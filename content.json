[{"title":"Appium测试【第一章】","date":"2018-02-08T11:03:59.000Z","path":"2018/02/08/2018-02-08-android-01/","text":"安装环境Mac下必须手工安装，下载包吧。。。 https://developer.android.com/studio/releases/platform-tools.html#download cd ~/Downloads(你的下载目录)/ unzip android-sdk*.zip mv android-sdk-macosx/ ~/.android-sdk-macosx echo &apos;export PATH=$PATH:~/.android-sdk-macosx/platform-tools/&apos; &gt;&gt; ~/.bash_profile source ~/.bash_profile 测试是否正常安装 adb devices 这样吧","tags":[{"name":"Appium测试","slug":"Appium测试","permalink":"//www.zwting.com/tags/Appium测试/"}]},{"title":"在MacMini上安装CentOS7","date":"2017-11-24T11:03:59.000Z","path":"2017/11/24/2017-11-24-system-01/","text":"1.123456789101112➜ iso hdiutil convert -format UDRW -o CentOS-7-x86_64-Minimal.iso CentOS-7-x86_64-Minimal-1503.iso正在读取Master Boot Record（MBR：0）…正在读取CentOS 7 x86_64 （Apple_ISO：1）…正在读取（Type EF：2）….正在读取CentOS 7 x86_64 （Apple_ISO：3）…...................................................................................................................................已耗时： 3.237s速度：174.2M 字节/秒节省：0.0%created: /data/tool/iso/CentOS-7-x86_64-Minimal.iso.dmg 2.1234567891011121314151617➜ iso diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *121.3 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_CoreStorage Macintosh HD 120.5 GB disk0s2 3: Apple_Boot Recovery HD 650.0 MB disk0s3/dev/disk1 (internal, virtual): #: TYPE NAME SIZE IDENTIFIER 0: Apple_HFS Macintosh HD +120.1 GB disk1 Logical Volume on disk0s2 CD6B5894-7339-4A3F-B2BA-46C8784AB504 Unencrypted/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *8.2 GB disk2 1: DOS_FAT_32 DREAM 8.2 GB disk2s1 3.12345➜ iso sudo dd if=CentOS-7-x86_64-Minimal.iso.dmg of=/dev/disk2 bs=1mPassword:dd: /dev/disk2: Resource busy➜ iso diskutil unmountDisk /dev/disk2Unmount of all volumes on disk2 was successful 4.1➜ iso sudo dd if=CentOS-7-x86_64-Minimal.iso.dmg of=/dev/disk2 bs=1m U盘会自动退出来，然后不可识别 5.开始时按住option（alt)键，进入UEFI，选择U盘启动。 问题： 1.设置基础软件仓库错误 进入安装界面以后，设置安装介质位置提示错误，中文提示是：设置基础软件仓库错误，英文是：error setting up base repository 这个错误找了好久， 才在一个英文网站上面找到了解决办法，根本问题还是安装文件的问题，点进去它有两个选项，大致是安装源来自1. iso文件，2.来自网络，点击iso文件旁边那个验证，马上出错只能重启。 解决办法是使用网络安装源， 首先退出，在 第四个网络设置上面设置你的网络连接，使网络连接可用，然后在回到第一个安装源设置里面，在http://后面输入 buildlogs.centos.org/centos/7/os/x86_64-20140614，在后面的proxy（代理设置）里面填入 buildlogs.centos.org:80，点击完成，这个错误就解决了。再设置硬盘分区","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第八章】","date":"2017-11-21T11:03:59.000Z","path":"2017/11/21/2017-11-21-erlang-07/","text":"8.10 动态代码载入 b.erl 12345-module(b).-export([x/0]).x() -&gt; 2. a.erl 1234567891011121314151617181920212223-module(a).-compile(export_all).-export([]).start(Tag) -&gt; spawn(fun() -&gt; loop(Tag) end).loop(Tag) -&gt; sleep(), Val = b:x(), io:format(\"Vsn2 (~p) b:x() = ~p~n\",[Tag, Val]), loop(Tag).sleep() -&gt; receive after 3000 -&gt; true end. 在任一时刻，Erlang允许一个模块的两个版本同时运行：当前版和旧版。重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版。可以把这想象成一个带有两个版本代码的移位寄存器。当添加新代码时，最老的版本就被清除了。一些进程可以运行旧版代码，与此同时，另一些则可以运行新版代码 8.1 进程字典每个Erlang进程都有一个被称为进程字典（process dictionary）的私有数据存储区域。进程字典是一个关联数组（在其他语言里可能被称作map、hashmap或者散列表），它由若干个键和值组成。每个键只有一个值。 put(Key,Val).给进程字典添加一个Key, Value组合。put的值是OldValue，也就是Key之前关联的值。如果没有之前的值，就返回原子undefined。 get(Key).查找Key的值。如果字典里存在Key, Value组合就返回Value，否则返回原子undefined。 get().返回整个字典，形式是一个由{Key,Value}元组所构成的列表。 get_keys().返回一个列表，内含字典里所有值为Value的键。 erase(x).返回Key的关联值，如果不存在则返回原子undefined。最后，删除Key的关联值。 erase().删除整个进程字典。返回值是一个由{Key,Value}元组所构成的列表，代表了字典删除之前的状态。 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第五章】","date":"2017-11-21T11:03:59.000Z","path":"2017/11/21/2017-11-21-erlang-05/","text":"第5章 记录与映射组 元组用于保存固定数量的元素，而列表用于保存可变数量的元素。 记录（record）和映射组（map）。记录其实就是元组的另一种形式。通过使用记录，可以给元组里的各个元素关联一个名称。 记录适合以下的情形：： 当你可以用一些预先确定且数量固定的原子来表示数据时； 当记录里的元素数量和元素名称不会随时间而改变时； 当存储空间是个问题时，典型的案例是你有一大堆元组，并且每个元组都有相同的结构。 1234567-module(myconf).-record(server_opts, &#123;port, ip = \"127.0.0.1\", max_connections = 10&#125;).%%#server_opts&#123;port = 8000,ip = \"192.168.56.101\",%%max_connections = 10&#125;%%%%Opts#server_opts.port. 映射组适合以下的情形： 当键不能预先知道时用来表示键值数据结构； 当存在大量不同的键时用来表示数据； 当方便使用很重要而效率无关紧要时作为万能的数据结构使用； 用作“自解释型”的数据结构，也就是说，用户容易从键名猜出值的含义； 用来表示键值解析树，例如XML或配置文件； 用JSON来和其他编程语言通信。 映射组在系统内部是作为有序集合存储的，打印时总是使用各键排序后的顺序，与映射组的创建方式无关。 使用映射组的最佳方式是在首次定义某个键时总是使用Key =&gt; Val，而在修改具体某个键的值时都使用Key := Val 1Facts = #&#123;a =&gt;1, b=&gt;2&#125;. jsonmaps:to_json(Map) -&gt;Bin maps:from_json(Bin) -&gt;Map maps:safe_from_json(Bin) -&gt;Map 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第十一章】","date":"2017-11-21T11:03:59.000Z","path":"2017/11/21/2017-11-24-erlang-11/","text":"并发编程只需要三个新的基本函数：spawn、send和 receive。spawn创建一个并行进程，send向某个进程发送消息，receive则是接收消息 在Erlang里： 创建和销毁进程是非常快速的； 在进程间发送消息是非常快速的； 进程在所有操作系统上都具有相同的行为方式； 可以拥有大量进程； 进程不共享任何内存，是完全独立的； 进程唯一的交互方式就是消息传递。 出于这些原因，Erlang有时会被称为是一种纯消息传递式语言 12.1 基本并发函数 Pid = spawn(Mod, Func, Args). 创建一个新的并发进程来执行apply(Mod, Func, Args)。这个新进程和调用进程并列运行。spawn返回一个Pid（process identifier的简称，即进程标识符）。可以用Pid来给此进程发送消息。请注意，元数为length(Args)的Func函数必须从Mod模块导出。当一个新进程被创建后，会使用最新版的代码定义模块。 Pid = spawn(Fun). 创建一个新的并发进程来执行Fun()。这种形式的spawn总是使用被执行fun的当前值，而且这个fun无需从模块里导出。 Pid!Message 向标识符为Pid的进程发送消息Message。消息发送是异步的。发送方并不等待，而是会继续之前的工作。!被称为发送操作符。 Pid ! M被定义为M。因此，Pid1 ! Pid2 !…! Msg的意思是把消息Msg发送给Pid1、Pid2等所有进程。 receive … end 接收发送给某个进程的消息。它的语法如下： 1234567receive Pattern1 [when Guard1] -&gt; Expressions1; Pattern2 [when Guard2] -&gt; Expressions2; ......end. 当某个消息到达进程后，系统会尝试将它与Pattern1（以及可选的关卡Guard1）匹配， 如果成功就执行Expressions1。如果第一个模式不匹配，就会尝试Pattern2，以此类推。如果没有匹配的模式，消息就会被保存起来供以后处理，进程则会开始等待下一条消息。 一个并发程序模板1-module(ctemplate). -compile(export_all). start() -&gt; spawn(?MODULE, loop, []). rpc(Pid, Request) -&gt; Pid ! &#123;self(), Request&#125;, receive &#123;Pid, Response&#125; -&gt; Response end. loop(X) -&gt; receive Any -&gt; io:format(\"Received:~p~n\",[Any]), loop(X) end. 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第三章】","date":"2017-11-20T11:30:59.000Z","path":"2017/11/20/2017-11-20-erlang-03/","text":"第3章 基本概念变量 记得上学的时候，数学老师曾说过：“如果一个等式中有好几处X，那么所有X都是一样的。”我们就是这么解方程的：如果知道X+Y=10且XY=2，那么这两个等式里的X就都等于6，Y都等于4. Erlang的变量是一次性赋值变量（single-assignment variable）,在Erlang里，变量只不过是对某个值的引用：Erlang的实现方式用指针代表绑定变量，指向一个包含值的存储区。这个值不能被修改。 注意 f()命令让shell忘记现有的任何绑定。在这个命令之后，所有变量都会变成未绑定状态 在大多数语言里，=表示一个赋值语句。而在Erlang里，=是一次模式匹配操作。Lhs = Rhs的真正意思是：计算右侧（Rhs）的值，然后将结果与左侧（Lhs）的模式相匹配。 浮点数 N div M是让N除以M然后舍去余数。N rem M是N除以M后剩下的余数。 原子 在Erlang里，原子是全局性的，而且不需要宏定义或包含文件就能实现 原子以小写字母开头，后接一串字母、数字、下划线（）或a（tcat、meters、yards、joe@somehost和a_long_name 原子还可以放在单引号（’）内。可以用这种引号形式创建以大写字母开头（否则会被解释成变量）或包含字母数字以外字符的原子，例如’Monday’、’Tuesday’、’+’、’*’和’an atom with spaces’。甚至可以给无需引号的原子加上引号，因此’a’和a的意思完全一致。在某些语言里，单引号和双引号可以互换使用。Erlang里不是这样。单引号的用法如前面所示，双引号用于给字符串字面量（string literal）定界。一个原子的值就是它本身。所以，如果输入一个原子作为命令，Erlang shell就会打印出这个原子的值。 元组 如果想把一些数量固定的项目归组成单一的实体，就会使用元组（tuple）。创建元组的方法是用大括号把想要表示的值括起来，并用逗号分隔它们。 匹配时，等号两侧的元组必须有相同数量的元素，而且两侧的对应元素必须绑定为相同的值。 1234- 1&gt; P = &#123;person,&#123;name, joe,armstrong&#125;,&#123;footsize,42&#125;&#125;.- 2&gt; &#123;\\_,&#123;\\_,Who,\\_&#125;,\\_&#125; = P.- 3&gt; Who.- joe 列表 列表（list）被用来存放任意数量的事物。创建列表的方法是用中括号把列表元素括起来， 并用逗号分隔它们。 表的第一个元素被称为列表头（head）。假设把列表头去掉，剩下的就被称为列表尾（tail）。举个例子，如果有一个列表[1,2,3,4,5] ， 那么列表头就是整数1 ，列表尾则是列表[2,3,4,5]。请注意列表头可以是任何事物，但列表尾通常仍然是个列表。访问列表头是一种非常高效的操作，因此基本上所有的列表处理函数都从提取列表头开始， 然后对它做一些操作，接着处理列表尾。 如果T是一个列表，那么[H|T]也是一个列表，它的头是H，尾是T。竖线（|）把列表的头与尾分隔开。[]是一个空列表。LISP程序员请注意：[H|T]是一个CAR为H、CDR为T的CONS单元。此语法用在模式里会解析出CAR和CDR，用在表达式里则会构建一个CONS单元。无论何时，只要用[…|T]语法构建一个列表，就应该确保T是列表。如果它是，那么新列表就是“格式正确的”。如果T不是列表，那么新列表就被称为“不正确的列表”。大多数库函数假定列表有正确的形式，无法用于不正确的列表。可以给T的开头添加不止一个元素，写法是[E1,E2,..,En|T]。 字符串 严格来说，Erlang里没有字符串。要在Erlang里表示字符串，可以选择一个由整数组成的列表或者一个二进制型。模式匹配 {X,abc} = {123,abc} | 成功：X = 123 {X,Y,Z} = {222,def,&quot;cat&quot;} | 成功：X = 222，Y = def，Z = &quot;cat&quot; {X,Y} = {333,ghi,&quot;cat&quot;} | 失败：元组的形状不同 X = true | 成功：X = true {X,Y,X} = {{abc,12},42,{abc,12}} | 成功：X = {abc,12}，Y = 42 {X,Y,X} = {{abc,12},42,true} | 失败：X不能既是{abc,12}又是true [H \\ T] = [1,2,3,4,5] | 成功：H = 1，T = [2,3,4,5] [H \\ T] = &quot;cat&quot; | 成功：H = 99，T = &quot;at&quot; [A,B,C \\ T] = [a,b,c,d,e,f] | 成功：A = a，B = b，C = c，T = [d,e,f] 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第四章】","date":"2017-11-20T11:30:59.000Z","path":"2017/11/20/2017-11-20-erlang-04/","text":"第4章 模块与内置函数查看和修改当前的工作目录。 pwd()打印当前工作目录。 ls()列出当前工作目录里所有的文件名。 cd(Dir)修改当前工作目录至Dir。模块例子 模块是Erlang的基本代码单元。模块保存在扩展名为.erl的文件里，而且必须先编译才能运行模块里的代码。编译后的模块以.beam作为扩展名。 12345678-module(geometry).-export([area/1]).area(&#123;rectangle, Width, Height&#125;) -&gt; Width * Height;area(&#123;square, Side&#125;) -&gt; Side * Side. 运行演示： 123458&gt; c(geometry).&#123;ok,geometry&#125;9&gt; geometry:area(&#123;rectangle,2,3&#125;).610&gt; geometry:area(&#123;square,3&#125;). 分隔符说明 逗号（,）分隔函数调用、数据构造和模式中的参数。 分号（;）分隔子句。我们能在很多地方看到子句，例如函数定义，以及case、if、try..catch和receive表达式。 句号（.）（后接空白）分隔函数整体，以及shell里的表达式。有一种简单的方法可以记住这些：想想英语。句号分隔句子，分号分隔子句，逗号则分隔下级子句。逗号象征短程，分号象征中程，句号则象征长程。 4.2 购物车.1234567891011121314151617181920-module(shop).-export([cost/1, total/1, test/0]).cost(oranges) -&gt; 2;cost(milk) -&gt; 8;cost(pears) -&gt; 1.total([&#123;What, N&#125; | T]) -&gt; shop:cost(What) * N + total(T);total([]) -&gt; 0.test() -&gt; %% shop:total([]). shop:total([&#123;milk, 8&#125;,&#123;pears,8&#125;]). 总结运算模型 1234total([Head|Tail])-&gt; to_do_funtion(Head) + total(Tail);total([])-&gt; 0. 4.3 fun：基本的抽象单元4.3.0 匿名函数 fun可以有任意数量的参数。 12345678943&gt; Double = fun(X) -&gt; 2*X end.#Fun&lt;erl_eval.6.52032458&gt;44&gt; Double(4).849&gt; Hypot = fun(X,Y) -&gt; math:sqrt(X*X + Y*Y) end.#Fun&lt;erl_eval.12.52032458&gt;50&gt; Hypot(3,4).5.0 4.3.1 以fun作为参数的函数123456789-module(btest).-export([test/0]).test() -&gt; Even = fun(X) -&gt; (X rem 2) =:= 0 end, %% lists:map(Even,[1,2,3,4,5,6]). lists:filter(Even,[1,2,3,4,5,6]). map和filter等函数能在一次调用里对整个列表执行某种操作，我们把它们称为一次一列表（list-at-a-time）式操作。使用一次一列表式操作让程序变得更小，而且易于理解。 4.3.1 返回fun的函数123456789-module(btest).-export([test2/0]).test2() -&gt; Mult = fun(Times) -&gt; (fun(X) -&gt; X * Times end ) end, T = Mult(3), T(5). 运行： 123473&gt; c(btest).&#123;ok,btest&#125;74&gt; btest:test2().15 括号里的fun是fun(X) -&gt; X * Times end，它只是一个关于X的函数。Times是“外部”fun的参数。 Mult(3)执行后返回fun(X) -&gt; X * 3 end，即内部fun的主体（Times被替换为3）。现在我们可以测试它了。 列表推导123475&gt; L = [1,2,3,4,5,6].[1,2,3,4,5,6]76&gt; [2*X || X &lt;- L].[2,4,6,8,10,12] -[ F(X) || X &lt;- L]标记的意思是“由F(X)组成的列表（X从列表L中提取）”。因此，[2 *X|| X &lt;- L ]的意思就是“由2*X组成的列表（X从列表L中提取）”。 毕达哥拉斯三元数组12345678910111213141516171819202122-module(btest).-export([test/1]).test(N) -&gt; [ &#123;A,B,C&#125;|| A &lt;-lists:seq(1,N), B &lt;-lists:seq(1,N), C &lt;-lists:seq(1,N), A+B+C =&lt; N, A*A + B*B =:= C*C ]. 77&gt; c(btest).&#123;ok,btest&#125;78&gt; btest:test3(15).[&#123;3,4,5&#125;,&#123;4,3,5&#125;] ``` - lists:seq(1, N)返回一个包含从1到N所有整数的列表。因此，A &lt;- lists: seq(1, N)的意思是A提取从1到N的所有可能值。所以这个程序可以这样念：“提取1到N的所有A 值，1到N的所有B值，1到N的所有C值，条件是A + B + C小于等于N并且A*A + B*B = C*C。##### 关卡 is_tuple(T), tuple_size(T) =:=6, abs(element(3,T)) &gt;5 1- 第一行的意思是T是一个包含六个元素的元组，并且T中第三个元素的绝对值大于5。关卡里分隔各个测试的逗号的意思是“并且”。 X =:=dog; X=:= catis_integer(X), X&gt;Y; abs(Y) &lt; 2312345- 第一个关卡的意思是X是一个cat或者dog，关卡里分号（;）的意思是“或者”。第二个关卡的意思是X是一个整数，并且X大于Y或者Y的绝对值小于23。 ##### 所有的关卡判断函数（即返回布尔值的关卡）和所有的关卡内置函数 |关卡判断函数 |意 思| |---------|-----| is_atom(X) |X是一个原子 is_binary(X) |X是一个二进制型 is_constant(X) |X是一个常量 is_float(X) |X是一个浮点数 is_function(X) |X是一个fun is_function(X, N) |X是一个带有N个参数的fun is_integer(X)| X是一个整数 is_list(X) |X是一个列表 is_map(X) |X是一个映射组 is_number(X) |X是一个整数或浮点数 is_pid(X) |X是一个进程标识符 is_pmod(X) |X是一个参数化模块的实例 is_port(X) |X是一个端 is_reference(X) |X是一个引用 is_tuple(X) |X是一个元组 is_record(X,Tag) |X是一个类型为Tag的记录 is_record(X,Tag,N) |X是一个类型为Tag、大小为N的记录 ##### 归集器- 把某个整数列表一分为二，分别包含原始列表里的奇数和偶数。 -module(mmisc). -export([odds_wqc_evens/1, adds_add_evens_acc/3]). odds_wqc_evens(L) -&gt; adds_add_evens_acc(L, [], []). adds_add_evens_acc([H|T], Odds, Evens) -&gt; case (H rem 2) of 1 -&gt; adds_add_evens_acc(T,[H|Odds], Evens); 0 -&gt; adds_add_evens_acc(T,Odds, [H|Evens]) end; adds_add_evens_acc([], Odds, Evens) -&gt; {Odds, Evens}. 1运行： 18&gt; c(mmisc).{ok,mmisc}19&gt; mmisc:odds_wqc_evens([1,2,3,4,5,6,7,8]).{[7,5,3,1],[8,6,4,2]}``` 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第二章】","date":"2017-11-12T11:30:59.000Z","path":"2017/11/12/2017-11-14-erlang-02/","text":"第2章 Erlang速览变量和原子的语法 Erlang的变量只能绑定一次。 Erlang的变量以大写字母开头。 在 shell 里编译并运行 Hello Worlderl文件命令成 hello.erl 输入以下内容 1234567- module(hello).- export([start/0]).start()-&gt; io:format(\"hello world ~n\").``` 编译并运行它，我们从保存hello.erl的目录里启动Erlang shell erlErlang/OTP 19 [erts-8.2] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] Eshell V8.2 (abort with ^G) 1&gt; c(hello,debug_info).{ok,hello}9&gt; hello:start().hello worldok123456789##### 并发- Erlang的基本并发单元是进程（process）。- 只能通过发送和接收消息来与其他进程通信。- loop函数永远不会返回，利用尾部的优化，意思是此函数的运行空间是固定的，不会耗尽栈空间- Erlang编译器和运行时系统会正确推断出如何在收到消息时运行适当的代码。不需要编写任何的if-then-else或switch语句来设定该做什么。这是模式匹配带来的乐趣之一，会为你节省大量工作##### server cat afile_server.erl -module(afile_server).-export([start/1,loop/1]). start(Dir) -&gt; spawn(afile_server,loop, [Dir]). loop(Dir) -&gt; receive {Client, list_dir} -&gt; Client ! { self(), file:list_dir(Dir)}; {Client, {get_file, File}} -&gt; Full = filename:join(Dir, File), Client ! {self(), file:read(Full)} end, loop(Dir).12 ➜ src erlErlang/OTP 19 [erts-8.2] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] Eshell V8.2 (abort with ^G)1&gt; c(afile_server).{ok,afile_server}2&gt; FS = afile_server:start(“.”). 3&gt; FS ! {self(),list_dir}3&gt; .{,list_dir}4&gt; receive X-&gt;X end.{, {ok,[“afile_server.beam”,”afile_server.erl”, “file_server.beam”,”hello.beam”,”hello.erl”,”test.beam”, “test.erl”]}}5&gt;12##### client -module(afile_client).-export([ls/1, get_file/2]). ls(Server) -&gt; Server ! {self(), list_dir}, receive {Server, FileList} -&gt; FileList end. get_file(Server, File) -&gt; Server ! {self(), {get_file, File}}, receive {Server, Content} -&gt; Content end. 12 1&gt; c(afile_server).{ok,afile_server}2&gt; c(afile_client).{ok,afile_client}3&gt; FS = afile_server:start(“.”). 4&gt; afile_client:ls(“./“).** exception error: bad argument in function afile_client:ls/1 (afile_client.erl, line 15)5&gt; afile_client:ls(FS).{ok,[“afile_client.beam”,”afile_client.erl”, “afile_server.beam”,”afile_server.erl”,”file_server.beam”, “hello.beam”,”hello.erl”,”test.beam”,”test.erl”]}``` 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"在台机器上登录两个GITHUB账号","date":"2017-11-12T11:30:59.000Z","path":"2017/11/12/2017-11-13-git-hacker/","text":"### git config –global –unset user.name git config –global –unset user.email ssh-keygen -t rsa -C &quot;TEST2@gmail.com&quot; -f ~/.ssh/TEST2 ssh-keygen -t rsa -C &quot;TEST1@gmail.com&quot; -f ~/.ssh/TEST1 TEST1 and TEST2两个账号在GITHUB上cat ~/.ssh/config Host gitlab.test.com HostName gitlab.test.com PreferredAuthentications publickey IdentityFile ~/.ssh/innergit Host TEST1.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/TEST1 Host TEST2.github.com HostName github.com User TEST2 PreferredAuthentications publickey IdentityFile ~/.ssh/TEST2 使用git clone git@TEST2.github.com:TEST2/Alcman.git cd project_name1 git config user.name &quot;TEST2&quot; git config user.email &quot;TEST2@gmail.com&quot; cd project_name2 git clone git@TEST1.github.com:TEST1/rake-flow.git git config user.name &quot;TEST1&quot; git config user.email &quot;TEST1@gmail.com&quot;","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"Erlang程序设计(第2版) 读书笔记【第一章】","date":"2017-11-12T11:30:59.000Z","path":"2017/11/12/2017-11-13-erlang-01/","text":"第1章 什么是并发并发和并行含义 区分基于操作系统的并发和基于语言的并发很重要，因为如果使用基于操作系统的并发，那么程序在不同的操作系统上就会有不同的工作方式。Erlang的并发在所有操作系统上都有着相同的工作方式。要用Erlang编写并发程序，只需掌握Erlang，而不必掌握操作系统的并发机制 并发程序是一种用并发编程语言编写的程序。编写并发程序是为了提升性能、可扩展性和容错性。（nodejs erlang） 并发编程语言拥有专门用于编写并发程序的语言结构。这些结构是编程语言的主要部分， 在所有操作系统上都有着相同的表现。 并行计算机是一种有多个处理单元（CPU或核心）同时运行的计算机。 模块和函数12345-module(test). %%模块声明-export([init/1]). %%导出声明init(Name) -&gt; io:format(\"~w~n\",[Name]). 模块名必须以一个小写字母开头。 导出声明指明了模块里哪些函数可以从模块外部进行调用。 -export([init/1]).语法的意思是带有一个参数。 -export([funcname1/1，funcname2/1，funcname3/1，]). 导出多个函数列表的写法。 erlang起进程1234567891011121314-module(test).-export([init/1]). %%导出声明-export([start/0]). %%导出声明start() -&gt; debugger:start(), spawn(test,init,[\"hello\"]).init(Name) -&gt; io:format(\"~w~n\",[Name]). spawn(ModName,FunName,[Arg1,Arg2,….]) 当Erlang运行时系统执行spawn时，它会创建一个新进程（不是操作系统的进程，而是一个由Erlang系统管理的轻量级进程）。当进程创建完毕后，它便开始执行参数所指定的代码。ModName 是包含想要执行代码的模块名。FuncName是模块里的函数名，而[Arg1, Arg2, …]是一个列表，包含了想要执行的函数参数。因此，下面这个调用的意思是启动一个执行函数person:init(“hello”)的进程 发送消息1Susannah!&#123;self(),\"send message\"&#125; Pid ! Msg语法的意思是发送消息Msg到进程Pid。大括号里的self()参数标明了发送消息的进程（在此处是Joe）。 接收消息1234receive &#123;From, Message&#125; -&gt; ......end 当Susannah的进程接收到一条消息时，变量From会绑定为Joe，这样Susannah就知道消息来自何处，变量Message则会包含此消息 这样吧","tags":[{"name":"Erlang程序设计的读书笔记","slug":"Erlang程序设计的读书笔记","permalink":"//www.zwting.com/tags/Erlang程序设计的读书笔记/"}]},{"title":"","date":"2017-10-31T07:31:49.000Z","path":"2017/10/31/2017-10-31-python-hacker/","text":"网络 Scapy, Scapy3k: 发送，嗅探，分析和伪造网络数据包。可用作交互式包处理程序或单独作为一个库。 pypcap, Pcapy, pylibpcap: 几个不同 libpcap 捆绑的python库 libdnet: 低级网络路由，包括端口查看和以太网帧的转发 dpkt: 快速，轻量数据包创建和分析，面向基本的 TCP/IP 协议 Impacket: 伪造和解码网络数据包，支持高级协议如 NMB 和 SMB pynids: libnids 封装提供网络嗅探，IP 包碎片重组，TCP 流重组和端口扫描侦查 Dirtbags py-pcap: 无需 libpcap 库支持读取 pcap 文件 flowgrep: 通过正则表达式查找数据包中的 Payloads Knock Subdomain Scan: 通过字典枚举目标子域名 SubBrute: 快速的子域名枚举工具 Mallory: 可扩展的 TCP/UDP 中间人代理工具，可以实时修改非标准协议 Pytbull: 灵活的 IDS/IPS 测试框架（附带超过300个测试样例） 调试和逆向工程 Paimei: 逆向工程框架，包含 PyDBG, PIDA,pGRAPH Immunity Debugger: 脚本 GUI 和命令行调试器 mona.py: Immunity Debugger 中的扩展，用于代替 pvefindaddr IDAPython: IDA pro 中的插件，集成 Python 编程语言，允许脚本在 IDA Pro 中执行 PyEMU: 全脚本实现的英特尔32位仿真器，用于恶意软件分析 pefile: 读取并处理 PE 文件 pydasm: Python 封装的 libdasm PyDbgEng: Python 封装的微软 Windows 调试引擎 uhooker: 截获 DLL 或内存中任意地址可执行文件的 API 调用 diStorm: AMD64 下的反汇编库 python-ptrace: Python 写的使用 ptrace 的调试器 vdb/vtrace: vtrace 是用 Python 实现的跨平台调试 API, vdb 是使用它调试器 Androguard: 安卓应用程序的逆向分析工具 Capstone: 一个轻量级的多平台多架构支持的反汇编框架。支持包括ARM,ARM64,MIPS和x86/x64平台。 PyBFD: GNU 二进制文件描述(BFD)库的 Python 接口 Fuzzing Sulley: 一个模糊器开发和模糊测试的框架，由多个可扩展的构件组成的 Peach Fuzzing Platform: 可扩展的模糊测试框架(v2版本 是用 Python 语言编写的) antiparser: 模糊测试和故障注入的 API TAOF: (The Art of Fuzzing, 模糊的艺术)包含 ProxyFuzz, 一个中间人网络模糊测试工具 untidy: 针对 XML 模糊测试工具 Powerfuzzer: 高度自动化和可完全定制的 Web 模糊测试工具 SMUDGE: 纯 Python 实现的网络协议模糊测试 Mistress: 基于预设模式，侦测实时文件格式和侦测畸形数据中的协议 Fuzzbox: 媒体多编码器的模糊测试 Forensic Fuzzing Tools: 通过生成模糊测试用的文件，文件系统和包含模糊测试文件的文件系统，来测试取证工具的鲁棒性 Windows IPC Fuzzing Tools: 使用 Windows 进程间通信机制进行模糊测试的工具 WSBang: 基于 Web 服务自动化测试 SOAP 安全性 Construct: 用于解析和构建数据格式(二进制或文本)的库 fuzzer.py(feliam): 由 Felipe Andres Manzano 编写的简单模糊测试工具 Fusil: 用于编写模糊测试程序的 Python 库 Web Requests: 优雅，简单，人性化的 HTTP 库 HTTPie: 人性化的类似 cURL 命令行的 HTTP 客户端 ProxMon: 处理代理日志和报告发现的问题 WSMap: 寻找 Web 服务器和发现文件 Twill: 从命令行界面浏览网页。支持自动化网络测试 Ghost.py: Python 写的 WebKit Web 客户端 Windmill: Web 测试工具帮助你轻松实现自动化调试 Web 应用 FunkLoad: Web 功能和负载测试 spynner: Python 写的 Web浏览模块支持 Javascript/AJAX python-spidermonkey: 是 Mozilla JS 引擎在 Python 上的移植，允许调用 Javascript 脚本和函数 mitmproxy: 支持 SSL 的 HTTP 代理。可以在控制台接口实时检查和编辑网络流量 pathod/pathoc: 变态的 HTTP/S 守护进程，用于测试和折磨 HTTP 客户端 取证 Volatility: 从 RAM 中提取数据 Rekall: Google 开发的内存分析框架 LibForensics: 数字取证应用程序库 TrIDLib: Python 实现的从二进制签名中识别文件类型 aft: 安卓取证工具集恶意软件分析 pyew: 命令行十六进制编辑器和反汇编工具，主要用于分析恶意软件 Exefilter: 过滤 E-mail，网页和文件中的特定文件格式。可以检测很多常见文件格式，也可以移除文档内容。 pyClamAV: 增加你 Python 软件的病毒检测能力 jsunpack-n: 通用 JavaScript 解释器，通过模仿浏览器功能来检测针对目标浏览器和浏览器插件的漏洞利用 yara-python: 对恶意软件样本进行识别和分类 phoneyc: 纯 Python 实现的蜜罐 CapTipper: 分析，研究和重放 PCAP 文件中的 HTTP 恶意流量 PDF peepdf: Python 编写的PDF文件分析工具，可以帮助检测恶意的PDF文件 Didier Stevens’ PDF tools: 分析，识别和创建 PDF 文件(包含PDFiD，pdf-parser，make-pdf 和 mPDF) Opaf: 开放 PDF 分析框架，可以将 PDF 转化为 XML 树从而进行分析和修改。 Origapy: Ruby 工具 Origami 的 Python 接口，用于审查 PDF 文件 pyPDF2: Python PDF 工具包包含：信息提取，拆分，合并，制作，加密和解密等等 PDFMiner: 从 PDF 文件中提取文本 python-poppler-qt4: Python 写的 Poppler PDF 库，支持 Qt4 杂项 InlineEgg: 使用 Python 编写的具有一系列小功能的工具箱 Exomind: 是一个利用社交网络进行钓鱼攻击的工具 RevHosts: 枚举指定 IP 地址包含的虚拟主句 simplejson: JSON 编码和解码器，例如使用 Google’s AJAX API PyMangle: 命令行工具和一个创建用于渗透测试使用字典的库 Hachoir: 查看和编辑二进制流 其他有用的库和工具 IPython: 增强的交互式 Python shell Beautiful Soup: HTML 解析器 matplotlib: 制作二维图 Mayavi: 三维科学数据的可视化与绘图 RTGraph3D: 在三维空间中创建动态图 Twisted: Python 语言编写的事件驱动的网络框架 Suds: 一个轻量级的基于SOAP的python客户端 M2Crypto: Python 语言对 OpenSSL 的封装 NetworkX: 图库(边, 节点) Pandas: 基于 Numpy 构建的含有更高级数据结构和工具的数据分析包 pyparsing: 通用解析模块 lxml: 使用 Python 编写的库，可以迅速、灵活地处理 XML Whoosh: 纯python实现的全文搜索组件 Pexpect: 控制和自动化程序 Sikuli: 使用 Jython 脚本自动化基于截图进行视觉搜索 PyQt 和PySide: Python 捆绑的 Qt 应用程序框架和 GUI 库","tags":[]},{"title":"","date":"2017-10-31T07:15:41.000Z","path":"2017/10/31/2017-10-31-python-hacker2/","text":"Python 资源大全中文版本项目的参与者 贡献者：艾凌风、Namco、Daetalus、黄利民、atupal、rainbow、木头lbj、beyondwu、cissoid、李广胜、polyval、冰斌、赵叶宇、л stalgic、硕恩、strongit、yuukilp 注：名单不分排名，不定期补充更新 环境管理管理 Python 版本和环境的工具 p：非常简单的交互式 python 版本管理工具。官网 pyenv：简单的 Python 版本管理工具。官网 Vex：可以在虚拟环境中执行命令。官网 virtualenv：创建独立 Python 环境的工具。官网 virtualenvwrapper：virtualenv 的一组扩展。官网 包管理管理包和依赖的工具。 pip：Python 包和依赖关系管理工具。官网 pip-tools：保证 Python 包依赖关系更新的一组工具。官网 conda：跨平台，Python 二进制包管理工具。官网 Curdling：管理 Python 包的命令行工具。官网 wheel：Python 分发的新标准，意在取代 eggs。官网 包仓库本地 PyPI 仓库服务和代理。 warehouse：下一代 PyPI。官网 Warehouse：PyPA 提供的 PyPI 镜像工具。官网 bandersnatch devpi：PyPI 服务和打包/测试/分发工具。官网 localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。官网 分发打包为可执行文件以便分发。 PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。官网 dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。官网 Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。官网 py2app：将 Python 脚本变为独立软件包（Mac OS X）。官网 py2exe：将 Python 脚本变为独立软件包（Windows）。官网 pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。官网 构建工具将源码编译成软件。 buildout：一个构建系统，从多个组件来创建，组装和部署应用。官网 BitBake：针对嵌入式 Linux 的类似 make 的构建工具。官网 fabricate：对任何语言自动找到依赖关系的构建工具。官网 PlatformIO：多平台命令行构建工具。官网 PyBuilder：纯 Python 实现的持续化构建工具。官网 SCons：软件构建工具。官网 交互式解析器交互式 Python 解析器。 IPython：功能丰富的工具，非常有效的使用交互式 Python。官网 bpython：界面丰富的 Python 解析器。官网 ptpython：高级交互式Python解析器， 构建于python-prompt-toolkit 之上。官网 文件文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。 imghdr：（Python 标准库）检测图片类型。官网 mimetypes：（Python 标准库）将文件名映射为 MIME 类型。官网 path.py：对 os.path 进行封装的模块。官网 pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。官网 python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。官网 Unipath：用面向对象的方式操作文件和目录。官网 watchdog：管理文件系统事件的 API 和 shell 工具官网 日期和时间操作日期和时间的类库。 arrow：更好的 Python 日期时间操作类库。官网 Chronyk：Python 3 的类库，用于解析手写格式的时间和日期。官网 dateutil：Python datetime 模块的扩展。官网 delorean：解决 Python 中有关日期处理的棘手问题的库。官网 moment：一个用来处理时间和日期的Python库。灵感来自于Moment.js。官网 PyTime：一个简单易用的Python模块，用于通过字符串来操作日期/时间。官网 pytz：现代以及历史版本的世界时区定义。将时区数据库引入Python。官网 when.py：提供用户友好的函数来帮助用户进行常用的日期和时间操作。官网 文本处理用于解析和操作文本的库。 通用 chardet：字符编码检测器，兼容 Python2 和 Python3。官网 difflib：(Python 标准库)帮助我们进行差异化比较。官网 ftfy：让Unicode文本更完整更连贯。官网 fuzzywuzzy：模糊字符串匹配。官网 Levenshtein：快速计算编辑距离以及字符串的相似度。官网 pangu.py：在中日韩语字符和数字字母之间添加空格。官网 yfiglet-figlet：pyfiglet -figlet 的 Python实现。 shortuuid：一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。官网 unidecode：Unicode 文本的 ASCII 转换形式 。官网 uniout：打印可读的字符，而不是转义的字符串。官网 xpinyin：一个用于把汉字转换为拼音的库。官网 simplejson：Python的JSON编码、解码器。官网、GitHub Slug化 awesome-slugify：一个 Python slug 化库，可以保持 Unicode。官网 python-slugify：Python slug 化库，可以把 unicode 转化为 ASCII。官网 unicode-slugify：一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。官网 解析器 phonenumbers：解析，格式化，储存，验证电话号码。官网 PLY：lex 和 yacc 解析工具的 Python 实现。官网 Pygments：通用语法高亮工具。官网 pyparsing：生成通用解析器的框架。官网 python-nameparser：把一个人名分解为几个独立的部分。官网 python-user-agents：浏览器 user agent 解析器。官网 sqlparse：一个无验证的 SQL 解析器。官网 特殊文本格式处理一些用来解析和操作特殊文本格式的库。 通用 tablib：一个用来处理中表格数据的模块。官网 Office Marmir：把输入的Python 数据结构转换为电子表单。官网 openpyxl：一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。官网 python-docx：读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。官网 unoconv：在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。官网 XlsxWriter：一个用于创建 Excel .xlsx 文件的 Python 模块。官网 xlwings：一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。官网 xlwt：读写 Excel 文件的数据和格式信息。官网 / xlrd relatorio：模板化OpenDocument 文件。官网 PDF PDFMiner：一个用于从PDF文档中抽取信息的工具。官网 PyPDF2：一个可以分割，合并和转换 PDF 页面的库。官网 ReportLab：快速创建富文本 PDF 文档。官网 Markdown Mistune：快速并且功能齐全的纯 Python 实现的 Markdown 解析器。官网 Python-Markdown：John Gruber’s Markdown 的 Python 版实现。官网 Python-Markdown2：纯 Python 实现的 Markdown 解析器，比 Python-Markdown 更快，更准确，可扩展。官网 YAML PyYAML：Python 版本的 YAML 解析器。官网 CSV csvkit：用于转换和操作 CSV 的工具。官网 Archive unp：一个用来方便解包归档文件的命令行工具。官网 自然语言处理用来处理人类语言的库。 NLTK：一个先进的平台，用以构建处理人类语言数据的 Python 程序。官网 jieba：中文分词工具。官网 langid.py：独立的语言识别系统。官网 Pattern：Python 网络信息挖掘模块。官网 SnowNLP：一个用来处理中文文本的库。官网 TextBlob：为进行普通自然语言处理任务提供一致的 API。官网 TextGrocery：一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。官网 文档用以生成项目文档的库。 Sphinx：Python 文档生成器。官网 awesome-sphinxdoc：官网 MkDocs：对 Markdown 友好的文档生成器。官网 pdoc：一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。官网 Pycco：文学编程（literate-programming）风格的文档生成器。官网 配置用来保存和解析配置的库。 config：logging 模块作者写的分级配置模块。官网 ConfigObj：INI 文件解析器，带验证功能。官网 ConfigParser：(Python 标准库) INI 文件解析器。官网 profig：通过多种格式进行配置，具有数值转换功能。官网 python-decouple：将设置和代码完全隔离。官网 命令行工具用于创建命令行程序的库。 命令行程序开发 asciimatics：跨平台，全屏终端包（即鼠标/键盘输入和彩色，定位文本输出），完整的复杂动画和特殊效果的高级API。官网 cement：Python 的命令行程序框架。官网 click：一个通过组合的方式来创建精美命令行界面的包。官网 cliff：一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。官网 clint：Python 命令行程序工具。官网 colorama：跨平台彩色终端文本。官网 docopt：Python 风格的命令行参数解析器。官网 Gooey：一条命令，将命令行程序变成一个 GUI 程序。官网 python-prompt-toolkit：一个用于构建强大的交互式命令行程序的库。官网 Pythonpy：在命令行中直接执行任何Python指令。官网 生产力工具 aws-cli：Amazon Web Services 的通用命令行界面。官网 bashplotlib：在终端中进行基本绘图。官网 caniusepython3：判断是哪个项目妨碍你你移植到 Python 3。官网 cookiecutter：从 cookiecutters（项目模板）创建项目的一个命令行工具。官网 doitlive：一个用来在终端中进行现场演示的工具。官网 howdoi：通过命令行获取即时的编程问题解答。官网 httpie：一个命令行HTTP 客户端，cURL 的替代品，易用性更好。官网 PathPicker：从bash输出中选出文件。官网 percol：向UNIX shell 传统管道概念中加入交互式选择功能。官网 SAWS：一个加强版的 AWS 命令行。官网 thefuck：修正你之前的命令行指令。官网 mycli：一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。官网 pgcli：Postgres 命令行工具，具有自动补全和语法高亮功能。官网 try：一个从来没有更简单的命令行工具，用来试用python库。官网 下载器用来进行下载的库. s3cmd：一个用来管理Amazon S3 和 CloudFront 的命令行工具。官网 s4cmd：超级 S3 命令行工具，性能更加强劲。官网 you-get：一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。官网 youtube-dl：一个小巧的命令行程序，用来下载 YouTube 视频。官网 图像处理用来操作图像的库. pillow：Pillow 是一个更加易用版的 PIL。官网 hmap：图像直方图映射。官网 imgSeek：一个使用视觉相似性搜索一组图片集合的项目。官网 nude.py：裸体检测。官网 pyBarcode：不借助 PIL 库在 Python 程序中生成条形码。官网 pygram：类似 Instagram 的图像滤镜。官网 python-qrcode：一个纯 Python 实现的二维码生成器。官网 Quads：基于四叉树的计算机艺术。官网 scikit-image：一个用于（科学）图像处理的 Python 库。官网 thumbor：一个小型图像服务，具有剪裁，尺寸重设和翻转功能。官网 wand：MagickWand的Python 绑定。MagickWand 是 ImageMagick的 C API 。官网 OCR光学字符识别库。 pyocr：Tesseract 和 Cuneiform 的一个封装(wrapper)。官网 pytesseract：Google Tesseract OCR 的另一个封装(wrapper)。官网 python-tesseract - Google Tesseract OCR 的一个包装类。 音频用来操作音频的库 audiolazy：Python 的数字信号处理包。官网 audioread：交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。官网 beets：一个音乐库管理工具及 MusicBrainz 标签添加工具官网 dejavu：音频指纹提取和识别官网 django-elastic-transcoder：Django + Amazon Elastic Transcoder。官网 eyeD3：一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。官网 id3reader：一个用来读取 MP3 元数据的 Python 模块。官网 m3u8：一个用来解析 m3u8 文件的模块。官网 mutagen：一个用来处理音频元数据的 Python 模块。官网 pydub：通过简单、简洁的高层接口来操作音频文件。官网 pyechonest：Echo Nest API 的 Python 客户端官网 talkbox：一个用来处理演讲/信号的 Python 库官网 TimeSide：开源 web 音频处理框架。官网 tinytag：一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。官网 mingus：一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。官网 Video用来操作视频和GIF的库。 moviepy：一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。官网 scikit-video：SciPy 视频处理常用程序。官网 地理位置地理编码地址以及用来处理经纬度的库。 GeoDjango：世界级地理图形 web 框架。官网 GeoIP：MaxMind GeoIP Legacy 数据库的 Python API。官网 geojson：GeoJSON 的 Python 绑定及工具。官网 geopy：Python 地址编码工具箱。官网 pygeoip：纯 Python GeoIP API。官网 django-countries：一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。官网 HTTP使用HTTP的库。 requests：人性化的HTTP请求库。官网 grequests：requests 库 + gevent ，用于异步 HTTP 请求.官网 httplib2：全面的 HTTP 客户端库。官网 treq：类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。官网 urllib3：一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。官网 数据库Python实现的数据库。 pickleDB：一个简单，轻量级键值储存数据库。官网 PipelineDB：流式 SQL 数据库。官网 TinyDB：一个微型的，面向文档型数据库。官网 ZODB：一个 Python 原生对象数据库。一个键值和对象图数据库。官网 数据库驱动用来连接和操作数据库的库。 MySQL：awesome-mysql系列 mysql-python：Python 的 MySQL 数据库连接器。官网 ysqlclient：mysql-python 分支，支持 Python 3。 oursql：一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.官网 PyMySQL：纯 Python MySQL 驱动，兼容 mysql-python。官网 PostgreSQL psycopg2：Python 中最流行的 PostgreSQL 适配器。官网 queries：psycopg2 库的封装，用来和 PostgreSQL 进行交互。官网 txpostgres：基于 Twisted 的异步 PostgreSQL 驱动。官网 其他关系型数据库 apsw：另一个 Python SQLite封装。官网 dataset：在数据库中存储Python字典 pymssql：一个简单的Microsoft SQL Server数据库接口。官网 NoSQL 数据库 cassandra-python-driver：Cassandra 的 Python 驱动。官网 HappyBase：一个为 Apache HBase 设计的，对开发者友好的库。官网 Plyvel：一个快速且功能丰富的 LevelDB 的 Python 接口。官网 py2neo：Neo4j restful 接口的Python 封装客户端。官网 pycassa：Cassandra 的 Python Thrift 驱动。官网 PyMongo：MongoDB 的官方 Python 客户端。官网 redis-py：Redis 的 Python 客户端。官网 telephus：基于 Twisted 的 Cassandra 客户端。官网 txRedis：基于 Twisted 的 Redis 客户端。官网 ORM实现对象关系映射或数据映射技术的库。 关系型数据库 Django Models：Django 的一部分。官网 SQLAlchemy：Python SQL 工具以及对象关系映射工具。官网 awesome-sqlalchemy系列 Peewee：一个小巧，富有表达力的 ORM。官网 PonyORM：提供面向生成器的 SQL 接口的 ORM。官网 python-sql：编写 Python 风格的 SQL 查询。官网 NoSQL 数据库 django-mongodb-engine：Django MongoDB 后端。官网 PynamoDB：Amazon DynamoDB 的一个 Python 风格接口。官网 flywheel：Amazon DynamoDB 的对象映射工具。官网 MongoEngine：一个Python 对象文档映射工具，用于 MongoDB。官网 hot-redis：为 Redis 提供 Python 丰富的数据类型。官网 redisco：一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。官网 其他 butterdb：Google Drive 电子表格的 Python ORM。官网 Web 框架全栈 Web 框架。 Django：Python 界最流行的 web 框架。官网 awesome-django系列 Flask：一个 Python 微型框架。官网 awesome-flask系列 pyramid：一个小巧，快速，接地气的开源Python web 框架。 awesome-pyramid系列 Bottle：一个快速小巧，轻量级的 WSGI 微型 web 框架。官网 CherryPy：一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。官网 TurboGears：一个可以扩展为全栈解决方案的微型框架。官网 web.py：一个 Python 的 web 框架，既简单，又强大。官网 web2py：一个全栈 web 框架和平台，专注于简单易用。官网 Tornado：一个web 框架和异步网络库。官网 权限允许或拒绝用户访问数据或功能的库。 Carteblanche：Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.官网 django-guardian：Django 1.2+ 实现了单个对象权限。官网 django-rules：一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。官网 CMS内容管理系统 odoo-cms: 一个开源的，企业级 CMS，基于odoo。官网 django-cms：一个开源的，企业级 CMS，基于 Django。官网 djedi-cms：一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。官网 FeinCMS：基于 Django 构建的最先进的内容管理系统之一。官网 Kotti：一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。官网 Mezzanine：一个强大的，持续的，灵活的内容管理平台。官网 Opps：一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。官网 Plone：一个构建于开源应用服务器 Zope 之上的 CMS。官网 Quokka：灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。官网 Wagtail：一个 Django 内容管理系统。官网 Widgy：最新的 CMS 框架，基于 Django。官网 电子商务用于电子商务以及支付的框架和库。 django-oscar：一个用于 Django 的开源的电子商务框架。官网 django-shop：一个基于 Django 的店铺系统。官网 Cartridge：一个基于 Mezzanine 构建的购物车应用。官网 shoop：一个基于 Django 的开源电子商务平台。官网 alipay：非官方的 Python 支付宝 API。官网 merchant：一个可以接收来自多种支付平台支付的 Django 应用。官网 money：货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.官网 python-currencies：显示货币格式以及它的数值。官网 RESTful API用来开发RESTful APIs的库 Django django-rest-framework：一个强大灵活的工具，用来构建 web API。官网 django-tastypie：为Django 应用开发API。官网 django-formapi：为 Django 的表单验证，创建 JSON APIs 。官网 Flask flask-api：为 flask 开发的，可浏览 Web APIs 。官网 flask-restful：为 flask 快速创建REST APIs 。官网 flask-restless：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。官网 flask-api-utils：为 Flask 处理 API 表示和验证。官网 eve：REST API 框架，由 Flask, MongoDB 等驱动。官网 Pyramid cornice：一个Pyramid 的 REST 框架 。官网 与框架无关的 falcon：一个用来建立云 API 和 web app 后端的高性能框架。官网 sandman：为现存的数据库驱动系统自动创建 REST APIs 。官网 restless：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。官网 ripozo：快速创建 REST/HATEOAS/Hypermedia APIs。官网 验证实现验证方案的库。 OAuth Authomatic：简单但是强大的框架，身份验证/授权客户端。官网 django-allauth：Django 的验证应用。官网 django-oauth-toolkit：为 Django 用户准备的 OAuth2。官网 django-oauth2-provider：为 Django 应用提供 OAuth2 接入。官网 Flask-OAuthlib：OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。官网 OAuthLib：一个 OAuth 请求-签名逻辑通用、 完整的实现。官网 python-oauth2：一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。官网 python-social-auth：一个设置简单的社会化验证方式。官网 rauth：OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。官网 sanction：一个超级简单的OAuth2 客户端实现。官网 其他 jose：JavaScript 对象签名和加密草案的实现。官网 PyJWT：JSON Web 令牌草案 01。官网 python-jws：JSON Web 签名草案 02 的实现。官网 python-jwt：一个用来生成和验证 JSON Web 令牌的模块。官网 模板引擎模板生成和词法解析的库和工具。 Jinja2：一个现代的，对设计师友好的模板引擎。官网 Chameleon：一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。官网 Genshi：Python 模板工具，用以生成 web 感知的结果。官网 Mako：Python 平台的超高速轻量级模板。官网 Queue处理事件以及任务队列的库。 celery：一个异步任务队列/作业队列，基于分布式消息传递。官网 huey：小型多线程任务队列。官网 mrq：Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。官网 rq：简单的 Python 作业队列。官网 simpleq：一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。官网 搜索对数据进行索引和执行搜索查询的库和软件。 django-haystack：Django 模块化搜索。官网 elasticsearch-py：Elasticsearch 的官方底层 Python 客户端。官网 elasticsearch-dsl-py：Elasticsearch 的官方高级 Python 客户端。官网 solrpy：solr的 Python 客户端。官网 Whoosh：一个快速的纯 Python 搜索引擎库。官网 动态消息用来创建用户活动的库。 django-activity-stream：从你的站点行为中生成通用活动信息流。官网 Stream-Framework：使用 Cassandra 和 Redis 创建动态消息和通知系统。官网 资源管理管理、压缩、缩小网站资源的工具。 django-compressor：将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。官网 django-storages：一个针对 Django 的自定义存储后端的工具集合。官网 fanstatic：打包、优化，并且把静态文件依赖作为 Python 的包来提供。官网 File Conveyor：一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。官网 Flask-Assets：帮你将 web 资源整合到你的 Flask app 中。官网 jinja-assets-compressor：一个 Jinja 扩展，用来编译和压缩你的资源。官网 webassets：为你的静态资源打包、优化和管理生成独一无二的缓存 URL。官网 缓存缓存数据的库。 Beaker：一个缓存和会话库，可以用在 web 应用和独立 Python脚本和应用上。官网 django-cache-machine：Django 模型的自动缓存和失效。官网 django-cacheops：具有自动颗粒化事件驱动失效功能的 ORM。官网 django-viewlet：渲染模板，同时具有额外的缓存控制功能。官网 dogpile.cache：dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。官网 HermesCache：Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。官网 johnny-cache：django应用缓存框架。官网 pylibmc：libmemcached 接口的 Python 封装。官网 电子邮件用来发送和解析电子邮件的库。 django-celery-ses：带有 AWS SES 和 Celery 的 Django email 后端。官网 envelopes：供人类使用的电子邮件库。官网 flanker：一个 email 地址和 Mime 解析库。官网 imbox：Python IMAP 库官网 inbox.py：Python SMTP 服务器。官网 inbox：一个开源电子邮件工具箱。官网 lamson：Python 风格的 SMTP 应用服务器。官网 mailjet：Mailjet API 实现，用来提供批量发送邮件，统计等功能。官网 marrow.mailer：高性能可扩展邮件分发框架。官网 modoboa：一个邮件托管和管理平台，具有现代的、简约的 Web UI。官网 pyzmail：创建，发送和解析电子邮件。官网 Talon：Mailgun 库，用来抽取信息和签名。官网 国际化用来进行国际化的库。 Babel：一个Python 的国际化库。官网 Korean：一个韩语词态库。官网 URL处理解析URLs的库 furl：一个让处理 URL 更简单小型 Python 库。官网 purl：一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。官网 pyshorteners：一个纯 Python URL 缩短库。官网 shorturl：生成短小 URL 和类似 bit.ly 短链的Python 实现。官网 webargs：一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。官网 HTML处理处理 HTML和XML的库。 BeautifulSoup：以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。官网 bleach：一个基于白名单的 HTML 清理和文本链接库。官网 cssutils：一个 Python 的 CSS 库。官网 html5lib：一个兼容标准的 HTML 文档和片段解析及序列化库。官网 lxml：一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。官网 MarkupSafe：为Python 实现 XML/HTML/XHTML 标记安全字符串。官网 pyquery：一个解析 HTML 的库，类似 jQuery。官网 untangle：将XML文档转换为Python对象，使其可以方便的访问。官网 xhtml2pdf：HTML/CSS 转 PDF 工具。官网 xmltodict：像处理 JSON 一样处理 XML。官网 爬取网络站点的库 Scrapy：一个快速高级的屏幕爬取及网页采集框架。官网 cola：一个分布式爬虫框架。官网 Demiurge：基于PyQuery 的爬虫微型框架。官网 feedparser：通用 feed 解析器。官网 Grab：站点爬取框架。官网 MechanicalSoup：用于自动和网络站点交互的 Python 库。官网 portia：Scrapy 可视化爬取。官网 pyspider：一个强大的爬虫系统。官网 RoboBrowser：一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。官网 网页内容提取用于进行网页内容提取的库。 Haul：一个可以扩展的图像爬取工具。官网 html2text：将 HTML 转换为 Markdown 格式文本官网 lassie：人性化的网页内容检索库。官网 micawber：一个小型网页内容提取库，用来从 URLs 提取富内容。官网 newspaper：使用 Python 进行新闻提取，文章提取以及内容策展。官网 opengraph：一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。官网 python-goose：HTML内容/文章提取器。官网 python-readability：arc90 公司 readability 工具的 Python 高速端口。官网 sanitize：为杂乱的数据世界带来调理性。官网 sumy：一个为文本文件和 HTML 页面进行自动摘要的模块。官网 textract：从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。官网 表单进行表单操作的库。 Deform：Python HTML 表单生成库，受到了 formish 表单生成库的启发。官网 django-bootstrap3：集成了 Bootstrap 3 的 Django。官网 django-crispy-forms：一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。官网 django-remote-forms：一个平台独立的 Django 表单序列化工具。官网 WTForms：一个灵活的表单验证和呈现库。官网 WTForms-JSON：一个 WTForms 扩展，用来处理 JSON 数据。官网 数据验证数据验证库。多用于表单验证。 Cerberus：A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.官网 colander：一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。官网 kmatch：一种用于匹配/验证/筛选 Python 字典的语言。官网 schema：一个用于对 Python 数据结构进行验证的库。官网 Schematics：数据结构验证。官网 valideer：轻量级可扩展的数据验证和适配库。官网 voluptuous：一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。官网 反垃圾技术帮助你和电子垃圾进行战斗的库。 django-simple-captcha：一个简单、高度可定制的Django 应用，可以为任何Django表单添加验证码。官网 django-simple-spam-blocker：一个用于Django的简单的电子垃圾屏蔽工具。官网 标记用来进行标记的库。 django-taggit：简单的 Django 标记工具。官网 管理面板管理界面库。 Ajenti：一个你的服务器值得拥有的管理面板。官网 django-suit：Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。官网 django-xadmin：Django admin 的一个替代品，具有很多不错的功能。官网 flask-admin：一个用于 Flask 的简单可扩展的管理界面框架。官网 flower：一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。官网 Grappelli：Django 管理界面的一个漂亮的皮肤。官网 Wooey：一个 Django 应用，可以为 Python 脚本创建 web 用户界面。官网 静态站点生成器静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。 Pelican：使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。官网 Cactus：为设计师设计的静态站点生成器。官网 Hyde：基于 Jinja2 的静态站点生成器。官网 Nikola：一个静态网站和博客生成器。官网 Tinkerer：Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。官网 Lektor：一个简单易用的静态 CMS 和博客引擎。官网 进程操作系统进程启动及通信库。 envoy：比 Python subprocess 模块更人性化。官网 sarge：另一 种 subprocess 模块的封装。官网 sh：一个完备的 subprocess 替代库。官网 并发和并行用以进行并发和并行操作的库。 multiprocessing：(Python 标准库) 基于进程的“线程”接口。官网 threading：(Python 标准库)更高层的线程接口。官网 eventlet：支持 WSGI 的异步框架。官网 gevent：一个基于协程的 Python 网络库，使用greenlet。官网 Tomorrow：用于产生异步代码的神奇的装饰器语法实现。官网 uvloop：在libuv之上超快速实现asyncio事件循环。官网 网络用于网络编程的库。 asyncio：(Python 标准库) 异步 I/O, 事件循环, 协程以及任务。官网 Twisted：一个事件驱动的网络引擎。官网 pulsar：事件驱动的并发框架。官网 diesel：基于Greenlet 的事件 I/O 框架。官网 pyzmq：一个 ZeroMQ 消息库的 Python 封装。官网 txZMQ：基于 Twisted 的 ZeroMQ 消息库的 Python 封装。官网 WebSocket帮助使用WebSocket的库。 AutobahnPython：给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 asyncio。官网 Crossbar：开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn).官网 django-socketio：给 Django 用的 WebSockets。官网 WebSocket-for-Python：为Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。官网 WSGI 服务器兼容 WSGI 的 web 服务器 gunicorn：Pre-forked, 部分是由 C 语言编写的。官网 uwsgi：uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。官网 bjoern：异步，非常快速，由 C 语言编写。官网 fapws3：异步 (仅对于网络端)，由 C 语言编写。官网 meinheld：异步，部分是由 C 语言编写的。官网 netius：异步，非常快速。官网 paste：多线程，稳定，久经考验。官网 rocket：多线程。官网 waitress：多线程, 是它驱动着 Pyramid 框架。官网 Werkzeug：一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。官网 RPC 服务器兼容 RPC 的服务器。 SimpleJSONRPCServer：这个库是 JSON-RPC 规范的一个实现。官网 SimpleXMLRPCServer：(Python 标准库) 简单的 XML-RPC 服务器实现，单线程。官网 zeroRPC：zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。官网 密码学 cryptography：这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。官网 hashids：在 Python 中实现 hashids 。官网 Paramiko：SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。官网 Passlib：安全密码存储／哈希库，官网 PyCrypto：Python 密码学工具箱。官网 PyNacl：网络和密码学(NaCl) 库的 Python 绑定。官网 图形用户界面用来创建图形用户界面程序的库。 curses：内建的 ncurses 封装，用来创建终端图形用户界面。官网 enaml：使用类似 QML 的Declaratic语法来创建美观的用户界面。官网 kivy：一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS平台上。官网 pyglet：一个Python 的跨平台窗口及多媒体库。官网 PyQt：跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4 和 Qt v5。官网 PySide：P跨平台用户界面框架 Qt 的 Python 绑定 ，支持Qt v4。官网 Tkinter：Tkinter 是 Python GUI 的一个事实标准库。官网 Toga：一个 Python 原生的, 操作系统原生的 GUI 工具包。官网 urwid：一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。官网 wxPython：wxPython 是 wxWidgets C++ 类库和 Python 语言混合的产物。官网 PyGObject：GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定官网 Flexx：Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。官网 游戏开发超赞的游戏开发库。 Cocos2d：cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。官网 Panda3D：由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用C++编写, 针对 Python 进行了完全的封装。官网 Pygame：Pygame 是一组 Python 模块，用来编写游戏。官网 PyOgre：Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。官网 PyOpenGL：OpenGL 的 Python 绑定及其相关 APIs。官网 PySDL2：SDL2 库的封装，基于 ctypes。官网 RenPy：一个视觉小说（visual novel）引擎。官网 日志用来生成和操作日志的库。 logging：(Python 标准库) 为 Python 提供日志功能。官网 logbook：Logging 库的替代品。官网 Eliot：为复杂的和分布式系统创建日志。官网 Raven：Sentry的 Python 客户端。官网 Sentry：实时记录和收集日志的服务器。官网 Testing进行代码库测试和生成测试数据的库。 测试框架 unittest：(Python 标准库) 单元测试框架。官网 nose：nose 扩展了 unittest 的功能。官网 contexts：一个 Python 3.3+ 的 BDD 框架。受到C# – Machine.Specifications的启发。官网 hypothesis：Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。官网 mamba：Python 的终极测试工具， 拥护BDD。官网 PyAutoGUI：PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。官网 pyshould：Should 风格的断言，基于 PyHamcrest。官网 pytest：一个成熟的全功能 Python 测试工具。官网 green：干净，多彩的测试工具。官网 pyvows：BDD 风格的测试工具，受Vows.js的启发。官网- Robot Framework：一个通用的自动化测试框架。官网 Web 测试 Selenium：Selenium WebDriver 的 Python 绑定。官网 locust：使用 Python 编写的，可扩展的用户加载测试工具。官网 sixpack：一个和语言无关的 A/B 测试框架。官网 splinter：开源的 web 应用测试工具。官网 Mock测试 mock：(Python 标准库) 一个用于伪造测试的库。官网 doublex：Python 的一个功能强大的 doubles 测试框架。官网 freezegun：通过伪造日期模块来生成不同的时间。官网 httmock：针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。官网 httpretty：Python 的 HTTP 请求 mock 工具。官网 responses：伪造 Python 中的 requests 库的一个通用库。官网 VCR.py：在你的测试中记录和重放 HTTP 交互。官网 对象工厂 factoryboy：一个 Python 用的测试固件 (test fixtures) 替代库。官网 mixer：另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。官网 modelmommy：为 Django 测试创建随机固件官网 代码覆盖率 coverage：代码覆盖率测量。官网 伪数据 faker：一个 Python 库，用来生成伪数据。官网 fake2db：伪数据库生成器。官网 radar：生成随机的日期/时间。官网 错误处理 FuckIt.py：FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。官网 代码分析和Lint工具进行代码分析，解析和操作代码库的库和工具。 代码分析 coala：语言独立和易于扩展的代码分析应用程序。官网 code2flow：把你的 Python 和 JavaScript 代码转换为流程图。官网 pycallgraph：这个库可以把你的Python 应用的流程(调用图)进行可视化。官网 pysonar2：Python 类型推断和检索工具。官网 Lint工具 Flake8：模块化源码检查工具: pep8, pyflakes 以及 co。官网 Pylint：一个完全可定制的源码分析器。官网 YAPF: Google的Python代码格式化工具。官网 pylama：Python 和 JavaScript 的代码审查工具。官网 代码格式化 autopep8：自动格式化 Python 代码，以使其符合 PEP8 规范。官网 Debugging Tools用来进行代码调试的库。 调试器 ipdb：IPython 启用的 pdb。官网 pudb：全屏，基于控制台的 Python 调试器。官网 pyringe：可以在 Python 进程中附加和注入代码的调试器。官网 wdb：一个奇异的 web 调试器，通过 WebSockets 工作。官网 winpdb：一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。官网 django-debug-toolbar：为 Django 显示各种调试信息。官网 django-devserver：一个 Django 运行服务器的替代品。官网 flask-debugtoolbar：django-debug-toolbar 的 flask 版。官网 性能分析器 lineprofiler：逐行性能分析。官网 Memory Profiler：监控 Python 代码的内存使用。官网、内存 profiling：一个交互式 Python 性能分析工具。官网 其他 pyelftools：解析和分析 ELF 文件以及 DWARF 调试信息。官网 python-statsd：statsd 服务器的 Python 客户端。官网 Science and Data Analysis用来进行科学计算和数据分析的库。 astropy：一个天文学 Python 库。官网 bcbio-nextgen：这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。官网 bccb：生物分析相关代码集合官网 Biopython：Biopython 是一组可以免费使用的用来进行生物计算的工具。官网 blaze：NumPy 和 Pandas 的大数据接口。官网 cclib：一个用来解析和解释计算化学软件包输出结果的库。官网 NetworkX：一个为复杂网络设计的高性能软件。官网 Neupy：执行和测试各种不同的人工神经网络算法。官网 Numba：Python JIT (just in time) 编译器，针对科学用的 Python ，由Cython 和 NumPy 的开发者开发。官网 NumPy：使用 Python 进行科学计算的基础包。官网 Open Babel：一个化学工具箱，用来描述多种化学数据。官网 Open Mining：使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。官网 orange：通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。官网 Pandas：提供高性能，易用的数据结构和数据分析工具。官网 PyDy：PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。官网 PyMC：马尔科夫链蒙特卡洛采样工具。官网 RDKit：化学信息学和机器学习软件。官网 SciPy：由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。官网 statsmodels：统计建模和计量经济学。官网 SymPy：一个用于符号数学的 Python 库。官网 zipline：一个 Python 算法交易库。官网 Bayesian-belief-networks：优雅的贝叶斯信念网络框架。官网 keras: 以tensorflow或者theano为后端的深度学习封装库，快速上手神经网络官网 数据可视化进行数据可视化的库。 参见: awesome-javascript。 matplotlib：一个 Python 2D 绘图库。官网 bokeh：用 Python 进行交互式 web 绘图。官网 ggplot：ggplot2 给 R 提供的 API 的 Python 版本。官网 plotly：协同 Python 和 matplotlib 工作的 web 绘图库。官网 pygal：一个 Python SVG 图表创建工具。官网 pygraphviz：Graphviz 的 Python 接口。官网 PyQtGraph：交互式实时2D/3D/图像绘制及科学/工程学组件。官网 SnakeViz：一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。官网 vincent：把 Python 转换为 Vega 语法的转换工具。官网 VisPy：基于 OpenGL 的高性能科学可视化工具。官网 计算机视觉计算机视觉库。 OpenCV：开源计算机视觉库。官网 pyocr：Tesseract和Cuneiform的包装库。官网 pytesseract：Google Tesseract OCR的另一包装库。官网 SimpleCV：一个用来创建计算机视觉应用的开源框架。官网 机器学习机器学习库。 参见: awesome-machine-learning. Crab：灵活、快速的推荐引擎。官网 gensim：人性化的话题建模库。官网 hebel：GPU 加速的深度学习库。官网 NuPIC：智能计算 Numenta 平台。官网 pattern：Python 网络挖掘模块。官网 PyBrain：另一个 Python 机器学习库。官网 Pylearn2：一个基于 Theano 的机器学习库。官网 python-recsys：一个用来实现推荐系统的 Python 库。官网 scikit-learn：基于 SciPy 构建的机器学习 Python 模块。官网 pydeep：Python 深度学习库。官网 vowpalporpoise：轻量级 Vowpal Wabbit 的 Python 封装。官网 skflow：一个 TensorFlow 的简化接口(模仿 scikit-learn)。官网 Caffe: 一个Caffe的python接口。官网MapReduce MapReduce 框架和库。 dpark：Spark 的 Python 克隆版，一个类似 MapReduce 的框架。官网 dumbo：这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。官网 luigi：这个模块帮你构建批处理作业的复杂流水线。官网 mrjob：在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。官网 PySpark：Spark 的 Python API 。官网 streamparse：运行针对事实数据流的 Python 代码。集成了Apache Storm。官网 函数式编程使用 Python 进行函数式编程。 CyToolz：Toolz 的 Cython 实现 : 高性能函数式工具。官网 fn.py：在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。官网 funcy：炫酷又实用的函数式工具。官网 Toolz：一组用于迭代器，函数和字典的函数式编程工具。官网 第三方 API用来访问第三方 API的库。 参见： List of Python API Wrappers and Libraries。 apache-libcloud：一个为各种云设计的 Python 库。官网 boto：Amazon Web Services 的 Python 接口。官网 django-wordpress：WordPress models and views for Django.官网 facebook-sdk：Facebook 平台的 Python SDK.官网 facepy：Facepy 让和 Facebook’s Graph API 的交互变得更容易。官网 gmail：Gmail 的 Python 接口。官网 google-api-python-client：Python 用的 Google APIs 客户端库。官网 gspread：Google 电子表格的 Python API.官网 twython：Twitter API 的封装。官网 DevOps 工具用于 DevOps 的软件和库。 Ansible：一个非常简单的 IT 自动化平台。官网 SaltStack：基础设施自动化和管理系统。官网 OpenStack：用于构建私有和公有云的开源软件。官网 Docker Compose：快速，分离的开发环境，使用 Docker。官网 Fabric：一个简单的，Python 风格的工具，用来进行远程执行和部署。官网 cuisine：为 Fabric 提供一系列高级函数。官网 Fabtools：一个用来编写超赞的 Fabric 文件的工具。官网 gitapi：Git 的纯 Python API。官网 hgapi：Mercurial 的纯 Python API。官网 honcho：Foreman的 Python 克隆版，用来管理基于Procfile的应用。官网 pexpect：Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。官网 psutil：一个跨平台进程和系统工具模块。官网 supervisor：UNIX 的进程控制系统。官网 任务调度任务调度库。 APScheduler：轻巧但强大的进程内任务调度，使你可以调度函数。官网 django-schedule：一个 Django 排程应用。官网 doit：一个任务执行和构建工具。官网 gunnery：分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。官网 Joblib：一组为 Python 提供轻量级作业流水线的工具。官网 Plan：如有神助地编写 crontab 文件。官网 schedule：人性化的 Python 任务调度库。官网 Spiff：使用纯 Python 实现的强大的工作流引擎。官网 TaskFlow：一个可以让你方便执行任务的 Python 库，一致并且可靠。官网 外来函数接口使用外来函数接口的库。 cffi：用来调用 C 代码的外来函数接口。官网 ctypes：(Python 标准库) 用来调用 C 代码的外来函数接口。官网 PyCUDA：Nvidia CUDA API 的封装。官网 SWIG：简化的封装和接口生成器。官网 高性能让 Python 更快的库。 Cython：优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。官网 PeachPy：嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。官网 PyPy：使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。官网 Pyston：使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。官网 Stackless Python：一个强化版的 Python。官网 微软的 Windows平台在 Windows 平台上进行 Python 编程。 Python(x,y)：面向科学应用的 Python 发行版，基于 Qt 和 Spyder。官网 pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。官网 PythonNet：Python 与 .NET 公共语言运行库 (CLR)的集成。官网 PyWin32：针对 Windows 的Python 扩展。官网 WinPython：Windows 7/8 系统下便携式开发环境。官网 网络可视化和SDN用来进行网络可视化和SDN(软件定义网络)的工具和库。 Mininet：一款流行的网络模拟器以及用 Python 编写的 API。官网 POX：一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。官网 Pyretic：火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。官网 SDX Platform：基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。官网 硬件用来对硬件进行编程的库。 ino：操作Arduino的命令行工具。官网 Pyro：Python 机器人编程库。官网 PyUserInput：跨平台的，控制鼠标和键盘的模块。官网 scapy：一个非常棒的操作数据包的库。官网 wifi：一个 Python 库和命令行工具用来在 Linux 平台上操作WiFi。官网 Pingo：Pingo 为类似Raspberry Pi，pcDuino， Intel Galileo等设备提供统一的API用以编程。官网 兼容性帮助从 Python 2 向 Python 3迁移的库。 Python-Future：这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。官网 Python-Modernize：使 Python 代码更加现代化以便最终迁移到 Python 3。官网 Six：Python 2 和 3 的兼容性工具。官网 杂项不属于上面任何一个类别，但是非常有用的库。 blinker：一个快速的 Python 进程内信号/事件分发系统。官网 itsdangerous：一系列辅助工具用来将可信的数据传入不可信的环境。官网 pluginbase：一个简单但是非常灵活的 Python 插件系统。官网 Pychievements：一个用来创建和追踪成就的 Python 框架。官网 Tryton：一个通用商务框架。官网 算法和设计模式Python 实现的算法和设计模式。 algorithms：一个 Python 算法模块。官网 python-patterns：Python 设计模式的集合。官网 sortedcontainers：快速，纯 Python 实现的SortedList，SortedDict 和 SortedSet 类型。官网 编辑器插件编辑器和 IDE 的插件 Emacs Elpy：Emacs Python 开发环境。官网 Sublime Text SublimeJEDI：一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。官网 Anaconda：Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。官网 Vim YouCompleteMe：引入基于 Jedi 的 Python 自动补全引擎。官网 Jedi-vim：绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。官网 Python-mode：将 Vim 变成 Python IDE 的一款多合一插件。官网 Visual Studio PTVS：Visual Studio 的 Python 工具官网 集成开发环境流行的 Python 集成开发环境。 PyCharm：商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。官网 LiClipse：基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。官网 Spyder：开源 Python IDE。官网 自动聊天工具用于开发聊天机器人的库 Errbot：最简单和最流行的聊天机器人用来实现自动聊天工具。官网 服务在线工具和简化开发的 API 。 持续集成参见: awesome-CIandCD. Travis CI：一个流行的工具，为你的开源和私人项目提供持续集成服务。(仅支持 GitHub)官网 CircleCI：一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)官网 Vexor CI：一个为私人 app 提供持续集成的工具，支持按分钟付费。官网 Wercker：基于 Docker 平台，用来构建和部署微服务。官网 代码质量 Codacy：自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。官网 QuantifiedCode：一个数据驱动、自动、持续的代码审查工具。官网","tags":[]},{"title":"kafka-flume集群环境搭建【3】","date":"2017-09-20T09:30:00.000Z","path":"2017/09/20/2017-09-21-flume-kafka-1/","text":"1. Flume与Kafka整合 把flume中的数据sink到Kafka kafka 集群已经完成 flume 集群已经完成 flume 的数据存入kafka flume client -&gt; flume server -&gt; kafka 这样也是说只要改flume server中sink配置即可 2. 配置flumeflume-client.conf[root@yaliceshi-1-2 ~]# cat /usr/local/flume/conf/flume-client.conf #Agent flumeAgent.channels = c1 flumeAgent.sources = s1 flumeAgent.sinks = k1 #flumeAgent Spooling Directory Source #注(1) flumeAgent.sources.s1.type = spooldir flumeAgent.sources.s1.spoolDir =/data/logs/ flumeAgent.sources.s1.fileHeader = true flumeAgent.sources.s1.deletePolicy =immediate flumeAgent.sources.s1.batchSize =1000 flumeAgent.sources.s1.channels =c1 flumeAgent.sources.s1.deserializer.maxLineLength =1048576 #flumeAgent FileChannel #注(2) flumeAgent.channels.c1.type = file flumeAgent.channels.c1.checkpointDir = /data/flume/spool/checkpoint flumeAgent.channels.c1.dataDirs = /data/flume/spool/data flumeAgent.channels.c1.capacity = 200000000 flumeAgent.channels.c1.keep-alive = 30 flumeAgent.channels.c1.write-timeout = 30 flumeAgent.channels.c1.checkpoint-timeout=600 # flumeAgent Sinks #注(3) flumeAgent.sinks.k1.channel = c1 flumeAgent.sinks.k1.type = avro # connect to CollectorMainAgent flumeAgent.sinks.k1.hostname = kafka103 flumeAgent.sinks.k1.port = 44444 sources 采用 spooldir 类型，监控/data/logs/目录中文件的变化 flume-server.conf[root@yaliceshi-1-3 ~]# cat /usr/local/flume/conf/flume-server.conf #flumeConsolidationAgent flumeConsolidationAgent.channels = c1 flumeConsolidationAgent.sources = s1 flumeConsolidationAgent.sinks = k1 #flumeConsolidationAgent Avro Source #注(4) flumeConsolidationAgent.sources.s1.type = avro flumeConsolidationAgent.sources.s1.channels = c1 flumeConsolidationAgent.sources.s1.bind = kafka103 flumeConsolidationAgent.sources.s1.port = 44444 #flumeConsolidationAgent FileChannel flumeConsolidationAgent.channels.c1.type = file flumeConsolidationAgent.channels.c1.checkpointDir = /data/flume/spool/checkpoint flumeConsolidationAgent.channels.c1.dataDirs = /data/flume/spool/data flumeConsolidationAgent.channels.c1.capacity = 200000000 flumeConsolidationAgent.channels.c1.keep-alive = 30 flumeConsolidationAgent.channels.c1.write-timeout = 30 flumeConsolidationAgent.channels.c1.checkpoint-timeout=600 ##flumeConsolidationAgent Memory Channel #flumeConsolidationAgent.channels.c1.type = memory #flumeConsolidationAgent.channels.c1.capacity = 10000 #flumeConsolidationAgent.channels.c1.transactionCapacity = 10000 #flumeConsolidationAgent.channels.c1.byteCapacityBufferPercentage = 20 #flumeConsolidationAgent.channels.c1.byteCapacity = 800000 #flumeConsolidationAgent Sinks #注(5) flumeConsolidationAgent.sinks.k1.channel= c1 flumeConsolidationAgent.sinks.k1.type = file_roll flumeConsolidationAgent.sinks.k1.sink.directory = /data/tmp flumeConsolidationAgent.sinks.k1.sink.rollInterval = 3600 flumeConsolidationAgent.sinks.k1.batchSize = 10000 sinks 采用 file_roll 类型，数据保存到 /data/tmp目录中 修改#flumeConsolidationAgent Sinks #注(5) #flumeConsolidationAgent.sinks.k1.channel= c1 #flumeConsolidationAgent.sinks.k1.type = file_roll #flumeConsolidationAgent.sinks.k1.sink.directory = /data/tmp #flumeConsolidationAgent.sinks.k1.sink.rollInterval = 3600 #flumeConsolidationAgent.sinks.k1.batchSize = 10000 上面的注释掉加上下面的内容 #set sink to hdfs flumeConsolidationAgent.sinks.k1.type=org.apache.flume.sink.kafka.KafkaSink flumeConsolidationAgent.sinks.k1.topic = ScalaTopic flumeConsolidationAgent.sinks.k1.brokerList = kafka102:9092, kafka103:9092, kafka104:9092 flumeConsolidationAgent.sinks.k1.requiredAcks = 1 flumeConsolidationAgent.sinks.k1.batchSize = 20 flumeConsolidationAgent.sinks.k1.channel=c1 测试启动flume server [root@yaliceshi-1-3 ~]#/usr/local/flume/bin/flume-ng agent --conf conf --conf-file /usr/local/flume/conf/flume-server.conf --name flumeConsolidationAgent -Dflume.root.logger=INFO,console 启动flume client [root@yaliceshi-1-2 ~]#/usr/local/apache-flume-1.7.0-bin/bin/flume-ng agent --conf conf --conf-file /usr/local/flume/conf/flume-client.conf --name flumeAgent -Dflume.root.logger=INFO,console 启动 kafka 的消费者 [root@yaliceshi-1-1 ~]/usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper 172.16.61.102:2181 --topic ScalaTopic --from-beginning 拷个文件到flume客户端监听目录 [root@yaliceshi-1-2 ~]# echo &quot;test wqc&quot; &gt; test.log;cp test.log /data/logs 拷个文件到flume客户端监听目录 [root@yaliceshi-1-1 ~]# /usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper 172.16.61.102:2181 --topic ScalaTopic --from-beginning test wqc 参考&gt; http://blog.csdn.net/strongyoung88/article/details/52937835 http://blog.csdn.net/minicto/article/details/53643496 http://blog.csdn.net/shouhuzhezhishen/article/details/64904848 http://blog.csdn.net/candysleep/article/details/53241268","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"kafka-flume集群环境搭建【2】","date":"2017-09-20T09:30:00.000Z","path":"2017/09/20/2017-09-18-cluster-flume-1/","text":"1. 前期准备1.1 操作系统172.16.61.102,centos6.9 172.16.61.103,centos6.9 172.16.61.104,centos6.9 三个机器的角色172.16.61.102 agent 172.16.61.103 collector 172.16.61.104 collector 1.3 安装Java （3主机均需要）yum install java-1.8.0-openjdk -y 1.4 下载安装flume （3主机均需要）wget http://mirrors.hust.edu.cn/apache/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz tar -xf apache-flume-1.7.0-bin.tar.gz -C /usr/local/ ln -sv /usr/local/apache-flume-1.7.0-bin /usr/local/flume ll /usr/local/flume 、 1.5 Flume 组件介绍flume 代理，是一个进程承载从外部源事件流到下一个目的地的过程。包含source channel 和 sink。 1.5.1.Source数据源，消耗外部传递给他的事件，外部源将数据按照flume Source 能识别的格式将Flume 事件发送给flume Source。 Source类型 说明 Avro Source 支持Avro协议（实际上是Avro RPC），内置支持 Thrift Source 支持Thrift协议，内置支持 Exec Source 基于Unix的command在标准输出上生产数据 JMS Source 从JMS系统（消息、主题）中读取数据，ActiveMQ已经测试过 Spooling Directory Source 监控指定目录内数据变更 Netcat Source 监控某个端口，将流经端口的每一个文本行数据作为Event输入 Sequence Generator Source 序列生成器数据源，生产序列数据 Syslog Sources 读取syslog数据，产生Event，支持UDP和TCP两种协议 HTTP Source 基于HTTP POST或GET方式的数据源，支持JSON、BLOB表示形式 Legacy Sources 兼容老的Flume OG中Source（0.9.x版本） Avro Legacy Source Thrift Legacy Source Scribe Source Kafka Source 是一个从Kafka主题读取消息的Apache Kafka消费者 Custom Source 自定义Source 1.5.2.Channel数据通道，是一个被动的存储，用来保持事件，直到由一个flume Sink消耗。 Channel类型 说明 Memory Channel Event数据存储在内存中 JDBC Channel Event数据存储在持久化存储中，当前Flume Channel内置支持Derby File Channel Event数据存储在磁盘文件中 Spillable Memory Channel Event数据存储在内存中和磁盘上，当内存队列满了，会持久化到磁盘文件（当前试验性的，不建议生产环境使用） Pseudo Transaction Channel 测试用途 Custom Channel 自定义Channel实现 1.5.3 Sink数据汇聚点，代表外部数据存放位置。发送flume event到指定的外部目标。 Sink类型 说明 HDFS Sink 数据写入HDFS Logger Sink 数据写入日志文件 Avro Sink 数据被转换成Avro Event，然后发送到配置的RPC端口上 Thrift Sink 数据被转换成Thrift Event，然后发送到配置的RPC端口上 IRC Sink 数据在IRC上进行回放 File Roll Sink 存储数据到本地文件系统 Null Sink 丢弃到所有数据 HBase Sink 数据写入HBase数据库 Morphline Solr Sink 数据发送到Solr搜索服务器（集群） ElasticSearch Sink 数据发送到Elastic Search搜索服务器（集群） Kite Dataset Sink 写数据到Kite Dataset，试验性质的 Custom Sink 自定义Sink实现 2. 配置flumeflume-client.conf[root@yaliceshi-1-2 ~]# cat /usr/local/flume/conf/flume-client.conf #Agent flumeAgent.channels = c1 flumeAgent.sources = s1 flumeAgent.sinks = k1 #flumeAgent Spooling Directory Source #注(1) flumeAgent.sources.s1.type = spooldir flumeAgent.sources.s1.spoolDir =/data/logs/ flumeAgent.sources.s1.fileHeader = true flumeAgent.sources.s1.deletePolicy =immediate flumeAgent.sources.s1.batchSize =1000 flumeAgent.sources.s1.channels =c1 flumeAgent.sources.s1.deserializer.maxLineLength =1048576 #flumeAgent FileChannel #注(2) flumeAgent.channels.c1.type = file flumeAgent.channels.c1.checkpointDir = /data/flume/spool/checkpoint flumeAgent.channels.c1.dataDirs = /data/flume/spool/data flumeAgent.channels.c1.capacity = 200000000 flumeAgent.channels.c1.keep-alive = 30 flumeAgent.channels.c1.write-timeout = 30 flumeAgent.channels.c1.checkpoint-timeout=600 # flumeAgent Sinks #注(3) flumeAgent.sinks.k1.channel = c1 flumeAgent.sinks.k1.type = avro # connect to CollectorMainAgent flumeAgent.sinks.k1.hostname = kafka103 flumeAgent.sinks.k1.port = 44444 sources 采用 spooldir 类型，监控/data/logs/目录中文件的变化 flume-server.conf[root@yaliceshi-1-3 ~]# cat /usr/local/flume/conf/flume-server.conf #flumeConsolidationAgent flumeConsolidationAgent.channels = c1 flumeConsolidationAgent.sources = s1 flumeConsolidationAgent.sinks = k1 #flumeConsolidationAgent Avro Source #注(4) flumeConsolidationAgent.sources.s1.type = avro flumeConsolidationAgent.sources.s1.channels = c1 flumeConsolidationAgent.sources.s1.bind = kafka103 flumeConsolidationAgent.sources.s1.port = 44444 #flumeConsolidationAgent FileChannel flumeConsolidationAgent.channels.c1.type = file flumeConsolidationAgent.channels.c1.checkpointDir = /data/flume/spool/checkpoint flumeConsolidationAgent.channels.c1.dataDirs = /data/flume/spool/data flumeConsolidationAgent.channels.c1.capacity = 200000000 flumeConsolidationAgent.channels.c1.keep-alive = 30 flumeConsolidationAgent.channels.c1.write-timeout = 30 flumeConsolidationAgent.channels.c1.checkpoint-timeout=600 ##flumeConsolidationAgent Memory Channel #flumeConsolidationAgent.channels.c1.type = memory #flumeConsolidationAgent.channels.c1.capacity = 10000 #flumeConsolidationAgent.channels.c1.transactionCapacity = 10000 #flumeConsolidationAgent.channels.c1.byteCapacityBufferPercentage = 20 #flumeConsolidationAgent.channels.c1.byteCapacity = 800000 #flumeConsolidationAgent Sinks #注(5) flumeConsolidationAgent.sinks.k1.channel= c1 flumeConsolidationAgent.sinks.k1.type = file_roll flumeConsolidationAgent.sinks.k1.sink.directory = /data/tmp flumeConsolidationAgent.sinks.k1.sink.rollInterval = 3600 flumeConsolidationAgent.sinks.k1.batchSize = 10000 sinks 采用 file_roll 类型，数据保存到 /data/tmp目录中 3. 启动服务3.1 启动服务端[kafka103 ]# /usr/local/flume/bin/flume-ng agent --conf conf --conf-file /usr/local/flume/conf/flume-server.conf --name flumeConsolidationAgent -Dflume.root.logger=INFO,console 3.2 启动客户端[kafka102 ]# /usr/local/apache-flume-1.7.0-bin/bin/flume-ng agent --conf conf --conf-file /usr/local/flume/conf/flume-client.conf --name flumeAgent -Dflume.root.logger=INFO,console 3.3 注意 –name 需要跟配置中的名称保持一致 测试在客户端拷贝一件文件到/data/logs在服务端查看/data/tmp下会有新文件生成 参考&gt; http://blog.csdn.net/strongyoung88/article/details/52937835 http://blog.csdn.net/minicto/article/details/53643496 http://blog.csdn.net/shouhuzhezhishen/article/details/64904848 http://blog.csdn.net/candysleep/article/details/53241268 https://my.oschina.net/u/1780960/blog/793783 https://github.com/Leaderman/flume-extension","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"python技术分享[3]－list dict在实际中的应用","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-14-training-python-3/","text":"在python中, list, tuple, dict, set有什么区别, 主要应用在什么样的场景? 定义: list:链表,有序的项目, 通过索引进行查找,使用方括号”[]”;tuple:元组,元组将多样的对象集合到一起,不能修改,通过索引进行查找, 使用括号”()”;dict:字典,字典是一组键(key)和值(value)的组合,通过键(key)进行查找,没有顺序, 使用大括号”{}”;set:集合,无序,元素只出现一次, 自动去重,使用”set([])” 应用场景: list, 简单的数据集合,可以使用索引;tuple, 把一些数据当做一个整体去使用,不能修改;dict,使用键值和值进行关联的数据;set,数据只出现一次,只关心数据是否出现, 不关心其位置; 实践样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python# coding=utf-8#################################################### # 功能：统计游戏中玩家及玩家登陆次数# #####################################################统计游戏中玩家及玩家登陆次数games = ['a','b','a','c','d','a','b','c','b'] from collections import Counter d = Counter(games) print d#排位赛规则，如果积分相同，则按胜利场次，再相同按失败场次games =[&#123;'f':3,'s':10,'b':12&#125;,&#123;'f':3,'s':10,'b':12&#125;,&#123;'f':13,'s':20,'b':16&#125;,&#123;'f':13,'s':12,'b':12&#125;,&#123;'f':13,'s':10,'b':12&#125;,]from operator import itemgetter print sorted(games ,key = itemgetter('f','s','b'),reverse=True)#选择某一天，然后以这天为准，次日留存，3日留存，7日留存，14日留存，30日留存from datetime import datetime,timedelta def GetNextDay(baseday,n): return str((datetime.strptime(str(baseday),'%Y-%m-%d')+timedelta(days=n)).date()) import functools selected_day = '2015-02-01'nday = functools.partial(GetNextDay,selected_day)print nday(1)print nday(2)print nday(6)print nday(13)print nday(29)#用来计算游戏包裹里面的变化情况def symmetric_difference(_oldobj,_newobj): _oldkeys = _oldobj.keys() _newkeys = _newobj.keys() _diff = &#123;&#125; for _key in set(_oldkeys + _newkeys): _val = _newobj.get(_key,0) - _oldobj.get(_key,0) if _val: _diff[_key] = _val return _diff oldobj = &#123;'a':1,'b':2,'c':3&#125; newobj = &#123;'a':1,'b':3,'d':4&#125; print symmetric_difference(oldobj,newobj) 输入：python 3.py 输出： Counter({‘a’: 3, ‘b’: 3, ‘c’: 2, ‘d’: 1}) [{‘s’: 20, ‘b’: 16, ‘f’: 13}, {‘s’: 12, ‘b’: 12, ‘f’: 13}, {‘s’: 10, ‘b’: 12, ‘f’: 13}, {‘s’: - 10, ‘b’: 12, ‘f’: 3}, {‘s’: 10, ‘b’: 12, ‘f’: 3}]- 2015-02-02- 2015-02-03- 2015-02-07- 2015-02-14- 2015-03-02- {‘c’: -3, ‘b’: 1, ‘d’: 4}- 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[4]－使用pylint约束代码规范","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-17-training-python-4/","text":"\u0016pylint是一个Python代码风格的检查工具, 它依据的标准是Guido van Rossum的PEP8\u0016* Pylint: http://www.logilab.org/project/pylint Pep8: https://www.python.org/dev/peps/pep-0008/ Pep8中文: http://code.google.com/p/zhong-wiki/wiki/PEP8 原谅我用2007年译的版本，我只是觉得当年这篇比较靠近原意。 1.扩展安装： pip install pylint 可以这样用 pylint demo.py pip install pep8 pep8 –show-source –show-pep8 demo.py 2.Pylint 的输出 对于每一个 Python 模块，Pylint 的结果中首先显示一些”*”字符 , 后面紧跟模块的名字，然后是一系列的 message, message 的格式如下： MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE MESSAGE_TYPE 有如下几种： (C) 惯例。违反了编码风格标准 (R) 重构。写得非常糟糕的代码。 (W) 警告。某些 Python 特定的问题。 (E) 错误。很可能是代码中的错误。 (F) 致命错误。阻止 Pylint 进一步运行的错误。 ####3.样本实例demo.py在 http://djshell.github.io/python/training-python-1.html ######3.1检查python格式 pylint demo.py No config file found, using default configuration * Module demo W: 11, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 15, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 16, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 17, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 18, 0: Bad indentation. Found 4 spaces, expected 8 (bad-indentation) W: 19, 0: Bad indentation. Found 4 spaces, expected 8 (bad-indentation) W: 22, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 27, 0: Bad indentation. Found 2 spaces, expected 4 (bad-indentation) W: 28, 0: Bad indentation. Found 4 spaces, expected 8 (bad-indentation) W: 29, 0: Bad indentation. Found 4 spaces, expected 8 (bad-indentation) C: 32, 0: Unnecessary parens after u’print’ keyword (superfluous-parens) C: 1, 0: Missing module docstring (missing-docstring) C: 15, 2: Invalid variable name “a” (invalid-name) C: 16, 2: Invalid variable name “b” (invalid-name) C: 18, 4: Invalid variable name “a” (invalid-name) C: 18, 7: Invalid variable name “b” (invalid-name) C: 21, 0: Invalid argument name “n” (invalid-name) C: 27, 6: Invalid variable name “x” (invalid-name) C: 29,15: More than one statement on a single line (multiple-statements) ………… …………省略多行，下面是得分 Your code has been rated at -2.67/10 可能是在页面复制贴粘时空格数据发生改变了，我们只得了负分现在我们来按照提示整理格式 Bad indentation. Found 2 spaces, expected 4 (bad-indentation) 空格期望四个，错误缩进 Unnecessary parens after u’print’ keyword (superfluous-parens) print 之后多余的小括号 Missing module docstring (missing-docstring) 没有模块文档说明 Invalid variable name “a” (invalid-name) 非法的变量 No space allowed around keyword argument assignment 不要在用于指定关键字参数 (keyword argument) 或默认参数值的 ‘=’ 号周围使用空格 Trailing whitespace (trailing-whitespace) 尾随空白，行尾有空白字符，需要删除 按照提示更改代码直到得到10分 Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00) ####更改完的代码如下： 12345678910111213141516171819202122232425262728293031# coding=utf-8#!/usr/bin/python2.7'''python pylint demo'''def fib(): ''' a generator that produces the fibonacci series's elements ''' int_a = 1 int_b = 1 while True: int_a, int_b = int_a + int_b, int_a yield int_adef nth(series, num): ''' returns the nth element of a series, consuming the series' earlier elements. ''' for key in series: num -= 1 if num &lt;= 0: return keyif __name__ == '__main__': print 'Executed from the command line' print nth(fib(), 10) 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[5]－ splinter自动登录微博和qq空间","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-19-training-python-5/","text":"1.扩展安装： pip install splinter sudo pip install selenium sudo pip install mozmill 要求python2.7+ 默认使用firefox浏览器，如果需要使用chrom且在mac的情况下可用 brew install chromedriver 安装，不过请使用代理，要不download会失败。 2.登录微博代码：1234567891011121314151617181920212223242526272829303132#!/usr/bin/python# coding=utf-8\"\"\"利用splinter模块模拟发布微博，仅为QA讲例测试\"\"\"from splinter.browser import Browserimport randomimport timeweb_firefox = Browser('firefox')web_firefox.visit('http://weibo.com/login.php')if web_firefox.find_by_name('username'): print 'uname' # web_firefox.find_by_name('username').click() # 这个地方用by_name能找到，但是模拟点击时有问题，改成by_css web_firefox.find_by_css( \"input[node-type=\\\"username\\\"]\").fill('xxxx@sina.com')time.sleep(random.randint(3, 10))if web_firefox.find_by_name('password'): print 'passwd' web_firefox.find_by_css(\"input[node-type=\\\"password\\\"]\").fill('******') time.sleep(random.randint(3, 15))print web_firefox.find_by_css(\".loginbox .W_login_form .login_btn div a \")[0].click()time.sleep(random.randint(3, 10))print web_firefox.find_by_css(\".input .W_input\").fill(u'我说不让你用微博测试，你非用，得了吧。。。。 封ip了吧')time.sleep(random.randint(3, 10))print web_firefox.find_by_css(\"a[node-type=\\\"submit\\\"]\").click() 效果：http://pan.baidu.com/s/1pJA3QyR 3.登录QQ空间代码：123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python# coding=utf-8import timefrom splinter import Browserdef splinter(url, q, p): # browser=Browser('chrome') #browser = Browser('webdriver.chrome') browser = Browser('firefox') browser.visit(url) time.sleep(5) #fill in account and password if browser.find_by_id('login_frame'): with browser.get_iframe('login_frame') as frame: frame.find_by_id('switcher_plogin').click() print '输入账号...' frame.find_by_id('u').fill(q) print '输入密码...' frame.find_by_id('p').fill(p) print '尝试登录...' frame.find_by_id('login_button').click() print '完成登录动作...' browser.find_by_id('aMyFriends').click() time.sleep(3)if __name__ == '__main__': website = 'http://qzone.qq.com' qq = 'qq号' pwd = '***********' splinter(website, qq, pwd) 效果：http://pan.baidu.com/s/1hqfAaX2 4.模块简介： \u0016Splinter 可以通过api自动模拟用户行为，可以利用Splinter开发浏览器自动化操作。\u0016* Splinter: https://github.com/cobrateam/splinter 功能： simple api 接口简单 multi webdrivers (chrome webdriver, firefox webdriver, phantomjs webdriver, zopetestbrowser, - remote webdriver) 多个浏览器驱动 css and xpath selectors css和xpath作为选择器 support to iframe and alert 支持iframe和alert execute javascript 可执行javascript works with ajax and async javascript 支持javascript的ajax的异步操作 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[6]－ 自定义数据库连接池","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-23-training-python-6/","text":"1.数据库连接池原理：&gt;连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 2.代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/python# coding=utf-8import MySQLdbimport timeimport string class PooledConnection: def __init__(self, maxconnections, connstr,dbtype): from Queue import Queue self._pool = Queue(maxconnections) # create the queue self.connstr = connstr self.dbtype=dbtype self.maxconnections=maxconnections try: for i in range(maxconnections): self.fillConnection(self.CreateConnection(connstr,dbtype)) except Exception,e: raise e def fillConnection(self,conn): try: self._pool.put(conn) except Exception,e: raise \"fillConnection error:\"+str(e) def returnConnection(self, conn): try: self._pool.put(conn) except Exception,e: raise \"returnConnection error:\"+str(e) def getConnection(self): try: return self._pool.get() except Exception,e: raise \"getConnection error:\"+str(e) def ColseConnection(self,conn): try: self._pool.get().close() self.fillConnection(self.CreateConnection(connstr,dbtype)) except Exception,e: raise \"CloseConnection error:\"+str(e) def CreateConnection(self,connstr,dbtype): try: conndb=MySQLdb.connect(db='test',host='127.0.0.1',user='root',passwd=''); conndb.clientinfo = 'datasync connection pool from datasync.py'; conndb.ping(); return conndb except Exception, e: print 'ssssssssss' raise 'conn targetdb datasource Excepts,%s!!!(%s).'%('127.0.0.1',str(e)) return None #创建连接池：connstring=\"rooot#' '#127.0.0.1:3306/test\"pool=PooledConnection(10,connstring,\"mysql\");#获取连接：conn = pool.getConnection()time.sleep(15)cursor = conn.cursor()cursor.execute(\"\"\"select * from emp\"\"\")result = cursor.fetchall();print cursor.descriptionconn.close(); 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[7]－ 自定义数据库连接池","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-27-training-python-7/","text":"1.数据库连接池原理：&gt;连接池基本的思想是在系统初始化的时候，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 2.代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#!/usr/bin/env python#coding=utf-8 class PooledConnection: def __init__(self, maxconnections, dbtype): from Queue import Queue self._pool = Queue(maxconnections) # create the queue self.dbtype=dbtype self.maxconnections=maxconnections try: for i in range(maxconnections): self.fillConnection(self.CreateConnection(dbtype)) except Exception,e: raise e def fillConnection(self,conn): try: self._pool.put(conn) except Exception,e: raise \"fillConnection error:\"+str(e) def returnConnection(self, conn): try: self._pool.put(conn) except Exception,e: raise \"returnConnection error:\"+str(e) def getConnection(self): try: return self._pool.get() except Exception,e: raise \"getConnection error:\"+str(e) def ColseConnection(self,conn): try: self._pool.get().close() self.fillConnection(self.CreateConnection(dbtype)) except Exception,e: raise \"CloseConnection error:\"+str(e) def CreateConnection(self, dbtype): try: conndb=MySQLdb.connect(db='test',host='127.0.0.1',user='root',passwd=''); conndb.clientinfo = 'datasync connection pool from datasync.py'; conndb.ping(); return conndb except Exception, e: raise 'conn targetdb datasource Excepts,%s!!!(%s).'%('127.0.0.1',str(e)) return None DB = PooledConnection(10,\"mysql\") def sub_mod( ip, data): global DB conn = DB.getConnection() cursor = conn.cursor() cursor.execute(\"\"\"insert into pool (name) values('wwwww')\"\"\") #result = cursor.fetchall(); #print cursor.description class MtaskConnection(object): stream_set = set([]) def __init__(self,stream, address): self.stream = stream self.address = address self.stream_set.add(self.stream) self.stream.set_close_callback(self._on_close) self.stream.read_until('\\n', self._on_read_line) def _on_read_line(self, data): sub_mod(self.address[0], data) def _on_close(self): MtaskConnection.stream_set.remove(self.stream) class MonitorTCPServer(TCPServer): def __init__(self): TCPServer.__init__(self) def handle_stream(self, stream, address): MtaskConnection(stream,address) #def __del__(self): # self.pool.ColseConnection() def main(): from tornado import process from tornado import web,netutil from tornado.tcpserver import TCPServer from tornado import ioloop import MySQLdb import json,time import sys,os,string import socket, select import syslog import base64 sockets = netutil.bind_sockets(32777) process.fork_processes(0) server = MonitorTCPServer() server.add_sockets(sockets) ioloop.IOLoop.instance().start()#经两次fork实现脱终端，成为守护进程def daemon(): try: pid = os.fork() if pid &gt; 0: sys.exit(0) os.setsid() os.umask(0) pid = os.fork() if pid &gt; 0: # exit from second parent sys.exit(0) for i in range(65): try: os.close(i) except: continue sys.stdin = open(\"/dev/null\", \"r+\") sys.stdout = sys.stdin sys.stderr = sys.stdin except OSError, e: syslog.syslog(syslog.LOG_ERR, \"fork failed: (%s)\" % e) sys.exit(1) if __name__ == '__main__': main() #syslog.openlog(\"monitor_svr\", 0, syslog.LOG_LOCAL6) #daemon() #syslog.closelog() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[8]－ 数据库操作之MySQLdb","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-10-training-python-8/","text":"1.数据库操作：&gt; 数据操作在工作中最常用的操作类库之一，今天贴出来我常用的MySQl操作类，一直在用，也一直在不断优化，暂时可以满足业务 2.接口代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/usr/bin/env python#coding=utf-8from abc import ABCMeta from abc import abstractpropertyfrom abc import abstractmethod class Custom_Interface(object): __metaclass__ = ABCMeta @abstractmethod def close(self): \"\"\" 关闭当前数据库句柄 \"\"\" return @abstractmethod def query(self, query, *parameters): \"\"\" @return: 返回一个list，多个结果。 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def get(self, query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def count(self,query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def insert(self,table,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return @abstractmethod def update(self,table,where,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return @abstractmethod def delete(self,table,where): ''' @param table:表名 @param datas:｛字段：值｝ ''' return 2.类实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#coding=utf-8'''Created on 2011-8-28@author: wuqichao@copyright: $Id: custom_mysql.py 12565 2013-01-29 08:00:34Z wuqichao $'''import systry: import MySQLdb import MySQLdb.cursors from MySQLdb import IntegrityError as IntegrityError from MySQLdb import OperationalError as OperationalError from MySQLdb import DatabaseError as DatabaseError from MySQLdb import InternalError as InternalErrorexcept ImportError: print &gt;&gt; sys.stderr,\"\"\"\\There was a problem importing Python modules(MySQLdb-python) required.The error leading to this problem was:%s Please install a package which provides this module, orverify that the module is installed correctly.It's possible that the above module doesn't match the current version of Python,which is:%s\"\"\" % (sys.exc_info(), sys.version)__ALL__=['Custom_MySQL']class Custom_MySQL() : ''' service 基础类 ''' def __init__(self,using=''): \"\"\" @param cursor_hander:数据库句柄 \"\"\" self.cursor = None self.cursor_hander = using self.connections = None if str(self.cursor_hander).rstrip() == '': print 'please write Custom_MySQL`s using param' exit(0) try: databases =&#123; 'log':&#123;'host':'115.*.*.*', 'user':'xxxxxxx','password':'xxxxxxxx', 'database':'logs','charset':'utf8','port':3306,'connect_timeout':60&#125;, &#125;, &#125; database = databases[self.cursor_hander] self.connections = MySQLdb.connect(database['host'],database['user'],database['password'], database['database'],charset = database['charset'], port = int(database['port']),connect_timeout = int(database['connect_timeout'])); self.connections.ping(True) self.cursor = self.connections.cursor(MySQLdb.cursors.DictCursor) except MySQLdb.Error, e: err_info = \"Error %d: %s\" % (e.args[0],e.args[1]) print err_info sys.exit(1) def ping(self): self.connections.ping(True) def close(self): try: if self.connections: self.connections.close() except: pass def __del__(self): try: if self.connections: self.connections.close() except: pass def _execute(self, cursor, query, parameters): try: return cursor.execute(query, parameters) except OperationalError: Exception(\"OperationalError for Custom_MySQL._execute() query\") raise except IntegrityError: Exception(\"IntegrityError for Custom_MySQL._execute() query\") raise except DatabaseError: Exception(\"IntegrityError for Custom_MySQL._execute() query\") raise except InternalError: Exception(\"IntegrityError for Custom_MySQL._execute() query\") raise def _execute_affected_rows(self, query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" try: self._execute(self.cursor,query, parameters) return self.cursor.rowcount except OperationalError: Exception(\"OperationalError for Custom_MySQL.execute() query\") raise def execute(self, query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" try: self._execute(self.cursor,query, parameters) return self.cursor.lastrowid except OperationalError: Exception(\"OperationalError for Custom_MySQL.execute() query\") raise def executemany(self, query, parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" try: self.cursor.executemany(query, parameters) return self.cursor.lastrowid except OperationalError: Exception(\"OperationalError for Custom_MySQL.executemany() query\") raise def query(self, query, *parameters): \"\"\" @return: 返回一个list，多个结果。 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" try: self._execute(self.cursor,query, parameters) return self.cursor.fetchall() except OperationalError: Exception(\"OperationalError for Custom_MySQL.query() query\") raise def get(self, query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" rows = self.query(query, *parameters) if not rows: return None elif len(rows) &gt; 1: print query raise Exception(\"Multiple rows returned for Database.get() query\") else: return rows[0] def count(self,query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" try: self._execute(self.cursor,query, parameters) return self.cursor.fetchone() except OperationalError: Exception(\"OperationalError for Custom_MySQL.count() query\") raise def insert(self,table,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return Insert(self,table)(**datas) def update(self,table,where,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return Update(self,table,where)(**datas) def delete(self,table,where): ''' @param table:表名 @param datas:｛字段：值｝ ''' return Delete(self,table,where)() def begin(self): if self.cursor is not None: self.cursor.execute('set autocommit =0;') def commit(self): if self.cursor is not None: try: self.cursor.execute('COMMIT;') except Exception,e: self.cursor.execute('ROLLBACK;') Exception(\"OperationalError for Custom_MySQL.commit() Error:%s\",e) raise def rollback(self): if self.cursor is not None: try: self.cursor.execute('ROLLBACK;') except Exception,e: Exception(\"OperationalError for Custom_MySQL.rollback() Error:%s\",e) raiseclass Insert: def __init__(self,db,tablename): self.db=db self.tablename=tablename def __call__(self,**fileds): columns=fileds.keys() _prefix=\"\".join(['INSERT INTO `',self.tablename,'`']) _fields=\",\".join([\"\".join(['`',column,'`']) for column in columns]) _values=\",\".join([\"%s\" for i in range(len(columns))]) _sql=\"\".join([_prefix,\"(\",_fields,\") VALUES (\",_values,\")\"]) _params=[fileds[key] for key in columns] return self.db.execute(_sql,*tuple(_params))class Update: def __init__(self,db,tablename,where): self.db=db self._tablename=tablename self._where=where def __call__(self,**fileds): if len(fileds)&lt;1: raise OperationalError,\"Must have unless 1 field to update\" _params=[] _cols=[] for i in fileds.keys(): _cols.append(\"\".join([\"`\",i,'`','=%s'])) for i in fileds.values(): _params.append(i) _sql_slice=[\"UPDATE \",self._tablename,\" SET \",\",\".join(_cols)] if self._where: _sql_slice.append(\" WHERE \"+self._where) _sql=\"\".join(_sql_slice) return self.db._execute_affected_rows(_sql,*_params)class Delete: def __init__(self,db,tablename,where): self.db=db self._tablename=tablename self._where=where def __call__(self): _sql_slice=[\"DELETE FROM `\",self._tablename,\"`\"] if self._where: _sql_slice.append(\" WHERE \"+self._where) _sql=\"\".join(_sql_slice) return self.db._execute_affected_rows(_sql) 2.接口代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657\u0016#!/usr/bin/python#coding=gbkfrom custom_mysql import Custom_MySQL#声明实例mysql = Custom_MySQL('test')#演示 mysql count 查询条数sql = 'select count(*) as count from qiubai'result = mysql.count(sql)count = result['count']print count#演示 mysql query 查询结果集多条sql = 'select id,url from qiubai limit 10'result = mysql.query(sql)for i in result: print i['id'],i['url']#演示 mysql get 查询结果集只有一条sql = 'select id,url from qiubai limit 10'result = mysql.get(sql)print result#事务处理mysql.begin()try: datas =&#123; 'year':'2013', 'month':'10', 'day':'12', 'page':'80', 'index':'2' &#125; #演示 mysql insert 返回last_insert_id print mysql.insert('qiubai',**datas) datas.update(&#123;'url':'wwwwwwwwwww'&#125;) #演示 mysql update 返回update的影响数 print mysql.update('qiubai', ' year = %(year)s and month =%(month)s and day = %(day)s and page=%(page)s and `index`=%(index)s'%datas, **datas) #演示 mysql delete 返回delete的影响数 print mysql.delete('qiubai', ' year = %(year)s and month =%(month)s and day = %(day)s and page=%(page)s and `index`=%(index)s'%datas) #提交事务 mysql.commit()except: #回滚 mysql.rollback() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[9]－ 数据库操作之MongoDB","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-12-training-python-9/","text":"1.数据库操作：&gt; 数据操作在工作中最常用的操作类库之一，今天贴出来我常用的pymongo操作类，一直在用，也一直在不断优化，暂时可以满足业务 2.接口代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/usr/bin/env python#coding=utf-8from abc import ABCMeta from abc import abstractpropertyfrom abc import abstractmethod class Custom_Interface(object): __metaclass__ = ABCMeta @abstractmethod def close(self): \"\"\" 关闭当前数据库句柄 \"\"\" return @abstractmethod def query(self, query, *parameters): \"\"\" @return: 返回一个list，多个结果。 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def get(self, query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def count(self,query, *parameters): \"\"\" @return: 返回单个结果 @param query:SQL语句 @param parameters:SQL语句参数 \"\"\" return @abstractmethod def insert(self,table,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return @abstractmethod def update(self,table,where,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return @abstractmethod def delete(self,table,where): ''' @param table:表名 @param datas:｛字段：值｝ ''' return 2.类实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#/usr/bin/python#coding=utf-8\"\"\"auth:.启createtime:2014-6-17下午12:13:07usege:\"\"\"import systry: import pymongoexcept ImportError: print &gt;&gt; sys.stderr,\"\"\"\\There was a problem importing Python modules(pymongo) required.The error leading to this problem was:%s Please install a package which provides this module, orverify that the module is installed correctly.you can use this cmd :pip install pymongoIt's possible that the above module doesn't match the current version of Python,which is:%s\"\"\" % (sys.exc_info(), sys.version)from interface import Custom_Interfaceclass Custom_Mongo(Custom_Interface): def __init__(self,using=''): \"\"\" @param cursor_hander:数据库句柄 \"\"\" self.cursor = None self.cursor_hander = using self.connections = None self.conn = None if str(self.cursor_hander).rstrip() == '': print 'please write Custom_MySQL`s using param' exit(0) databases =&#123; 'logs':&#123;'host':'127.0.0.1', 'user':'readonly','password':'readonly', 'database':'local','charset':'utf8','port':27017,'connect_timeout':50&#125;, &#125; database = databases[self.cursor_hander] #建立和数据库系统的连接,创建Connection时，指定host及port参数 self.conn = pymongo.Connection(host=database['host'],port=database['port']) self.database = self.conn[database['database']] #admin 数据库有帐号，连接-认证-切换库 #db_auth = conn.admin #db_auth.authenticate('sa','sa') def __del__(self): self.close() def close(self): \"\"\" 关闭当前数据库句柄 \"\"\" if self.conn != None: return self.conn.disconnect() def query(self, table_name, parameters,skip=None,limit=None): \"\"\" @return: 返回一个list，多个结果。 @param table_name:表名 @param parameters:SQL语句参数 \"\"\" result = self.database[table_name].find(parameters) if skip !=None: result.skip(skip) if limit !=None: result.limit(limit) return result def get(self, table_name,**parameters): \"\"\" @return: 返回单个结果 @param table_name:表名 @param parameters:SQL语句参数 \"\"\" return self.database[table_name].find_one(parameters) def count(self,table_name, **parameters): \"\"\" @return: 返回单个结果 @param table_name:表名 @param parameters:SQL语句参数 \"\"\" return self.database[table_name].find(parameters).count() def insert(self,table,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return self.database[table].insert(datas) def update(self,table,where,**datas): ''' @param table:表名 @param datas:｛字段：值｝ ''' return self.database[table].update(where,datas) def delete(self,table,where): ''' @param table:表名 @param datas:｛字段：值｝ ''' return self.database[table].remove(where) 3.用例代码：1234567891011121314151617181920212223242526#/usr/bin/python#coding=utf-8'''date:2014-06-17 12:00'''from custom.db.mongo import Custom_Mongon = Custom_Mongo(using='logs')param = &#123;'sex':'man','name':'wuqichao'&#125;print n.insert('users',**param)param = &#123;'sex':'man','name':'wuqichao'&#125;print n.get('users',**param)param = &#123;'sex':'man','name':'wuqichao'&#125;print n.count('users', **param)n.update('users',&#123;'sex':'man','name':'wuqichao'&#125;,**&#123;'sex':'wman','name':'wuqichao'&#125;)param = &#123;'sex':'man','name':'wuqichao'&#125;res = n.query('users',param,skip=2,limit=2)for r in res: print r 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[10]－ 日志－记文件log","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-14-training-python-10/","text":"1.日志操作：&gt; 日志文件操作在工作中最常用的操作类库之一，今天贴出来我常用的文件操作类，一直在用，也一直在不断优化，暂时可以满足业务 2.日志操作代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python#coding:utf-8\"\"\"mail:wuqichao@gyyx.comcreatetime:2011-3-1下午12:24:29usege:\"\"\"import sys, os, reimport loggingimport logging.handlersclass LogFactory: '''日志工厂''' ilog = None #信息日志 elog = None #错误日志 root = os.path.abspath('.') ilogfile = root+'/logs/mtask_info_%s.log' #信息日志文件 elogfile = root+'/logs/mtask_err_%s.log' #错误日志文件 ERROR = 'err' INFO = 'info' @staticmethod def init_log(logtype, p = \"\"): ''' 初始化日志对像 @param logtype:info 和 err分别是信息日志和错误日志 @param p :日志文件名后缀 ''' logfile = LogFactory.ilogfile % p if logtype == LogFactory.ERROR: logfile = LogFactory.elogfile % p logger = logging.getLogger(logtype) logger.setLevel(logging.INFO) handler = logging.handlers.RotatingFileHandler(logfile, maxBytes=1024*1024*1024, backupCount=5) formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(filename)s %(lineno)d %(message)s') handler.setFormatter(formatter) logger.addHandler(handler) return logger @staticmethod def get_err_logger(p=\"\"): '''初使化错误日志''' if not LogFactory.elog : LogFactory.elog = LogFactory.init_log(LogFactory.ERROR, p) return LogFactory.elog @staticmethod def get_info_logger(p=\"\"): '''初使化错误日志''' if not LogFactory.ilog : LogFactory.ilog = LogFactory.init_log(LogFactory.INFO, p) return LogFactory.ilogdef w_info(msg,p=''): ''' 写信息日志 @param msg:信息 ''' ilogger = LogFactory.get_info_logger(p=p) ilogger.info(msg)def w_err(msg,p=''): ''' 写错误日志 @param msg : 错误信息 ''' elogger = LogFactory.get_err_logger(p=p) elogger.error(msg) 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[11]－ 日志－日志记录到mongodb中","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-15-training-python-11/","text":"1.日志操作：&gt; 日志文件操作在工作中最常用的操作类库之一，今天贴出来我常用的文件操作类，一直在用，也一直在不断优化，暂时可以满足业务 2.日志操作代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import loggingimport getpassfrom datetime import datetimefrom socket import gethostnamefrom pymongo.connection import Connectionfrom bson import InvalidDocumentclass MongoFormatter(logging.Formatter): def format(self, record): \"\"\"Format exception object as a string\"\"\" data = record.__dict__.copy() if record.args: record.msg = record.msg % record.args data.update( username=getpass.getuser(), time=datetime.now(), host=gethostname(), message=record.msg, args=tuple(unicode(arg) for arg in record.args) ) if 'exc_info' in data and data['exc_info']: data['exc_info'] = self.formatException(data['exc_info']) return data class MongoHandler(logging.Handler): \"\"\" Custom log handler Logs all messages to a mongo collection. This handler is designed to be used with the standard python logging mechanism. \"\"\" @classmethod def to(cls, db, collection, host='localhost', port=None, level=logging.NOTSET): \"\"\" Create a handler for a given \"\"\" return cls(Connection(host, port)[db][collection], level) def __init__(self, collection, db='mongolog', host='localhost', port=None, level=logging.NOTSET): \"\"\" Init log handler and store the collection handle \"\"\" logging.Handler.__init__(self, level) if (type(collection) == str): self.collection = Connection(host, port)[db][collection] else: self.collection = collection self.formatter = MongoFormatter() def emit(self,record): \"\"\" Store the record to the collection. Async insert \"\"\" try: self.collection.save(self.format(record)) except InvalidDocument, e: logging.error(\"Unable to save log record: %s\", e.message ,exc_info=True) 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[12]－ 利用BeautifulSoup进行采集","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-17-training-python-12/","text":"1.BeautifulSoup操作： Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它像其它网络爬虫一样，可以便捷的操作html，如果你有jquery的使用经验，请使用Beautiful Soup 4. 安装时：pip install Beautiful Soup 4 网方文档地址：http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 2.糗百内容采集代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/python#coding=utf-8‘’‘功能：演示BeautifulSoup MySQLdb Process的使用’‘’from multiprocessing import Process, Pool, Pipe, cpu_count, active_childrenimport time,requestsfrom bs4 import BeautifulSoupfrom db.mysql import Custom_MySQLclass RebotQB(Process): def __init__(self, child_conn, data): Process.__init__(self) self.data = data self.child_conn = child_conn def insert_qiubai_content(self, datas): ''' 记录采集入口到数据库 ''' self.mysql = Custom_MySQL('test') # 查看当年当月当天的入口 # 演示 mysql count sql = 'select count(*) as count from qiubai\\ where year = %(year)s and month = %(month)s and day = %(day)s and page = %(page)s and `index`= %(index)s'% datas # print sql result = self.mysql.count(sql) count = result['count'] # 如果不存在 if int(count) == 0: # 演示insert self.mysql.insert('qiubai', **datas) # 如果存在 else: # 演示update self.mysql.update('qiubai', ' year = %(year)s and month =%(month)s and day = %(day)s and page=%(page)s and `index`=%(index)s' % datas, **datas) def run(self): print self.data['url'] # 获取页面内容 content = requests.get(self.data['url']).text if content == None: self.child_conn.put(&#123;'count': 0&#125;) return False # 变成soup可认内容 soup = BeautifulSoup(content, from_encoding=\"utf-8\") # 抓取笑话内容 # 规范请参考http://www.crummy.com/software/BeautifulSoup/bs4/doc/ # 同jquery选择器一样 tag_index = 0 for i in soup.select('[id^=\"qiushi_tag\"]'): # 确定是第几个笑话 tag_index = tag_index + 1 # 去掉内容和图片上次的内容 try: del self.data['content'] del self.data['img'] except: pass # 内容和图片变量 content = None img = None # 连接数据库并确认是本页的第几个笑话 self.mysql = Custom_MySQL('test') self.data.update(&#123;'index': tag_index&#125;) # 采集笑话内容 try: content = i.find(\"div\", attrs=&#123;'class': \"content\"&#125;) content = content.string self.data.update(&#123;'content': content.encode('gbk')&#125;) except: pass # 采集笑话中的图片 try: img = i.find(\"div\", attrs=&#123;'class': \"thumb\"&#125;) img = img.find('img').attrs['src'] self.data.update(&#123;'img': img&#125;) except: pass # 内容入库 result = self.insert_qiubai_content(self.data) # 统计每页要采集多少个笑话 self.child_conn.put(&#123;'count': tag_index&#125;)if __name__ == '__main__': from multiprocessing import Process, Queue q = Queue() data =&#123;'id':2,'url':'http://www.qiushibaike.com/history'&#125; r = RebotQB(q,data) r.start() 3.利用进程池代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python# coding=utf-8'''功能：采集糗百笑话，利用进程池,更改了一下系统pool的默认行为支持daemon模式'''import multiprocessing#我们必须显示声明引进multiprocessing模块，而不是Processimport multiprocessing.poolimport timefrom random import randintfrom multiprocessing import Processclass TaskProcess(Process): ''' 替成自己的业务类即可 ''' def __init__(self): Process.__init__(self) def __del__(self): pass def run(self): print 'TaskProcess is running 'class NoDaemonProcess(multiprocessing.Process): # 使进程总是daemon模式 def _get_daemon(self): return False def _set_daemon(self, value): pass daemon = property(_get_daemon, _set_daemon, None, doc='make \"daemon\" attribute always return False')#我们用multiprocessing.pool.Pool 代替 multiprocessing.Pool#因为这里只有最新的包装器函数, 而不是一个类.class CustomPool(multiprocessing.pool.Pool): Process = NoDaemonProcessdef work(num_procs): print(\"Creating %i (daemon) workers and jobs in child.\" % num_procs) # 自己的业务进程 p = TaskProcess() p.start()def test(): print(\"Creating 5 (non-daemon) workers and jobs in main process.\") year = [x for x in range(2008, 2014)] pool = CustomPool(len(year) * 4) result = pool.map(work, year) pool.close() pool.join() # print(result)if __name__ == '__main__': test() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[14]－ ansible多进程并发执行","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2016-12-06-training-python-14/","text":"1.业务场景游戏发布版本，涉及多个游戏平台一起发布的情况，所以在执行ansible时，需要指定游戏平以的服务器 集群IP，需要执行的yaml文件和host文件不同，为了对接资产，所以用python2.7实现最好. 2.安装扩展- pip install ansible2.2 3.接管ansible的playbook接口v2版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/python# coding=utf-8# unitl.pyfrom collections import namedtuplefrom ansible.parsing.dataloader import DataLoaderfrom ansible.vars import VariableManagerfrom ansible.inventory import Inventoryfrom ansible.playbook.play import Playfrom ansible.executor.task_queue_manager import TaskQueueManagerfrom ansible.executor.playbook_executor import PlaybookExecutorfrom ansible.plugins.callback import CallbackBasefrom ansible.utils.display import Displayimport jsonclass ResultsCollector(CallbackBase): def __init__(self, *args, **kwargs): super(ResultsCollector, self).__init__(*args, **kwargs) self.host_ok = &#123;&#125; self.host_unreachable = &#123;&#125; self.host_failed = &#123;&#125; def v2_runner_on_unreachable(self, result): self.host_unreachable.setdefault(result._host.get_name(), []).append(result._result) #print result._result.items() def v2_runner_on_ok(self, result, *args, **kwargs): if result._task.name: self.host_ok.setdefault(result._task.name,[]).append(result._host.name) #print result._result.items() def v2_runner_on_failed(self, result, *args, **kwargs): if result._task.name: self.host_failed.setdefault(result._task.name, []).append(result._host.name)class Distribute_playbook(): def __init__(self, playbook=\"./test.yaml\", hosts=\"\", group=\"\", username=\"playcrab\", passwd=&#123;&#125;, extra_vars=&#123;&#125;): self.display = Display() self.callback = ResultsCollector() self.extra_vars = extra_vars Options = namedtuple('Options', ['listtags', 'listtasks', 'listhosts', 'syntax', 'connection', 'module_path', 'forks', 'async', 'remote_user', 'private_key_file', 'ssh_common_args', 'ssh_extra_args', 'sftp_extra_args', 'scp_extra_args', 'become', 'become_method', 'become_user', 'verbosity', 'check']) self.options = Options(listtags=False, listtasks=False, listhosts=False, syntax=False, connection='smart', module_path='/usr/share/ansible', forks=10, async=3, remote_user=username, private_key_file=None, ssh_common_args=None, ssh_extra_args=None, sftp_extra_args=None, scp_extra_args=None, become=None, become_method=None, become_user=None, verbosity=None, check=False) # initialize needed objects self.variable_manager = VariableManager() self.variable_manager.extra_vars = self.extra_vars self.loader = DataLoader() self.passwords = dict(vault_pass=passwd) # 初始化 self.inventory_example = Inventory(loader=self.loader, variable_manager=self.variable_manager, host_list=hosts) # 得到所有组 self.inventory_example.get_groups() # 得到所有主机 result_hosts = self.inventory_example.get_hosts(pattern=group) host_list = [] for host in result_hosts: host_list.append(str(host)) # create inventory and pass to var manager self.inventory = Inventory(loader=self.loader, variable_manager=self.variable_manager, host_list=host_list) self.variable_manager.set_inventory(self.inventory) # create play with tasks self.play_source = dict( # name = \"Ansible Play\", hosts = host_list, # gather_facts = 'no', # #tasks = [ # # dict(action=dict(module='shell', args='ls'), register='shell_out'), # # dict(action=dict(module='debug', args=dict(msg='&#123;&#123;shell_out.stdout&#125;&#125;'))) # # ] # tasks = [ dict(action=dict(module='command', args=dict(cmd=cmd))) ] ) self.play = Play().load(self.play_source, variable_manager=self.variable_manager, loader=self.loader) self.playbook = playbook def run(self): # actually run it tqm = PlaybookExecutor( playbooks=[self.playbook], inventory=self.inventory, variable_manager=self.variable_manager, loader=self.loader, options=self.options, passwords=self.passwords, ) tqm._tqm._stdout_callback = self.callback tqm.run() def get_result(self): res=&#123;&#125; res['succ']=self.callback.host_ok res['fail'] = self.callback.host_failed res['unreach']=self.callback.host_unreachable return res 4.任务所需test.yaml1234567- hosts: all gather_facts: False vars: key: Ansible tasks: - name: display Host Variable from hostfile debug: msg=\" The &#123;&#123; inventory_hostname &#125;&#125; Value is &#123;&#123; key &#125;&#125;\" 5.任务所需hosts1234[test]192.168.5.2 192.168.5.3 192.168.5.4 5.执行任务12345678910111213141516171819202122232425262728293031 #!/usr/bin/python# coding=utf-8# test.py from unitl import Distribute_playbookimport multiprocessing class Worker(multiprocessing.Process): def __init__(self,index): self.index = index multiprocessing.Process.__init__(self) def run(self): #ansible-playbook -i ./hosts ./test.yaml test = Distribute_playbook(playbook=\"./test%s.yaml\"%self.index, hosts=\"./hosts\", group=\"test\") test.run() res = test.get_result() print(res) if __name__ == '__main__': jobs = [] for i in range(1,6): p = Worker(i) jobs.append(p) p.start() for j in jobs: j.join() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[13]－ Flask实现restful接口","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-05-20-training-python-13/","text":"1.安装扩展 pip install flask pip install flask-restful pip install sqlalchemy 网方文档地址：http://flask-restful.readthedocs.org/en/0.3.3/ 2.models代码：123456789101112131415161718192021222324252627#!/usr/bin/python#coding=utf-8‘’‘功能：定义数据表结构，生成需要生成数据表时，直接python models.py’‘’from sqlalchemy import Columnfrom sqlalchemy import Integerfrom sqlalchemy import Stringfrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()class Todo(Base): __tablename__ = 'todos' id = Column(Integer, primary_key=True) task = Column(String(255))‘’‘if __name__ == \"__main__\": from sqlalchemy import create_engine from settings import DB_URI engine = create_engine(DB_URI) Base.metadata.drop_all(engine) Base.metadata.create_all(engine)’‘’ 3.db代码：123456789101112131415#!/usr/bin/env python# coding=utf-8from sqlalchemy import create_enginefrom sqlalchemy.orm import scoped_sessionfrom sqlalchemy.orm import sessionmaker#from settings import DB_URIDB_URI = 'mysql://root:@localhost:3306/test?charset=utf8'Session = sessionmaker(autocommit=False, autoflush=False, bind=create_engine(DB_URI))session = scoped_session(Session) 4.resources代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# coding=utf-8'''功能：引入上面的models文件，将数据表数据进行对象化，定义restful资源，返回前数据利用marshal_with装饰器做序列化'''from models import Todofrom db import sessionfrom flask.ext.restful import reqparsefrom flask.ext.restful import abortfrom flask.ext.restful import Resourcefrom flask.ext.restful import fieldsfrom flask.ext.restful import marshal_withtodo_fields = &#123; 'id': fields.Integer, 'task': fields.String, 'uri': fields.Url('todo', absolute=True),&#125;parser = reqparse.RequestParser()parser.add_argument('task', type=str)class TodoResource(Resource): @marshal_with(todo_fields) def get(self, id): todo = session.query(Todo).filter(Todo.id == id).first() if not todo: abort(404, message=\"Todo &#123;&#125; doesn't exist\".format(id)) return todo def delete(self, id): todo = session.query(Todo).filter(Todo.id == id).first() if not todo: abort(404, message=\"Todo &#123;&#125; doesn't exist\".format(id)) session.delete(todo) session.commit() return &#123;&#125;, 204 @marshal_with(todo_fields) def put(self, id): parsed_args = parser.parse_args() print parsed_args todo = session.query(Todo).filter(Todo.id == id).first() todo.task = parsed_args['task'] session.add(todo) session.commit() return todo, 201class TodoListResource(Resource): @marshal_with(todo_fields) def get(self): todos = session.query(Todo).all() return todos @marshal_with(todo_fields) def post(self): parsed_args = parser.parse_args() todo = Todo(task=parsed_args['task']) session.add(todo) session.commit() return todo, 201 5.app代码：123456789101112131415161718#!/usr/bin/env python# coding=utf-8from flask import Flaskfrom flask.ext.restful import Apiapp = Flask(__name__)api = Api(app)from resources import TodoListResourcefrom resources import TodoResourceapi.add_resource(TodoListResource, '/todos', endpoint='todos')api.add_resource(TodoResource, '/todos/&lt;string:id&gt;', endpoint='todo')if __name__ == '__main__': app.run(debug=True) 5.test代码：1234567891011import requests, jsonprint requests.get('http://localhost:5000/todos').json()print requests.post('http://localhost:5000/todos', headers=&#123;'Content-Type': 'application/json'&#125;, data=json.dumps(&#123;'task': 'go outside!'&#125;)).json()print requests.get('http://localhost:5000/todos/1').json()print requests.put('http://localhost:5000/todos/1', headers=&#123;'Content-Type': 'application/json'&#125;, data=json.dumps(&#123;'task': 'go to the gym'&#125;)).json()print requests.delete('http://localhost:5000/todos/1')print requests.get('http://localhost:5000/todos').json() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[15]－ 视频教程","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2017-04-20-training-python-15/","text":"###为了培训python录的视频，每周更新，欢迎拍砖！ 请用无线观看，每个约200M大小 &gt; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[1]－python初步感观","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-10-training-python-1/","text":"###1、环境简介 os系统：centos6.5 python:2.7.7 或者 2.7.8 扩展要求:setuptools ,pip ,MySQL-python 如果你的python版本过低，可以用下面的脚本升级为2.7.7 脚本下载：http://pan.baidu.com/s/1jGDvFzo ###1.1 python使用方式 进入python shell环境 执行脚本模式 python demo.py ###2、初步感观12345678910111213141516171819202122232425262728293031323334#coding=utf-8#!/usr/bin/python2.7##################################################### python 第一个显示程序，用于初步感观####################################################def fib(): ''' a generator that produces the fibonacci series's elements ''' a = 1 b = 1 while True: a, b = a + b, a yield a def nth(series, n): ''' returns the nth element of a series, consuming the series' earlier elements. ''' for x in series: n -= 1 if n &lt;= 0: return x if __name__ == '__main__': print('Executed from the command line') print nth(fib(), 10) 执行 python demo.py 输出 Executed from the command line 144 ###3、Python格言 输入python 进入python shell环境 import this 显示python之禅 3.1 Python之禅 Beautiful is better than ugly. 漂亮的代码要比丑陋的代码要好得多。 Explicit is better than implicit. 明确的定义比 隐式定义更好。 Simple is better than complex. 简单比负责要好。 Complex is better than complicated. 负责要比搞复杂要好。 Flat is better than nested. 扁平结构要比嵌套结构好。 Sparse is better than dense. 简洁明了的代码要比稠密的代码要好。 Readability counts. 可读写的计数。 Special cases aren’t special enough to break the rules. 专门的用例不是特殊到足以违反规则。 Although practicality beats purity. 是的，实用性练就纯度。 Errors should never pass silently. 错误永远都不会沉默。 Unless explicitly silenced. 除非明确啥也不干。 In the face of ambiguity, refuse the temptation to guess. 面对模糊定义、拒绝视图拍脑袋猜。 There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. 虽然一开始不那面明确,我们会选择更清晰一条到走。 Now is better than never. 现在开始总比不开始的要好。 Although never is often better than right now. 虽然从不尝试总比现在开始尝试好。 If the implementation is hard to explain, it’s a bad idea. 如果实现难以说明，那它是个坏主意。 If the implementation is easy to explain, it may be a good idea. 如果实现容易说明，那它是个好主意。 Namespaces are one honking great idea – let’s do more of those! 名称空间是一个好东西——让我们做更多那样的东西! 3.2 Python“八荣八耻” 以动手实践为荣 , 以只看不练为耻; 以打印日志为荣 , 以单步跟踪为耻; 以空格缩进为荣 , 以制表缩进为耻; 以单元测试为荣 , 以人工测试为耻; 以模块复用为荣 , 以复制粘贴为耻; 以多态应用为荣 , 以分支判断为耻; 以Pythonic为荣 , 以冗余拖沓为耻; 以总结分享为荣 , 以跪求其解为耻; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"python技术分享[2]－list dict 基本使用","date":"2017-09-15T11:30:59.000Z","path":"2017/09/15/2015-04-13-training-python-2/","text":"定义: list:链表,有序的项目, 通过索引进行查找,使用方括号”[]”; tuple:元组,元组将多样的对象集合到一起,不能修改,通过索引进行查找, 使用括号”()”; dict:字典,字典是一组键(key)和值(value)的组合,通过键(key)进行查找,没有顺序, 使用大括号”{}”; set:集合,无序,元素只出现一次, 自动去重,使用”set([])” 12345678910#样例mylist = [1, 2, 3, 4, 'Oh'] mytuple = (1, 2, 'Hello', (4, 5)) mydict = &#123;'Wang' : 1, 'Hu' : 2, 'Liu' : 4&#125; myset = set(['Wang', 'Hu', 'Liu', 4, 'Wang']) print(mylist) print(mytuple) print(mydict) print(myset) 输出 [1, 2, 3, 4, ‘Oh’] (1, 2, ‘Hello’, (4, 5)) {‘Liu’: 4, ‘Wang’: 1, ‘Hu’: 2} set([‘Liu’, 4, ‘Wang’, ‘Hu’]) 我们重点讲字典和列表 ####一、List操作123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# coding=utf-8#################################################### # 功能：python入门引导 # #####################################################定义函数def list_test(): #初始化列表 sample_list = ['a','b',0,1,3] print sample_list #得到列表中的某一个值 value_start = sample_list[1:3] print value_start end_value = sample_list[-1] print end_value #删除列表的第一个值 del sample_list[0] #在列表中插入一个值 sample_list[0] = ['sample value'] sample_list[2] = 'second' sample_list.append('three') #得到列表的长度 list_length = len(sample_list) print list_length #列表遍历 for element in sample_list: print(element) #用同一个值初始化，形成一个含有六个元素的列表 sample_list = ['test']*6 for element in sample_list: print(element) if __name__ == '__main__': #调用函数 list_test() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python#coding=utf-8#################################################### # 功能：python入门引导 # ####################################################def dict_test(): #初始化字典 sample_dict = &#123;'a':'a','2':'b',3:'c'&#125; print sample_dict #获取指定的key的值 pop = sample_dict.pop('2') print pop print sample_dict get = sample_dict.get('a') print get print sample_dict print sample_dict[3] #删除指定key的值 pop = sample_dict.pop(3) print pop print sample_dict #在字典中插入一个值 sample_dict.update(&#123;3:'c','2':'b'&#125;) print sample_dict #获取字典长度 print len(sample_dict) #字典遍历 for element in sample_dict: print element,sample_dict[element] for (k, v) in sample_dict.items(): print \"sample_dict[%s] =\" % k, vif __name__ == '__main__': dict_test() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"python技术分享","slug":"python技术分享","permalink":"//www.zwting.com/tags/python技术分享/"}]},{"title":"kafka-flume集群环境搭建【1】","date":"2017-09-11T09:30:00.000Z","path":"2017/09/11/2017-09-11-cluster-kafka-1/","text":"1. 前期准备1.1 操作系统172.16.61.102,centos6.9 172.16.61.103,centos6.9 172.16.61.104,centos6.9 1.2 /etc/hosts （3主机均需要）172.16.61.102 kafka01 172.16.61.103 kafka02 172.16.61.104 kafka03 1.3 安装Java （3主机均需要）yum install java-1.8.0-openjdk -y 1.4 下载安装kafka （3主机均需要）cd ~ wget http://mirrors.hust.edu.cn/apache/kafka/0.11.0.0/kafka_2.11-0.11.0.0.tgz tar -xf kafka_2.11-0.11.0.0.tgz -C /usr/local/ ln -sv /usr/local/kafka_2.11-0.11.0.0 /usr/local/kafka ll /usr/local/kafka 2. 配置zookeeper2.1 zookeeper 配置[root@kafka102 ] cat /usr/local/kafka/config/zookeeper.properties dataDir=/data/zookeeper clientPort=2181 tickTime=2000 initLimit=20 syncLimit=10 server.102=172.16.61.102:2888:3888 server.103=172.16.61.103:2888:3888 server.104=172.16.61.104:2888:3888 [root@kafka103 ] cat /usr/local/kafka/config/zookeeper.properties dataDir=/data/zookeeper clientPort=2181 tickTime=2000 initLimit=20 syncLimit=10 server.102=172.16.61.102:2888:3888 server.103=172.16.61.103:2888:3888 server.104=172.16.61.104:2888:3888 [root@kafka104 ] cat /usr/local/kafka/config/zookeeper.properties dataDir=/data/zookeeper clientPort=2181 tickTime=2000 initLimit=20 syncLimit=10 server.102=172.16.61.102:2888:3888 server.103=172.16.61.103:2888:3888 server.104=172.16.61.104:2888:3888 2.2 创建数据目录 （3主机均需要）[root@kafka102 ] mkdir -p /data/zookeeper [root@kafka103 ] mkdir -p /data/zookeeper [root@kafka104] mkdir -p /data/zookeeper 2.3 写zookeeper标识（3主机均需要）[root@kafka102 ] echo 102 &gt; /data/zookeeper/myid [root@kafka103 ] echo 103 &gt; /data/zookeeper/myid [root@kafka104 ] echo 104 &gt; /data/zookeeper/myid 注意数字要zookeeper.properties中一致 2.4 启动zookeeper[root@kafka102 ]# nohup /usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties &amp; [root@kafka103 ]# nohup /usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties &amp; [root@kafka104 ]# nohup /usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties &amp; 2.5 停止zookeeper/usr/local/kafka/bin/zookeeper-server-stop.sh 3. 配置kafka3.1 server.properties 修改 broker.id、zookeeper.connect[root@kafka102 ~]# grep -v ^# /usr/local/kafka/config/server.properties|sed ‘/^$/d’ broker.id=102 num.network.threads=3 num.io.threads=8 socket.send.buffer.bytes=102400 socket.receive.buffer.bytes=102400 socket.request.max.bytes=104857600 log.dirs=/tmp/kafka-logs num.partitions=1 num.recovery.threads.per.data.dir=1 offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 log.retention.hours=168 log.segment.bytes=1073741824 log.retention.check.interval.ms=300000 zookeeper.connect=172.16.61.102:2181,172.16.61.103:2181,172.16.61.104:2181 zookeeper.connection.timeout.ms=6000 group.initial.rebalance.delay.ms=0 [root@kafka103 ~]# grep -v ^# /usr/local/kafka/config/server.properties|sed ‘/^$/d’ broker.id=103 num.network.threads=3 num.io.threads=8 socket.send.buffer.bytes=102400 socket.receive.buffer.bytes=102400 socket.request.max.bytes=104857600 log.dirs=/tmp/kafka-logs num.partitions=1 num.recovery.threads.per.data.dir=1 offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 log.retention.hours=168 log.segment.bytes=1073741824 log.retention.check.interval.ms=300000 zookeeper.connect=172.16.61.102:2181,172.16.61.103:2181,172.16.61.104:2181 zookeeper.connection.timeout.ms=6000 group.initial.rebalance.delay.ms=0 [root@kafka104 ~]# grep -v ^# /usr/local/kafka/config/server.properties|sed ‘/^$/d’ broker.id=104 num.network.threads=3 num.io.threads=8 socket.send.buffer.bytes=102400 socket.receive.buffer.bytes=102400 socket.request.max.bytes=104857600 log.dirs=/tmp/kafka-logs num.partitions=1 num.recovery.threads.per.data.dir=1 offsets.topic.replication.factor=1 transaction.state.log.replication.factor=1 transaction.state.log.min.isr=1 log.retention.hours=168 log.segment.bytes=1073741824 log.retention.check.interval.ms=300000 zookeeper.connect=172.16.61.102:2181,172.16.61.103:2181,172.16.61.104:2181 zookeeper.connection.timeout.ms=6000 group.initial.rebalance.delay.ms=0 3.2 启动kafka[root@kafka102 zookeeper]# nohup /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp; [root@kafka103 zookeeper]# nohup /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp; [root@kafka104 zookeeper]# nohup /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp; 3.3 停止kafka/usr/local/kafka/bin/kafka-server-stop.sh 3.4 查看各机器端口netstat -nlpt | grep -E &quot;2181|2888|3888|9092&quot; 4. kafka日常操作4.1 创建主题[root@kafka102 ~]# /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 172.16.61.102:2181 --replication-factor 3 --partitions 1 --topic test000 4.2 查看主题列表[root@kafka102 ~]# /usr/local/kafka/bin/kafka-topics.sh --list --zookeeper 172.16.61.102:2181 4.3 查看主题详细内容[root@kafka102 ~]# /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper 172.16.61.102:2181 --topic test000 4.4 生产者 和 消费者[root@kafka01 ~]# /usr/local/kafka/bin/kafka-console-producer.sh --broker-list 172.16.61.102:2181 --topic test000 [root@kafka01 ~]# /usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper 172.16.61.102:2181 --topic test000 --from-beginning 会有如下提示，需要用最新的指令 0.9+ Using the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper]. /usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test --producer.config /usr/local/kafka/config/producer.properties /usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --new-consumer --from-beginning --consumer.config /usr/local/kafka/config/consumer.properties 5. kafka问题实录：5.1 Q：因为没有启动kafka[root@kafka102 ~]# /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 172.16.61.102:2181 --replication-factor 3 --partitions 1 --topic test000 Error while executing topic command : replication factor: 3 larger than available brokers: 0 [2017-09-12 16:42:56,533] ERROR org.apache.kafka.common.errors.InvalidReplicationFactorException: replication factor: 3 larger than available brokers: 0 (kafka.admin.TopicCommand$) 参考&gt;http://blog.csdn.net/ddcowboy/article/details/54617740http://orchome.com/454","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"PHP7扩展开发官方译文[2]","date":"2017-08-29T11:51:59.000Z","path":"2017/08/29/Internal-value-representation-in-PHP-7-part-2/","text":"本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。 要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。 第一部分讲了 PHP5 和 PHP7 中关于变量最基础的实现和变化。这里再重复一下，主要的变化就是 zval 不再单独分配内存，不自己存储引用计数。整型浮点型等简单类型直接存储在 zval 中。复杂类型则通过指针指向一个独立的结构体。 复杂的 zval 数据值有一个共同的头，其结构由 zend_refcounted 定义： 123456789101112struct _zend_refcounted &#123; uint32_t refcount; union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) &#125; v; uint32_t type_info; &#125; u;&#125;; 这个头存储有 refcount（引用计数），值的类型 type 和循环回收的相关信息 gc_info 以及类型标志位 flags。 接下来会对每种复杂类型的实现单独进行分析并和 PHP5 的实现进行比较。引用虽然也属于复杂类型，但是上一部分已经介绍过了，这里就不再赘述。另外这里也不会讲到资源类型（因为作者觉得资源类型没什么好讲的）。 字符串PHP7 中定义了一个新的结构体 zend_string 用于存储字符串变量： 123456struct _zend_string &#123; zend_refcounted gc; zend_ulong h; /* hash value */ size_t len; char val[1];&#125;; 除了引用计数的头以外，字符串还包含哈希缓存 h，字符串长度 len 以及字符串\b的值 val。哈希缓存的存在是为了防止使用字符串做为 hashtable 的 key 在查找时需要重复计算其哈希值，所以这个在使用之前就对其进行初始化。 如果你对 C 语言了解的不是很深入的话，可能会觉得 val 的定义有些奇怪：这个声明只有一个元素，但是显然我们想存储的字符串偿付肯定大于一个字符的长度。这里其实使用的是结构体的一个『黑』\b方法：在声明数组时只定义一个元素，但是实际创建 zend_string 时再分配足够的内存来存储整个字符串。这样我们还是可以通过 val 访问完整的字符串。 当然这属于非常规的实现手段，因为我们实际的读和写的内容都超过了单字符数组的边界。但是 C 语言编译器却不知道你是这么做的。虽然 C99 也曾明确规定过支持『柔性数组』，但是感谢我们的好朋友微软，没人能在不同的平台上保证 C99 的一致性（所以这种手段是为了解决 Windows 平台下柔性数组的支持问题）。 新的字符串类型的结构比原生的 C 字符串更方便使用：第一是因为直接存储了字符串的长度，这样就不用每次使用时都去计算。第二是字符串也有引用计数的头，这样也就可以在不同的地方共享字符串本身而无需使用 zval。一个经常使用的地方就是共享 hashtable 的 key。 但是新的字符串类型也有一个很不好的地方：虽然可以很方便的从 zend_string 中取出 C 字符串（使用 str-&gt;val 即可），但反过来，如果将 C 字符串变成 zend_string 就需要先分配 zend_string 需要的内存，再将字符串复制到 zend_string 中。这在实际使用的过程中并不是很方便。 字符串也有一些特有的标志（存储在 GC 的标志位中的）： 123#define IS_STR_PERSISTENT (1&lt;&lt;0) /* allocated using malloc */#define IS_STR_INTERNED (1&lt;&lt;1) /* interned string */#define IS_STR_PERMANENT (1&lt;&lt;2) /* interned string surviving request boundary */ 持久化的字符串需要的内存直接从系统本身分配而不是 zend 内存管理器（ZMM），这样它就可以一直存在而不是只在单次请求中有效。给这种特殊的分配打上标记便于 zval 使用持久化字符串。在 PHP5 中并不是这样处理的，是在使用前复制一份到 ZMM 中。 保留字符（interned strings）有点特殊，它会一直存在直到请求结束时才销毁，所以也就无需进行引用计数。保留字符串也不可重复（duplicate），所以在创建新的保留字符时也会先检查是否有同样字符的已经存在。所有 PHP 源码中不可变的字符串都是保留字符（包括字符串常量、变量名函数名等）。持久化字符串也是请求开始之前已经创建好的保留字符。但普通的保留字符在请求结束后会销毁，持久化字符串却始终存在。 如果使用了 opcache 的话保留字符会被存储在共享内存（SHM）中这样就可以在所有 PHP 进程质检共享。这种情况下持久化字符串也就没有存在的意义了，因为保留字符也是不会被销毁的。 数组因为之前的文章有讲过新的数组实现，所以这里就不再详细描述了。虽然最近有些变化导致之前的描述不是十分准确了，但是基本的概念还是一致的。 这里要说的是之前的文章中没有提到的数组相关的概念：不可变数组。其本质上和保留字符类似：没有引用计数且在请求结束之前一直存在（也可能在请求结束之后还存在）。 因为某些内存管理方便的原因，不可变数组只会在开启 opcache 时会使用到。我们来看看实际使用的例子，先看以下的脚本： 12345&lt;?phpfor ($i = 0; $i &lt; 1000000; ++$i) &#123; $array[] = ['foo'];&#125;var_dump(memory_get_usage()); 开启 opcache 时，以上代码会使用 32MB 的内存，不开启的情况下因为 $array 每个元素都会复制一份 [&#39;foo&#39;] ，所以需要 390MB。这里会进行完整的复制而不是增加引用计数值的原因是防止 zend 虚拟机操作符执行的时候出现共享内存出错的情况。我希望不使用 opcache 时内存暴增的问题以后能得到改善。 PHP5 中的对象在了解 PHP7 中的对象实现直线我们先看一下 PHP5 的并且看一下有什么效率上的问题。PHP5 中的 zval 会存储一个 zend_object_value 结构，其定义如下： 1234typedef struct _zend_object_value &#123; zend_object_handle handle; const zend_object_handlers *handlers;&#125; zend_object_value; handle 是对象的唯一 ID，可以用于查找对象数据。handles 是保存对象各种属性方法的虚函数表指针。通常情况下 PHP 对象都有着同样的 handler 表，但是 PHP 扩展创建的对象也可以通过操作符重载等方式对其行为自定义。 对象句柄\b（handler）是作为索引用于『对象存储』，对象存储本身是一个存储容器（bucket）的数组，bucket 定义如下： 12345678910111213141516171819typedef struct _zend_object_store_bucket &#123; zend_bool destructor_called; zend_bool valid; zend_uchar apply_count; union _store_bucket &#123; struct _store_object &#123; void *object; zend_objects_store_dtor_t dtor; zend_objects_free_object_storage_t free_storage; zend_objects_store_clone_t clone; const zend_object_handlers *handlers; zend_uint refcount; gc_root_buffer *buffered; &#125; obj; struct &#123; int next; &#125; free_list; &#125; bucket;&#125; zend_object_store_bucket; 这个结构体包含了很多东西。前三个成员只是些普通的元数据（对象的析构函数是否被调用过、bucke 是否被使用过以及对象被递归调用过多少次）。接下来的联合体用于区分 bucket 是处于使用中的状态还是空闲状态。上面的结构中最重要的是 struct _store_object 子结构体： 第一个成员 object 是指向实际对象（也就是对象最终存储的位置）的指针。对象实际并不是直接嵌入到对象存储的 bucket 中的，因为对象不是定长的。对象指针下面是三个用于管理对象销毁、释放与克隆的操作句柄（handler）。这里要注意的是 PHP 销毁和释放对象是不同的步骤，前者在某些情况下有可能会被跳过（不完全释放）。克隆操作实际上几乎几乎不会被用到，因为这里包含的操作不是普通对象本身的一部分，所以（任何时候）他们在每个对象中他们都会被单独复制（duplicate）一份而不是共享。 这些对象存储操作句柄后面是一个普通的对象 handlers 指针。\b存储这几个数据是因为有时候可能会在 zval 未知的情况下销毁对象（通常情况下这些操作都是针对 zval 进行的）。 bucket 也包含了 refcount 的字段，不过这种行为在 PHP5 中显得有些奇怪，因为 zval 本身已经存储了引用计数。为什么还需要一个多余的计数呢？问题在于虽然通常情况下 zval 的『复制』行为都是简单的增加引用计数即可，但是偶尔也会有深度复制的情况出现，比如创建一个全新的 zval 但是保存同样的 zend_object_value。这种情况下两个不同的 zval 就用到了同一个对象存储的 bucket，所以 bucket 自身也需要进行引用计数。这种『双重计数』的方式是 PHP5 的实现内在的问题。GC 根缓冲区中的 buffered 指针也是由于同样的原因才需要进行完全复制（duplicate）。 现在看看对象存储中指针指向的实际的 object 的结构，通常情况下用户层面的对象定义如下： 123456typedef struct _zend_object &#123; zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards;&#125; zend_object; zend_class_entry 指针指向的是对象实现的类原型。接下来的两个元素是使用不同的方式存储对象属性。动态属性（运行时添加的而不是在类中定义的）全部存在 properties 中，不过只是属性名和值的简单匹配。 不过这里有针对已经声明的属性的一个优化：编译期间每个属性都会被指定一个索引并且属性本身是存储在 properties_table 的索引中。属性名称和索引的匹配存储在类原型的 hashtable 中。这样就可以防止每个对象使用的内存超过 hashtable 的上限，并且属性的索引会在运行时有多处缓存。 guards 的哈希表是用于实现魔术方法的递归行为的，比如 __get，这里我们不深入讨论。 除了上文提到过的双重计数的问题，这种实现还有一个问题是一个最小的只有一个\b属性的对象也需要 136 个字节的内存（这还不算 zval 需要的内存）。而且中间存在很多间接访问动作：比如要从对象 zval 中取出一个元素，先需要取出对象存储 bucket，然后是 zend object，然后才能通过指针找到对象属性表和 zval。这样这里至少就有 4 层间接访问（并且实际使用中可能最少需要七层）。 PHP7 中的对象PHP7 的实现中试图解决上面这些问题，包括去掉双重引用计数、减少内存使用以及间接访问。新的 zend_object 结构体如下： 12345678struct _zend_object &#123; zend_refcounted gc; uint32_t handle; zend_class_entry *ce; const zend_object_handlers *handlers; HashTable *properties; zval properties_table[1];&#125;; 可以看到现在这个结构体几乎就是一个对象的全部内容了：zend_object_value 已经被替换成一个直接指向对象和对象存储的指针，虽然没有完全移除，但已经是很大的提升了。 除了 PHP7 中惯用的 zend_refcounted 头以外，handle 和 对象的 handlers 现在也被放到了 zend_object 中。这里的 properties_table 同样用到了 C 结构体的小技巧，这样 zend_object 和属性表就会得到一整块内存。当然，现在属性表是直接嵌入到 zval 中的而不是指针。 现在对象结构体中没有了 guards 表，现在如果需要的话这个字段的值会被存储在 properties_table 的第一位中，也就是使用 __get 等方法的时候。不过如果没有使用魔术方法的话，guards 表会被省略。 dtor、free_storage 和 clone 三个操作句柄之前是存储在对象操作 bucket 中，现在直接存在 handlers 表中，其结构体定义如下： 12345678910struct _zend_object_handlers &#123; /* offset of real object header (usually zero) */ int offset; /* general object functions */ zend_object_free_obj_t free_obj; zend_object_dtor_obj_t dtor_obj; zend_object_clone_obj_t clone_obj; /* individual object functions */ // ... rest is about the same in PHP 5&#125;; handler 表的第一个成员是 offset，很显然这不是一个操作句柄。这个 offset 是现在的实现中必须存在的，因为虽然内部的对象总是嵌入到标准的 zend_object 中，但是也总会有添加一些成员进去的需求。在 PHP5 中解决这个问题的方法是添加一些内容到标准的对象后面： 12345struct custom_object &#123; zend_object std; uint32_t something; // ...&#125;; 这样如果你可以轻易的将 zend_object* 添加到 struct custom_object* 中。这也是 C 语言中常用的结构体继承的做法。但是在 PHP7 中这种实现会有一个问题：因为 zend_object 在存储属性表时用了结构体 hack 的技巧，zend_object 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中会把自己添加的成员添加到标准对象结构的前面： 12345struct custom_object &#123; uint32_t something; // ... zend_object std;&#125;; 不过这样也就意味着现在无法直接在 zend_object* 和 struct custom_object* 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值。 也许你会好奇既然现在已经直接（在 zend_value 中）存储了 zend_object 的指针，那现在就不需要再到对象存储中去查找对象了，为什么 PHP7 的对象者还保留着 handle 字段呢？ 这是因为现在对象存储仍然存在，虽然得到了极大的简化，所以保留 handle 仍然是有必要的。现在它只是一个指向对象的指针数组。当对象被创建时，会有一个指针插入到对象存储中并且其索引会保存在 handle 中，当对象被释放时，索引也会被移除。 那么为什么现在还需要对象存储呢？因为在请求结束的阶段会在存在某个节点，在这之后再去执行用户代码并且取指针数据时就不安全了。为了避免这种情况出现 PHP 会在更早的节点上执行所有对象的析构函数并且之后就不再有此类操作，所以就需要一个活跃对象的列表。 并且 handle 对于调试也是很有用的，它让每个对象都有了一个唯一的 ID，这样就很容易区分两个对象是同一个还是只是有相同的内容。虽然 HHVM 没有对象存储的概念，但它也存了对象的 handle。 和 PHP5 相比，现在的实现中只有一个引用计数（zval 自身不计数），并且内存的使用量有了很大的缩减：40 个字节用于基础对象，每个属性需要 16 个字节，并且这还是算了 zval 之后的。间接访问的情况也有了显著的改善，因为现在中间层的结构体要么被去掉了，要么就是直接嵌入的，所以现在读取一个属性只有一层访问而不再是四层。 间接 zval到现在我们已经基本提到过了所有正常的 zval 类型，但是也有一对特殊类型用于某些特定的情况的，其中之一就是 PHP7 新添加的 IS_INDIRECT。 间接 zval 指的就是其真正的值是存储在其他地方的。注意这个 IS_REFERENCE 类型是不同的，间接 zval 是直接指向另外一个 zval 而不是像 zend_reference 结构体一样嵌入 zval。 为了理解在什么时候会出现这种情况，我们来看一下 PHP 中变量的实现（实际上对象属性的存储也是一样的情况）。 所有在编译过程中已知的变量都会被指定一个索引并且其值会被存在编译变量（CV）表的相应位置中。但是 PHP 也允许你动态的引用变量，不管是局部变量还是全局变量（比如 $GLOBALS），只要出现这种情况，PHP 就会为脚本或者函数创建一个符号表，这其中包含了变量名和它们的值之间的映射关系。 但是问题在于：怎么样才能实现两\b个表的同时访问呢？我们需要在 CV 表中能够访问普通变量，也需要能在符号表中访问编译变量。在 PHP5 中 CV 表用了双重指针 zval**，通常这些指针指向中间的 zval* 的表，zval* 最终指向的才是实际的 zval: 1234567+------ CV_ptr_ptr[0]| +---- CV_ptr_ptr[1]| | +-- CV_ptr_ptr[2]| | || | +-&gt; CV_ptr[0] --&gt; some zval| +---&gt; CV_ptr[1] --&gt; some zval+-----&gt; CV_ptr[2] --&gt; some zval 当需要使用符号表时存储 zval* 的中间表其实是没有用到的而 zval** 指针会被更新到 hashtable buckets 的响应位置中。我们假定有 $a、$b 和 $c 三个变量，下面是简单的示意图： 123CV_ptr_ptr[0] --&gt; SymbolTable[\"a\"].pDataPtr --&gt; some zvalCV_ptr_ptr[1] --&gt; SymbolTable[\"b\"].pDataPtr --&gt; some zvalCV_ptr_ptr[2] --&gt; SymbolTable[\"c\"].pDataPtr --&gt; some zval 但是 PHP7 的用法中已经没有这个问题了，因为 PHP7 中的 hashtable 大小发生变化时 hashtable bucket 就失效了。所以 PHP7 用了一个相反的策略：为了访问 CV 表中存储的变量，符号表中存储 INDIRECT 来指向 CV 表。CV 表在符号表的生命周期内不会重新分配，所以也就不会存在有无效指针的问题了。 所以加入你有一个函数并且在 CV 表中有 $a、$b 和 $c，同时还有一个动态分配的变量 $d，符号表的结构看起来大概就是这个样子： 1234SymbolTable[\"a\"].value = INDIRECT --&gt; CV[0] = LONG 42SymbolTable[\"b\"].value = INDIRECT --&gt; CV[1] = DOUBLE 42.0SymbolTable[\"c\"].value = INDIRECT --&gt; CV[2] = STRING --&gt; zend_string(\"42\")SymbolTable[\"d\"].value = ARRAY --&gt; zend_array([4, 2]) 间接 zval 也可以是一个指向 IS_UNDEF 类型 zval 的指针，\b当 hashtable 没有和它关联的 key 时就会出现这种情况。所以当使用 unset($a) 将 CV[0] 的类型标记为 UNDEF 时就会判定符号表不存在键值为 a 的数据。 常量和 AST还有两个需要说一下的在 PHP5 和 PHP7 中都存在的特殊类型 IS_CONSTANT 和 IS_CONSTANT_AST。要了解他们我们还是先看以下的例子： 12345678&lt;?phpfunction test($a = ANSWER, $b = ANSWER * ANSWER) &#123; return $a + $b;&#125;define('ANSWER', 42);var_dump(test()); // int(42 + 42 * 42)· test() 函数的两个参数的默认值都是由常量 ANSWER构成，但是函数声明时常量的值尚未定义。常量的具体值只有通过 define() 定义时才知道。 由于以上问题的存在，参数和属性的默认值、常量以及其他接受『静态表达式』的东西都支持『延时绑定』直到首次使用时。 常量（或者类的静态属性）这些需要『延时绑定』的数据就是最常需要用到 IS_CONSTANT 类型 zval 的地方。如果这个值是表达式，就会使用 IS_CONSTANT_AST 类型的 zval 指向表达式的抽象语法树（AST）。 到这里我们就结束了对 PHP7 中变量实现的分析。后面我可能还会写两篇文章来介绍一些虚拟机优化、新的命名约定以及一些编译器基础结构的优化的内容（这是作者原话）。 译者注：两篇文章篇幅较长，翻译中可能有疏漏或不正确的地方，如果发现了请及时指正。","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"PHP7扩展开发官方译文[1]","date":"2017-08-28T07:51:59.000Z","path":"2017/08/28/Internal-value-representation-in-PHP-7-part-1/","text":"本文第一部分和第二均翻译自Nikita Popov(nikic，PHP 官方开发组成员，柏林科技大学的学生) 的博客。为了更符合汉语的阅读习惯，文中并不会逐字逐句的翻译。 要理解本文，你应该对 PHP5 中变量的实现有了一些了解，本文重点在于解释 PHP7 中 zval 的变化。 由于大量的细节描述，本文将会分成两个部分：第一部分主要描述 zval(zend value) 的实现在 PHP5 和 PHP7 中有何不同以及引用的实现。第二部分将会分析单独类型（strings、objects）的细节。 PHP5 中的 zvalPHP5 中 zval 结构体定义如下： 123456typedef struct _zval_struct &#123; zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc;&#125; zval; 如上，zval 包含一个 value、一个 type 以及两个 __gc 后缀的字段。value 是个联合体，用于存储不同类型的值： 1234567891011typedef union _zvalue_value &#123; long lval; // 用于 bool 类型、整型和资源类型 double dval; // 用于浮点类型 struct &#123; // 用于字符串 char *val; int len; &#125; str; HashTable *ht; // 用于数组 zend_object_value obj; // 用于对象 zend_ast *ast; // 用于常量表达式(PHP5.6 才有)&#125; zvalue_value; C 语言联合体的特征是一次只有一个成员是有效的并且分配的内存与需要内存最多的成员匹配（也要考虑内存对齐）。所有成员都存储在内存的同一个位置，根据需要存储不同的值。当你\b需要 lval 的时候，它存储的是有符号整形，需要 dval 时，会存储双精度浮点数。 需要指出的是是联合体中当前存储的数据类型会记录到 type 字段，用一个整型来标记： 123456789101112#define IS_NULL 0 /* Doesn't use value */#define IS_LONG 1 /* Uses lval */#define IS_DOUBLE 2 /* Uses dval */#define IS_BOOL 3 /* Uses lval with values 0 and 1 */#define IS_ARRAY 4 /* Uses ht */#define IS_OBJECT 5 /* Uses obj */#define IS_STRING 6 /* Uses str */#define IS_RESOURCE 7 /* Uses lval, which is the resource ID *//* Special types used for late-binding of constants */#define IS_CONSTANT 8#define IS_CONSTANT_AST 9 PHP5 中的引用计数在PHP5中，zval 的内存是单独从堆（heap）中分配的（有少数例外情况），PHP 需要知道哪些 zval 是正在使用的，哪些是需要释放的。所以这就需要用到引用计数：zval 中 refcount__gc 的值用于保存 zval 本身被引用的次数，比如 $a = $b = 42 语句中，42 被两个变量引用，所以它的引用计数就是 2。如果引用计数变成 0，就意味着这个变量已经没有用了，内存也就可以释放了。 注意这里提及到的引用计数指的不是 PHP 代码中的引用（使用 &amp;），而是变量的使用次数。后面两者需要同时出现时会使用『PHP 引用』和『引用』来区分两个概念，这里先忽略掉 PHP 的部分。 一个和引用计数紧密相关的概念是『写时复制』：对于多个引用来说，zaval 只有在没有变化的情况下才是共享的，一旦其中一个引用改变 zval 的值，就需要复制（”separated”）一份 zval，然后修改复制后的 zval。 下面是一个关于『写时复制』和 zval 的销毁的例子： 1234567891011121314&lt;?php$a = 42; // $a -&gt; zval_1(type=IS_LONG, value=42, refcount=1)$b = $a; // $a, $b -&gt; zval_1(type=IS_LONG, value=42, refcount=2)$c = $b; // $a, $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=3)// 下面几行是关于 zval 分离的$a += 1; // $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=2) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)unset($b); // $c -&gt; zval_1(type=IS_LONG, value=42, refcount=1) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)unset($c); // zval_1 is destroyed, because refcount=0 // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1) 引用计数有个致命的问题：无法检查并释放循环引用（使用的内存）。为了解决这问题，PHP 使用了循环回收的方法。当一个 zval 的计数减一时，就有可能属于循环的一部分，这时将 zval 写入到『根缓冲区』中。当缓冲区满时，潜在的循环会被打上标记并进行回收。 因为要支持循环回收，实际使用的 zval 的结构实际上如下： 1234567typedef struct _zval_gc_info &#123; zval z; union &#123; gc_root_buffer *buffered; struct _zval_gc_info *next; &#125; u;&#125; zval_gc_info; zval_gc_info 结构体中嵌入了一个正常的 zval 结构，同时也增加了两个指针参数，但是共属于同一个联合体 u，所以实际使用中只有一个指针是有用的。buffered 指针用于存储 zval 在根缓冲区的引用地址，所以如果在循环回收执行之前 zval 已经被销毁了，这个字段就可能被移除了。next 在回收销毁值的时候使用，这里不会深入。 修改动机下面说说关于内存使用上的情况，这里说的都是指在 64 位的系统上。首先，由于 str 和 obj 占用的大小一样， zvalue_value 这个联合体占用 16 个字节（bytes）的内存。整个 zval 结构体占用的内存是 24 个字节（考虑到内存对齐），zval_gc_info 的大小是 32 个字节。综上，在堆（相对于栈）分配给 zval 的内存需要额外的 16 个字节，所以每个 zval 在不同的地方一共需要用到 48 个字节（要理解上面的计算方式需要注意每个指针在 64 位的系统上也需要占用 8 个字节）。 在这点上不管从什么方面去考虑都可以认为 zval 的这种设计效率是很低的。比如 zval 在存储整型的时候本身只需要 8 个字节，即使考虑到需要存一些附加信息以及内存对齐，额外 8 个字节应该也是足够的。 在存储整型时本来确实需要 16 个字节，但是实际上还有 16 个字节用于引用计数、16 个字节用于循环回收。所以说 zval 的内存分配和释放都是消耗很大的操作，我们有必要对其进行优化。 从这个角度思考：一个整型数据真的需要存储引用计数、循环回收的信息并且单独在堆上分配内存吗？答案是当然不，这种处理方式一点都不好。 这里总结一下 PHP5 中 zval 实现方式存在的主要问题： zval 总是单独从堆中分配内存； zval 总是存储引用计数和循环回收的信息，即使是整型这种可能并不需要此类信息的数据； 在使用对象或者资源时，直接引用会导致两次计数（原因会在下一部分讲）； 某些间接访问需要一个更好的处理方式。比如现在访问存储在变量中的对象间接使用了四个指针（指针链的长度为四）。这个问题也放到下一部分讨论； 直接计数也就意味着数值只能在 zval 之间共享。如果想在 zval 和 hashtable key 之间共享一个字符串就不行（除非 hashtable key 也是 zval）。 PHP7 中的 zval在 PHP7 中 zval 有了新的实现方式。最基础的变化就是 zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。复杂数据类型（比如字符串、数组和对象）的引用计数由其自身来存储。这种实现方式有以下好处： 简单数据类型不需要单独分配内存，也不需要计数； 不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的； 由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间； 间接访问需要的指针数减少了。 我们看看现在 zval 结构体的定义（现在在 zend_types.h 文件中）： 12345678910111213141516171819202122struct _zval_struct &#123; zend_value value; /* value */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2;&#125;; 结构体的第一个元素没太大变化，仍然是一个 value 联合体。第二个成员是由一个表示类型信息的整型和一个包含四个字符变量的结构体组成的联合体（可以忽略 ZEND_ENDIAN_LOHI_4 宏，它只是用来解决跨平台大小端问题的）。这个子结构中比较重要的部分是 type（和以前类似）和 type_flags，这个接下来会解释。 上面这个地方也有一点小问题：value 本来应该占 8 个字节，但是由于内存对齐，哪怕只增加一个字节，实际上也是占用 16 个字节（使用一个字节就意味着需要额外的 8 个字节）。但是显然我们并不需要 8 个字节来存储一个 type 字段，所以我们在 u1 的后面增加了了一个名为 u2 的联合体。默认情况下是用不到的，需要使用的时候可以用来存储 4 个字节的数据。这个联合体可以满足不同场景下的需求。 PHP7 中 value 的结构定义如下： 12345678910111213141516171819typedef union _zend_value &#123; zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value; 首先需要注意的是现在 value 联合体需要的内存是 8 个字节而不是 16。它只会直接存储整型（lval）或者浮点型（dval）数据，其他情况下都是指针（上面提到过，指针占用 8 个字节，最下面的结构体由两个 4 字节的无符号整型组成）。上面所有的指针类型（除了特殊标记的）都有一个同样的头（zend_refcounted）用来存储引用计数： 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; /* reference counter 32-bit */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, /* used for strings &amp; objects */ uint16_t gc_info) /* keeps GC root number (or 0) and color */ &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 现在，这个结构体肯定会包含一个存储引用计数的字段。除此之外还有 type、flags 和 gc_info。type 存储的和 zval 中的 type 相同的内容，这样 GC 在不存储 zval 的情况下单独使用引用计数。flags 在不同的数据类型中有不同的用途，这个放到下一部分讲。 gc_info 和 PHP5 中的 buffered 作用相同，不过不再是位于根缓冲区的指针，而是一个索引数字。因为以前根缓冲区的大小是固定的（10000 个元素），所以使用一个 16 位（2 字节）的数字代替 64 位（8 字节）的指针足够了。gc_info 中同样包含一个『颜色』位用于回收时标记结点。 zval 内存管理上文提到过 zval 需要的内存不再单独从堆上分配。但是显然总要有地方来存储它，所以会存在哪里呢？实际上大多时候它还是位于堆中（所以前文中提到的地方重点不是堆，而是单独分配），只不过是嵌入到其他的数据结构中的，比如 hashtable 和 bucket 现在就会直接有一个 zval 字段而不是指针。所以函数表编译变量和对象属性在存储时会是一个 zval 数组并得到一整块内存而不是散落在各处的 zval 指针。之前的 zval * 现在都变成了 zval。 之前当 zval 在一个新的地方使用时会复制一份 zval * 并增加一次引用计数。现在就直接复制 zval 的值（忽略 u2），某些情况下可能会增加其结构指针指向的引用计数（如果在进行计数）。 那么 PHP 怎么知道 zval 是否正在计数呢？不是所有的数据类型都能知道，因为有些类型（比如字符串或数组）并不是总需要进行引用计数。所以 type_info 字段就是用来记录 zval 是否在进行计数的，这个字段的值有以下几种情况： 123456#define IS_TYPE_CONSTANT (1&lt;&lt;0) /* special */#define IS_TYPE_IMMUTABLE (1&lt;&lt;1) /* special */#define IS_TYPE_REFCOUNTED (1&lt;&lt;2)#define IS_TYPE_COLLECTABLE (1&lt;&lt;3)#define IS_TYPE_COPYABLE (1&lt;&lt;4)#define IS_TYPE_SYMBOLTABLE (1&lt;&lt;5) /* special */ 注：在 7.0.0 的正式版本中，上面这一段宏定义的注释这几个宏是供 zval.u1.v.type_flags 使用的。这应该是注释的错误，因为这个上述字段是 zend_uchar 类型。 type_info 的三个主要的属性就是『可计数』（refcounted）、『可回收』（collectable）和『可复制』（copyable）。计数的问题上面已经提过了。『可回收』用于标记 zval 是否参与循环，不如字符串通常是可计数的，但是你却没办法给字符串制造一个循环引用的情况。 是否可复制用于表示在复制时是否需要在复制时制造（原文用的 “duplication” 来表述，用中文表达出来可能不是很好理解）一份一模一样的实体。”duplication” 属于深度复制，比如在复制数组时，不仅仅是简单增加数组的引用计数，而是制造一份全新值一样的数组。但是某些类型（比如对象和资源）即使 “duplication” 也只能是增加引用计数，这种就属于不可复制的类型。这也和对象和资源现有的语义匹配（现有，PHP7 也是这样，不单是 PHP5）。 下面的表格上标明了不同的类型会使用哪些标记（x 标记的都是有的特性）。『简单类型』（simple types）指的是整型或布尔类型这些不使用指针指向一个结构体的类型。下表中也有『不可变』（immutable）的标记，它用来标记不可变数组的，这个在下一部分再详述。 interned string（保留字符）在这之前没有提过，其实就是函数名、变量名等无需计数、不可重复的字符串。 12345678910 | refcounted | collectable | copyable | immutable----------------+------------+-------------+----------+----------simple types | | | |string | x | | x |interned string | | | |array | x | x | x |immutable array | | | | xobject | x | x | |resource | x | | |reference | x | | | 要理解这一点，我们可以来看几个例子，这样可以更好的认识 zval 内存管理是怎么工作的。 下面是整数行为模式，在上文中 PHP5 的例子的基础上进行了一些简化 ： 1234567891011&lt;?php$a = 42; // $a = zval_1(type=IS_LONG, value=42)$b = $a; // $a = zval_1(type=IS_LONG, value=42) // $b = zval_2(type=IS_LONG, value=42)$a += 1; // $a = zval_1(type=IS_LONG, value=43) // $b = zval_2(type=IS_LONG, value=42)unset($a); // $a = zval_1(type=IS_UNDEF) // $b = zval_2(type=IS_LONG, value=42) 这个过程其实挺简单的。现在整数不再是共享的，变量直接就会分离成两个单独的 zval，由于现在 zval 是内嵌的所以也不需要单独分配内存，所以这里的注释中使用 = 来表示的而不是指针符号 -&gt;，unset 时变量会被标记为 IS_UNDEF。下面看一下更复杂的情况： 123456789101112&lt;?php$a = []; // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])$b = $a; // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[]) // $b = zval_2(type=IS_ARRAY) ---^// zval 分离在这里进行$a[] = 1 // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1, value=[1]) // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])unset($a); // $a = zval_1(type=IS_UNDEF), zend_array_2 被销毁 // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[]) 这种情况下每个变量变量有一个单独的 zval，但是是指向同一个（有引用计数） zend_array 的结构体。修改其中一个数组的值时才会进行复制。这点和 PHP5 的情况类似。 类型（Types）我们大概看一下 PHP7 支持哪些类型（zval 使用的类型标记）： 1234567891011121314151617181920/* regular data types */#define IS_UNDEF 0#define IS_NULL 1#define IS_FALSE 2#define IS_TRUE 3#define IS_LONG 4#define IS_DOUBLE 5#define IS_STRING 6#define IS_ARRAY 7#define IS_OBJECT 8#define IS_RESOURCE 9#define IS_REFERENCE 10/* constant expressions */#define IS_CONSTANT 11#define IS_CONSTANT_AST 12/* internal types */#define IS_INDIRECT 15#define IS_PTR 17 这个列表和 PHP5 使用的类似，不过增加了几项： IS_UNDEF 用来标记之前为 NULL 的 zval 指针（和 IS_NULL 并不冲突）。比如在上面的例子中使用 unset 注销变量； IS_BOOL 现在分割成了 IS_FALSE 和 IS_TRUE 两项。现在布尔类型的标记是直接记录到 type 中，这么做可以优化类型检查。不过这个变化对用户是透明的，还是只有一个『布尔』类型的数据（PHP 脚本中）。 PHP 引用不再使用 is_ref 来标记，而是使用 IS_REFERENCE 类型。这个也要放到下一部分讲； IS_INDIRECT 和 IS_PTR 是特殊的内部标记。 实际上上面的列表中应该还存在两个 fake types，这里忽略了。 IS_LONG 类型表示的是一个 zend_long 的值，而不是原生的 C 语言的 long 类型。原因是 Windows 的 64 位系统（LLP64）上的 long 类型只有 32 位的位深度。所以 PHP5 在 Windows 上只能使用 32 位的数字。PHP7 允许你在 64 位的操作系统上使用 64 位的数字，即使是在 Windows 上面也可以。 zend_refcounted 的内容会在下一部分讲。下面看看 PHP 引用的实现。 引用PHP7 使用了和 PHP5 中完全不同的方法来处理 PHP &amp; 符号引用的问题（这个改动也是 PHP7 开发过程中大量 bug 的根源）。我们先从 PHP5 中 PHP 引用的实现方式说起。 通常情况下， 写时复制原则意味着当你修改一个 zval 之前需要对其进行分离来保证始终修改的只是某一个 PHP 变量的值。这就是传值调用的含义。 但是使用 PHP 引用时这条规则就不适用了。如果一个 PHP 变量是 PHP 引用，就意味着你想要在将多个 PHP 变量指向同一个值。PHP5 中的 is_ref 标记就是用来注明一个 PHP 变量是不是 PHP 引用，在修改时需不需要进行分离的。比如： 123456&lt;?php$a = []; // $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])$b =&amp; $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[])$b[] = 1; // $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1]) // 因为 is_ref 的值是 1, 所以 PHP 不会对 zval 进行分离 但是这个设计的一个很大的问题在于它无法在一个 PHP 引用变量和 PHP 非引用变量之间共享同一个值。比如下面这种情况： 12345678910111213&lt;?php$a = []; // $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])$b = $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])$c = $b // $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[])$d =&amp; $c; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[]) // $d 是 $c 的引用, 但却不是 $a 的 $b, 所以这里 zval 还是需要进行复制 // 这样我们就有了两个 zval, 一个 is_ref 的值是 0, 一个 is_ref 的值是 1.$d[] = 1; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1]) // 因为有两个分离了的 zval, $d[] = 1 的语句就不会修改 $a 和 $b 的值. 这种行为方式也导致在 PHP 中使用引用比普通的值要慢。比如下面这个例子： 1234&lt;?php$array = range(0, 1000000);$ref =&amp; $array;var_dump(count($array)); // &lt;-- 这里会进行分离 因为 count() 只接受传值调用，但是 $array 是一个 PHP 引用，所以 count() 在执行之前实际上会有一个对数组进行完整的复制的过程。如果 $array 不是引用，这种情况就不会发生了。 现在我们来看看 PHP7 中 PHP 引用的实现。因为 zval 不再单独分配内存，也就没办法再使用和 PHP5 中相同的实现了。所以增加了一个 IS_REFERENCE 类型，并且专门使用 zend_reference 来存储引用值： 1234struct _zend_reference &#123; zend_refcounted gc; zval val;&#125;; 本质上 zend_reference 只是增加了引用计数的 zval。所有引用变量都会存储一个 zval 指针并且被标记为 IS_REFERENCE。val 和其他的 zval 的行为一样，尤其是它也可以在共享其所存储的复杂变量的指针，比如数组可以在引用变量和值变量之间共享。 我们还是看例子，这次是 PHP7 中的语义。为了简洁明了这里不再单独写出 zval，只展示它们指向的结构体： 12345&lt;?php$a = []; // $a -&gt; zend_array_1(refcount=1, value=[])$b =&amp; $a; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[])$b[] = 1; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1]) 上面的例子中进行引用传递时会创建一个 zend_reference，注意它的引用计数是 2（因为有两个变量在使用这个 PHP 引用）。但是值本身的引用计数是 1（因为 zend_reference 只是有一个指针指向它）。下面看看引用和非引用混合的情况： 123456789101112&lt;?php$a = []; // $a -&gt; zend_array_1(refcount=1, value=[])$b = $a; // $a, $b, -&gt; zend_array_1(refcount=2, value=[])$c = $b // $a, $b, $c -&gt; zend_array_1(refcount=3, value=[])$d =&amp; $c; // $a, $b -&gt; zend_array_1(refcount=3, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) ---^ // 注意所有变量共享同一个 zend_array, 即使有的是 PHP 引用有的不是$d[] = 1; // $a, $b -&gt; zend_array_1(refcount=2, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1]) // 只有在这时进行赋值的时候才会对 zend_array 进行赋值 这里和 PHP5 最大的不同就是所有的变量都可以共享同一个数组，即使有的是 PHP 引用有的不是。只有当其中某一部分被修改的时候才会对数组进行分离。这也意味着使用 count() 时即使给其传递一个很大的引用数组也是安全的，不会再进行复制。不过引用仍然会比普通的数值慢，因为\b存在需要为 zend_reference 结构体分配内存（间接）并且引擎本身处理这一块儿也不快的的原因。 结语总结一下 PHP7 中最重要的改变就是 zval 不再单独从堆上分配内存并且不自己存储引用计数。需要使用 zval 指针的复杂类型（比如字符串、数组和对象）会自己存储引用计数。这样就可以有更少的内存分配操作、更少的间接指针使用以及更少的内存分配。 文章的第二部分我们会讨论复杂类型的问题。","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[12] autoload机制实现","date":"2017-08-12T09:09:59.000Z","path":"2017/08/12/2016-02-12-php-ext-12/","text":"123456789101112131415场景：实现PHP的autoload&lt;?php class myLoader&#123; public static function autoload($className)&#123; $filename = './include/'.$className.'.php'; if(file_exists($filename))&#123; include_once $filename; &#125;else&#123; exit('no file'); &#125; &#125; &#125; spl_autoload_register(array('myLoader', 'autoload')); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** 摘抄自yaf的代码，实现INCLUDE**/int loader_import(char *path, size_t len) &#123; zend_file_handle file_handle; zend_op_array *op_array; char realpath[255]; file_handle.filename = path; file_handle.free_filename = 0; file_handle.type = ZEND_HANDLE_FILENAME; file_handle.opened_path = NULL; file_handle.handle.fp = NULL; op_array = zend_compile_file(&amp;file_handle, ZEND_INCLUDE); if (op_array &amp;&amp; file_handle.handle.stream.handle) &#123; zval dummy; ZVAL_NULL(&amp;dummy); if (!file_handle.opened_path) &#123; file_handle.opened_path = zend_string_init(path, len, 0); &#125; zend_hash_add(&amp;EG(included_files), file_handle.opened_path, &amp;dummy); &#125; zend_destroy_file_handle(&amp;file_handle); if (op_array) &#123; zval result; ZVAL_UNDEF(&amp;result); zend_execute(op_array, &amp;result); destroy_op_array(op_array); efree(op_array); if (!EG(exception)) &#123; zval_ptr_dtor(&amp;result); &#125; return 1; &#125; return 0;&#125;/** * 声明构造函数 * @param * @return */ZEND_METHOD(doua,__construct)&#123; zend_printf(\"__construct\\n\"); &#125;ZEND_METHOD(doua,load)&#123; zend_printf(\"load\\n\"); loader_import(\"/data/work/php-7.0.5/ext/doua/2.php\",strlen(\"/data/work/php-7.0.5/ext/doua/2.php\"));&#125;/** * 加载view * @param * @return */ZEND_METHOD(doua,run)&#123; zend_printf(\"run\\n\"); //loader_import(\"/data/work/php-7.0.5/ext/doua/2.php\",strlen(\"/data/work/php-7.0.5/ext/doua/2.php\")); zval arg;//参数 zval * pthis = getThis();//当前类 array_init(&amp;arg);//初始化数据， Z_ADDREF_P(pthis); add_next_index_zval(&amp;arg, pthis); add_next_index_string(&amp;arg, \"load\"); zend_call_method_with_1_params(NULL, NULL, NULL, \"spl_autoload_register\", NULL, &amp;arg); zval_ptr_dtor(&amp;arg);&#125;const zend_function_entry doua_functions[] = &#123; //注册loader类中的方法 ZEND_ME(doua, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) //ZEND_ME(loader,autoload,NULL,ZEND_ACC_PUBLIC) ZEND_ME(doua,run,NULL,ZEND_ACC_PUBLIC) ZEND_ME(doua,load,NULL,ZEND_ACC_PUBLIC) PHP_FE_END /* Must be the last line in doua_functions[] */&#125;;PHP_MINIT_FUNCTION(doua)&#123; /* If you have INI entries, uncomment these lines REGISTER_INI_ENTRIES(); */ //注册loader类 zend_class_entry ce; INIT_CLASS_ENTRY(ce, \"doua\", doua_functions); doua_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); return SUCCESS;&#125; 123456$n = new doua();$n-&gt;run();$ab = new abc\\ab();echo $ab-&gt;test(\"test\"); 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[11] MVC之自动加载文件","date":"2017-08-11T09:09:59.000Z","path":"2017/08/11/2016-02-11-php-ext-11/","text":"1234567891011121314151617场景：想要用C实现PHP的一个MVC结构的路由解析和加载文件的功能，一共要解决几个问题1.由于MVC要加载多个C文件，所以要修正config.m4，修改config.m4内容第十行左右，去掉dnl,PHP_ARG_WITH(dora, for route support,dnl Make sure that the comment is aligned:[ --with-route Include dora support])在下面追加到以下内容：if test -z \"$PHP_DEBUG\" ; then AC_ARG_ENABLE(debug, [--enable-debug compile with debugging system], [PHP_DEBUG=$enableval],[PHP_DEBUG=no] ) fi 最后一行，加载所需所有C文件，如下： PHP_NEW_EXTENSION(dora, dora.c common/utilts.c loader/loader.c route/route.c controller/controller.c model/model.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1) PHP_ADD_BUILD_DIR([$ext_builddir/common]) PHP_ADD_BUILD_DIR([$ext_builddir/loader]) PHP_ADD_BUILD_DIR([$ext_builddir/route]) PHP_ADD_BUILD_DIR([$ext_builddir/controller]) PHP_ADD_BUILD_DIR([$ext_builddir/model]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include \"utilts.h\"#include \"php_ini.h\"#include \"ext/standard/info.h\"#include \"Zend/zend_list.h\"#include \"Zend/zend_interfaces.h\" //执行PHP文件函数int zend_execute_scripts_ext(char *filepath)&#123; zval retval; zend_file_handle zfd; zfd.type = ZEND_HANDLE_FILENAME; zfd.filename = filepath; zfd.free_filename = 0; zfd.opened_path = NULL; //zend_execute_scripts(int type, zval *retval, int file_count, ...); //FAILURE OR SUCCESS return zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC,&amp;retval,1,&amp;zfd); &#125;//调用类中的方法int call_user_class_method(zval *retval, zend_class_entry *obj_ce, zval *obj, zval func, uint32_t params_count, zval params[])&#123; HashTable *function_table; if(obj) &#123; function_table = &amp;Z_OBJCE_P(obj)-&gt;function_table; &#125;else&#123; function_table = (CG(function_table)); &#125; zend_fcall_info fci; fci.size = sizeof(fci); fci.function_table = function_table; fci.object = obj ? Z_OBJ_P(obj) : NULL;; fci.function_name = func; fci.retval = retval; fci.param_count = params_count; fci.params = params; fci.no_separation = 1; fci.symbol_table = NULL; //FAILURE OR SUCCESS return zend_call_function(&amp;fci, NULL TSRMLS_CC); //函数调用结束。 &#125; 1234567893.修改php_route.h头文件内容在第五十行左右，加入以下内容//定义类extern zend_class_entry *route_ce;//定义loader类中的方法PHP_METHOD(route_ce,__construct);PHP_METHOD(route_ce,run); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751764.修改route.c文件内容/** * 声明构造函数 * @param * @return */ZEND_METHOD(route,__construct)&#123; zval *app_dir; if( zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &amp;app_dir) == FAILURE ) &#123; RETURN_NULL(); &#125; //zend_update_static_property_stringl(zend_class_entry *scope, const char *name, size_t name_length, const char *value, size_t value_length); zend_update_static_property(route_ce, \"app_dir\", sizeof(\"app_dir\")-1, app_dir TSRMLS_CC);&#125;/** * 加载view * @param * @return */ZEND_METHOD(route,run)&#123; zend_string* controller_name = zend_string_init(\"Index\",strlen(\"Index\"),0); zend_string* action_name = zend_string_init(\"Index\",strlen(\"Index\"),0); zval *c_result; zval *a_result; int flag; //设置站点目录 zval *app_dir = zend_read_static_property(Z_OBJCE_P(getThis()), \"app_dir\", sizeof(\"app_dir\")-1, 0 TSRMLS_DC); //获取GET请求参数hashtable zval *get_arr = &amp;PG(http_globals)[TRACK_VARS_GET]; HashTable *ht= HASH_OF(get_arr); //int array_count = zend_hash_num_elements(Z_ARRVAL_P(get_arr)); //获取controller_name zend_string *c_key= zend_string_init(\"controller\", sizeof(\"controller\")-1, 0); if ((c_result = zend_hash_find(ht, c_key)) != NULL) &#123; controller_name = zval_get_string(c_result); &#125;else&#123; zend_error_noreturn(E_CORE_ERROR, \"Couldn't find controller param in url.\"); &#125; //释放key的变量 zend_string_release(c_key); //获取action_name zend_string *a_key= zend_string_init(\"action\", sizeof(\"action\")-1, 0); if ((a_result = zend_hash_find(ht, a_key)) != NULL) &#123; action_name = zval_get_string(a_result); //php_printf(\"%s\\n\", Z_STRVAL_P(a_result)); //php_printf(\"%s\\n\", zval_get_string(a_result)); &#125;else&#123; zend_error_noreturn(E_CORE_ERROR,\"Couldn't find action param in url.\"); &#125; //释放key的变量 zend_string_release(a_key); //拼装controller文件路径 char *path = Z_STRVAL_P(app_dir); char *c_2 = \"controllers/\"; strcat(path,c_2); //zend_string-&gt;char * char *c_3 = ZSTR_VAL(controller_name); strcat(path,c_3); char *c_4 = \".php\"; strcat(path,c_4); //php_printf(\"%s\\n\", c_1); // php_printf(\"%s\\n\", controller_name); // php_printf(\"%s\\n\", action_name); //PHPWRITE(Z_STRVAL_P(app_dir), Z_STRLEN_P(app_dir)); //加载执行controller文件 flag = zend_execute_scripts_ext(c_1); if(flag == FAILURE)&#123; zend_error_noreturn(E_CORE_ERROR,\"Couldn't find file: %s.\",c_1); &#125; //查找controller对应的 //zend_class_entry *zend_lookup_class(zend_string *name); zend_class_entry *controller_ce = zend_lookup_class(controller_name); if(controller_ce == NULL)&#123; zend_error_noreturn(E_CORE_ERROR,\"Couldn't find file: %s.\",c_1); &#125; zval obj; object_init_ex(&amp;obj, controller_ce); zval function_name; ZVAL_STRING(&amp;function_name,ZSTR_VAL(action_name)); flag = call_user_class_method(return_value, controller_ce, &amp;obj, function_name, 0, NULL); if(flag == FAILURE)&#123; zend_error_noreturn(E_CORE_ERROR, \"Couldn't find implementation for method %s%s%s\", controller_ce ? ZSTR_VAL(controller_ce-&gt;name) : \"\", controller_ce ? \"::\" : \"\", function_name); &#125; //RETURN_ZVAL(get_arr, 1, 0);&#125;const zend_function_entry route_functions[] = &#123; //注册route类中的方法 ZEND_ME(route, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) ZEND_ME(route,run,NULL,ZEND_ACC_PUBLIC) PHP_FE_END /* Must be the last line in route_functions[] */&#125;;PHP_MINIT_FUNCTION(route)&#123; //注册route类 zend_class_entry ce; //define INIT_NS_CLASS_ENTRY(class_container, ns, class_name, functions) INIT_NS_CLASS_ENTRY(ce,\"Dora\" ,\"Route\", route_functions); route_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); //声明一个静态数据成员app_dir //zend_declare_property_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value, int access_type); zend_declare_property_string(route_ce, \"app_dir\", strlen(\"app_dir\"), \"\",ZEND_ACC_PUBLIC|ZEND_ACC_STATIC TSRMLS_DC); return SUCCESS;&#125; 12345.编译安装phpize./configure --with-php-config=/usr/bin/php-configmake &amp;&amp; make install 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892906.php7创建类所有到的知识点常见的变量操作宏CG -&gt; Complier Global 编译时信息，包括函数表等(zend_globals_macros.h:32)EG -&gt; Executor Global 执行时信息(zend_globals_macros.h:43)PG -&gt; PHP Core Global 主要存储php.ini中的信息SG -&gt; SAPI Global SAPI信息//===============================================================================PHP7中的zval的类型:/* regular data types */define IS_UNDEF 0define IS_NULL 1define IS_FALSE 2define IS_TRUE 3define IS_LONG 4define IS_DOUBLE 5define IS_STRING 6define IS_ARRAY 7define IS_OBJECT 8define IS_RESOURCE 9define IS_REFERENCE 10define IS_CONSTANT 11define IS_CONSTANT_AST 12define _IS_BOOL 13define IS_CALLABLE 14define IS_INDIRECT 15define IS_PTR 17//===============================================================================PHP7中获取的zval赋值:- ZVAL_STRING(zv, str, 1);+ ZVAL_STRING(zv, str);- ZVAL_STRINGL(zv, str, len, 1);+ ZVAL_STRINGL(zv, str, len);- ZVAL_STRING(zv, str, 0);+ ZVAL_STRING(zv, str);+ efree(str);- ZVAL_STRINGL(zv, str, len, 0);+ ZVAL_STRINGL(zv, str, len);//===============================================================================PHP7中获取的zval的值和长度:define Z_LVAL(zval) (zval).value.lvaldefine Z_LVAL_P(zval_p) Z_LVAL(*(zval_p))define Z_DVAL(zval) (zval).value.dvaldefine Z_DVAL_P(zval_p) Z_DVAL(*(zval_p))define Z_STR(zval) (zval).value.strdefine Z_STR_P(zval_p) Z_STR(*(zval_p))define Z_STRVAL(zval) ZSTR_VAL(Z_STR(zval))define Z_STRVAL_P(zval_p) Z_STRVAL(*(zval_p))define Z_STRLEN(zval) ZSTR_LEN(Z_STR(zval))define Z_STRLEN_P(zval_p) Z_STRLEN(*(zval_p))define Z_STRHASH(zval) ZSTR_HASH(Z_STR(zval))define Z_STRHASH_P(zval_p) Z_STRHASH(*(zval_p))define Z_ARR(zval) (zval).value.arrdefine Z_ARR_P(zval_p) Z_ARR(*(zval_p))define Z_ARRVAL(zval) Z_ARR(zval)define Z_ARRVAL_P(zval_p) Z_ARRVAL(*(zval_p))define Z_OBJ(zval) (zval).value.objdefine Z_OBJ_P(zval_p) Z_OBJ(*(zval_p))define Z_OBJ_HT(zval) Z_OBJ(zval)-&gt;handlersdefine Z_OBJ_HT_P(zval_p) Z_OBJ_HT(*(zval_p))define Z_OBJ_HANDLER(zval, hf) Z_OBJ_HT((zval))-&gt;hfdefine Z_OBJ_HANDLER_P(zv_p, hf) Z_OBJ_HANDLER(*(zv_p), hf)define Z_OBJ_HANDLE(zval) (Z_OBJ((zval)))-&gt;handledefine Z_OBJ_HANDLE_P(zval_p) Z_OBJ_HANDLE(*(zval_p))define Z_OBJCE(zval) (Z_OBJ(zval)-&gt;ce)define Z_OBJCE_P(zval_p) Z_OBJCE(*(zval_p))define Z_OBJPROP(zval) Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval))define Z_OBJPROP_P(zval_p) Z_OBJPROP(*(zval_p))define Z_OBJDEBUG(zval,tmp) (Z_OBJ_HANDLER((zval),get_debug_info)?Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;tmp):(tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL))define Z_OBJDEBUG_P(zval_p,tmp) Z_OBJDEBUG(*(zval_p), tmp)define Z_RES(zval) (zval).value.resdefine Z_RES_P(zval_p) Z_RES(*zval_p)define Z_RES_HANDLE(zval) Z_RES(zval)-&gt;handledefine Z_RES_HANDLE_P(zval_p) Z_RES_HANDLE(*zval_p)define Z_RES_TYPE(zval) Z_RES(zval)-&gt;typedefine Z_RES_TYPE_P(zval_p) Z_RES_TYPE(*zval_p)define Z_RES_VAL(zval) Z_RES(zval)-&gt;ptrdefine Z_RES_VAL_P(zval_p) Z_RES_VAL(*zval_p)define Z_REF(zval) (zval).value.refdefine Z_REF_P(zval_p) Z_REF(*(zval_p))define Z_REFVAL(zval) &amp;Z_REF(zval)-&gt;valdefine Z_REFVAL_P(zval_p) Z_REFVAL(*(zval_p))define Z_AST(zval) (zval).value.astdefine Z_AST_P(zval_p) Z_AST(*(zval_p))define Z_ASTVAL(zval) (zval).value.ast-&gt;astdefine Z_ASTVAL_P(zval_p) Z_ASTVAL(*(zval_p))define Z_INDIRECT(zval) (zval).value.zvdefine Z_INDIRECT_P(zval_p) Z_INDIRECT(*(zval_p))define Z_CE(zval) (zval).value.cedefine Z_CE_P(zval_p) Z_CE(*(zval_p))define Z_FUNC(zval) (zval).value.funcdefine Z_FUNC_P(zval_p) Z_FUNC(*(zval_p))define Z_PTR(zval) (zval).value.ptrdefine Z_PTR_P(zval_p) Z_PTR(*(zval_p))//===============================================================================php7 用来判断类型和取值 void display_value(zval zv,zval *zv_p,zval **zv_pp)&#123; if( Z_TYPE(zv) == IS_NULL ) &#123; php_printf(\"类型是 IS_NULL!\\n\"); &#125; if( Z_TYPE_P(zv_p) == IS_LONG ) &#123; php_printf(\"类型是 IS_LONG，值是：%ld\" , Z_LVAL_P(zv_p)); &#125; if(Z_TYPE_PP(zv_pp) == IS_DOUBLE ) &#123; php_printf(\"类型是 IS_DOUBLE,值是：%f\" , Z_DVAL_PP(zv_pp) ); &#125;&#125; //================================================================================PHP7中的定义返回值的宏 Zend/zend_API.hdefine RETVAL_BOOL(b) ZVAL_BOOL(return_value, b)define RETVAL_NULL() ZVAL_NULL(return_value)define RETVAL_LONG(l) ZVAL_LONG(return_value, l)define RETVAL_DOUBLE(d) ZVAL_DOUBLE(return_value, d)define RETVAL_STR(s) ZVAL_STR(return_value, s)define RETVAL_INTERNED_STR(s) ZVAL_INTERNED_STR(return_value, s)define RETVAL_NEW_STR(s) ZVAL_NEW_STR(return_value, s)define RETVAL_STR_COPY(s) ZVAL_STR_COPY(return_value, s)define RETVAL_STRING(s) ZVAL_STRING(return_value, s)define RETVAL_STRINGL(s, l) ZVAL_STRINGL(return_value, s, l)define RETVAL_EMPTY_STRING() ZVAL_EMPTY_STRING(return_value)define RETVAL_RES(r) ZVAL_RES(return_value, r)define RETVAL_ARR(r) ZVAL_ARR(return_value, r)define RETVAL_OBJ(r) ZVAL_OBJ(return_value, r)define RETVAL_ZVAL(zv, copy, dtor) ZVAL_ZVAL(return_value, zv, copy, dtor)define RETVAL_FALSE ZVAL_FALSE(return_value)define RETVAL_TRUE ZVAL_TRUE(return_value)define RETURN_BOOL(b) &#123; RETVAL_BOOL(b); return; &#125;define RETURN_NULL() &#123; RETVAL_NULL(); return;&#125;define RETURN_LONG(l) &#123; RETVAL_LONG(l); return; &#125;define RETURN_DOUBLE(d) &#123; RETVAL_DOUBLE(d); return; &#125;define RETURN_STR(s) &#123; RETVAL_STR(s); return; &#125;define RETURN_INTERNED_STR(s) &#123; RETVAL_INTERNED_STR(s); return; &#125;define RETURN_NEW_STR(s) &#123; RETVAL_NEW_STR(s); return; &#125;define RETURN_STR_COPY(s) &#123; RETVAL_STR_COPY(s); return; &#125;define RETURN_STRING(s) &#123; RETVAL_STRING(s); return; &#125;define RETURN_STRINGL(s, l) &#123; RETVAL_STRINGL(s, l); return; &#125;define RETURN_EMPTY_STRING() &#123; RETVAL_EMPTY_STRING(); return; &#125;define RETURN_RES(r) &#123; RETVAL_RES(r); return; &#125;define RETURN_ARR(r) &#123; RETVAL_ARR(r); return; &#125;define RETURN_OBJ(r) &#123; RETVAL_OBJ(r); return; &#125;define RETURN_ZVAL(zv, copy, dtor) &#123; RETVAL_ZVAL(zv, copy, dtor); return; &#125;define RETURN_FALSE &#123; RETVAL_FALSE; return; &#125;define RETURN_TRUE &#123; RETVAL_TRUE; return; &#125;array_init(return_value);//初始化return_value成数组，此操作完后就可以返回一个空的数组object_init(return_value);//初始化return_value成Object，此操作完成后返回一个空的对像//===============================================================================grep \"define ZEND_ACC\" Zend/*.h内核中提供了定义类以方法的修饰词 Zend/zend_compile.h声明定义define ZEND_ACC_STATIC 0x01define ZEND_ACC_ABSTRACT 0x02define ZEND_ACC_FINAL 0x04define ZEND_ACC_IMPLEMENTED_ABSTRACT 0x08define ZEND_ACC_IMPLICIT_ABSTRACT_CLASS 0x10define ZEND_ACC_EXPLICIT_ABSTRACT_CLASS 0x20define ZEND_ACC_INTERFACE 0x40define ZEND_ACC_TRAIT 0x80define ZEND_ACC_ANON_CLASS 0x100define ZEND_ACC_ANON_BOUND 0x200define ZEND_ACC_PUBLIC 0x100define ZEND_ACC_PROTECTED 0x200define ZEND_ACC_PRIVATE 0x400define ZEND_ACC_PPP_MASK (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)define ZEND_ACC_CHANGED 0x800define ZEND_ACC_IMPLICIT_PUBLIC 0x1000define ZEND_ACC_CTOR 0x2000define ZEND_ACC_DTOR 0x4000define ZEND_ACC_CLONE 0x8000//===============================================================================1. grep ZEND_ACC Zend/*.h内核中提供了定义类属性的宏 Zend/zend_API.h声明定义ZEND_API int zend_declare_property_ex(zend_class_entry *ce, zend_string *name, zval *property, int access_type, zend_string *doc_comment);ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, size_t name_length, zval *property, int access_type);ZEND_API int zend_declare_property_null(zend_class_entry *ce, const char *name, size_t name_length, int access_type);ZEND_API int zend_declare_property_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_long value, int access_type);ZEND_API int zend_declare_property_long(zend_class_entry *ce, const char *name, size_t name_length, zend_long value, int access_type);ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, size_t name_length, double value, int access_type);ZEND_API int zend_declare_property_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value, int access_type);ZEND_API int zend_declare_property_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_len, int access_type);更新类中的数据成员 Zend/zend_API.h声明定义ZEND_API void zend_update_property_ex(zend_class_entry *scope, zval *object, zend_string *name, zval *value);ZEND_API void zend_update_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zval *value);ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, size_t name_length);ZEND_API void zend_update_property_bool(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_long value);ZEND_API void zend_update_property_long(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_long value);ZEND_API void zend_update_property_double(zend_class_entry *scope, zval *object, const char *name, size_t name_length, double value);ZEND_API void zend_update_property_str(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_string *value);ZEND_API void zend_update_property_string(zend_class_entry *scope, zval *object, const char *name, size_t name_length, const char *value);ZEND_API void zend_update_property_stringl(zend_class_entry *scope, zval *object, const char *name, size_t name_length, const char *value, size_t value_length);grep \"zend_read_\" ../../Zend/*.h 读取类中的数据成员 在Zend/zend_API.h声明定义ZEND_API zval *zend_read_property(zend_class_entry *scope, zval *object, const char *name, size_t name_length, zend_bool silent, zval *rv);//===============================================================================2. grep \"zend_declare_class_constant\" Zend/*.h创建类中的常量的方法在Zend/zend_API.h声明定义ZEND_API int zend_declare_class_constant(zend_class_entry *ce, const char *name, size_t name_length, zval *value);ZEND_API int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length);ZEND_API int zend_declare_class_constant_long(zend_class_entry *ce, const char *name, size_t name_length, zend_long value);ZEND_API int zend_declare_class_constant_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_bool value);ZEND_API int zend_declare_class_constant_double(zend_class_entry *ce, const char *name, size_t name_length, double value);ZEND_API int zend_declare_class_constant_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_length);ZEND_API int zend_declare_class_constant_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value);更新类中的常量数据成员 Zend/zend_API.h声明定义ZEND_API int zend_update_class_constants(zend_class_entry *class_type);//=================================================================================3. grep \"zend_update_static_\" ../../Zend/*.h 更新类中的静态数据成员 在Zend/zend_API.ZEND_API int zend_update_static_property(zend_class_entry *scope, const char *name, size_t name_length, zval *value);ZEND_API int zend_update_static_property_null(zend_class_entry *scope, const char *name, size_t name_length);ZEND_API int zend_update_static_property_bool(zend_class_entry *scope, const char *name, size_t name_length, zend_long value);ZEND_API int zend_update_static_property_long(zend_class_entry *scope, const char *name, size_t name_length, zend_long value);ZEND_API int zend_update_static_property_double(zend_class_entry *scope, const char *name, size_t name_length, double value);ZEND_API int zend_update_static_property_string(zend_class_entry *scope, const char *name, size_t name_length, const char *value);ZEND_API int zend_update_static_property_stringl(zend_class_entry *scope, const char *name, size_t name_length, const char *value, size_t value_length);grep \"zend_read_\" ../../Zend/*.h 读取类中的数据成员 在Zend/zend_API.h声明定义ZEND_API zval *zend_read_static_property(zend_class_entry *scope, const char *name, size_t name_length, zend_bool silent); 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[10] 怎么样创建类详细","date":"2017-08-10T09:09:59.000Z","path":"2017/08/10/2016-02-10-php-ext-10/","text":"123场景：php7扩展开发怎么样创建类1.创建扩展进入$&#123;php-src&#125;/ext目录，执行./ext_skel--extname=route，这时目录下会出现一个route的目录,cd ./route 123456782.修改config.m4内容第十行左右，去掉dnlPHP_ARG_WITH(route, for route support,dnl Make sure that the comment is aligned:[ --with-route Include route support])在下面追加到以下内容：if test -z \"$PHP_DEBUG\" ; then AC_ARG_ENABLE(debug, [--enable-debug compile with debugging system], [PHP_DEBUG=$enableval],[PHP_DEBUG=no] ) fi 1234567893.修改php_route.h头文件内容在第五十行左右，加入以下内容//定义类extern zend_class_entry *route_ce;//定义loader类中的方法PHP_METHOD(route_ce,__construct);PHP_METHOD(route_ce,run); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475764.修改route.c文件内容/* True global resources - no need for thread safety here */在这行注释下添加变量声明zend_class_entry *route_ce;找到route_functions，去掉confirm_route_compiled的内容，改为如下const zend_function_entry route_functions[] = &#123; //这里去掉了测试的方法，记得去掉上面的函数实现。处女座有洁癖。 //注册route类中的方法 ZEND_ME(route, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) ZEND_ME(route,run,NULL,ZEND_ACC_PUBLIC) PHP_FE_END /* Must be the last line in route_functions[] */&#125;;注：找到PHP_MINIT_FUNCTION方法，移到route_functions下面来PHP_MINIT_FUNCTION(route)&#123; //注册route类 zend_class_entry ce; //define INIT_NS_CLASS_ENTRY(class_container, ns, class_name, functions) INIT_NS_CLASS_ENTRY(ce,\"Dora\" ,\"Route\", route_functions); route_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); return SUCCESS;&#125;/* Every user-visible function in PHP should document itself in the source */在这行注释下添加函数/** * 声明构造函数 * @param * @return */ZEND_METHOD(route,__construct)&#123; zend_printf(\"__construct\\n\");&#125;/** * 加载run * @param * @return */ZEND_METHOD(route,run)&#123; zend_printf(\"route_run\\n\");&#125;//加载模块zend_module_entry route_module_entry = &#123; STANDARD_MODULE_HEADER, \"route\", route_functions, PHP_MINIT(route), PHP_MSHUTDOWN(route), PHP_RINIT(route), PHP_RSHUTDOWN(route), PHP_MINFO(route), PHP_ROUTE_VERSION, STANDARD_MODULE_PROPERTIES&#125;; 12345.编译安装phpize./configure --with-php-config=/usr/bin/php-configmake &amp;&amp; make install 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441456.php7创建类所有到的知识点1.zend_class_entry是内核中定义的一个类的结构体，是内核实现PHP中类与对象的一个结构类型，起到类模板的作用。声明在Zend/zend.h中struct _zend_class_entry &#123; char type; zend_string *name; struct _zend_class_entry *parent; //指向父类的指针 int refcount; uint32_t ce_flags; int default_properties_count;//默认数据成员个数 int default_static_members_count;//默认类中静态成员个数 zval *default_properties_table;//默认数据成员变量 zval *default_static_members_table;//默认类中静态数据成员变量 zval *static_members_table;//类中静态成员 HashTable function_table; //函数方法表 HashTable properties_info;//数据成员表 HashTable constants_table;//类数据常量 //php中的构造函数、析构函数和魔法函数 union _zend_function *constructor; union _zend_function *destructor; union _zend_function *clone; union _zend_function *__get; union _zend_function *__set; union _zend_function *__unset; union _zend_function *__isset; union _zend_function *__call; union _zend_function *__callstatic; union _zend_function *__tostring; union _zend_function *__debugInfo; union _zend_function *serialize_func; union _zend_function *unserialize_func; zend_class_iterator_funcs iterator_funcs; /* 类句柄 */ zend_object* (*create_object)(zend_class_entry *class_type); zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref); /* 类声明的接口 */ int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type); /* a class implements this interface */ union _zend_function *(*get_static_method)(zend_class_entry *ce, zend_string* method); /* 序列化回调函数指针 */ int (*serialize)(zval *object, unsigned char **buffer, size_t *buf_len, zend_serialize_data *data); int (*unserialize)(zval *object, zend_class_entry *ce, const unsigned char *buf, size_t buf_len, zend_unserialize_data *data); uint32_t num_interfaces; // 类实现的接口数 zend_class_entry **interfaces;//类实现的接口变量 uint32_t num_traits; zend_class_entry **traits; zend_trait_alias **trait_aliases; zend_trait_precedence **trait_precedences; union &#123; struct &#123; zend_string *filename; uint32_t line_start; uint32_t line_end; zend_string *doc_comment; &#125; user; struct &#123; const struct _zend_function_entry *builtin_functions; struct _zend_module_entry *module; &#125; internal; &#125; info;&#125;;2.zend_function_entry是内核中定义的一个函数的结构体，所有类的方法的声明在zend_function_entry中注册，声明在Zend/zend_API.h中。typedef struct _zend_function_entry &#123; const char *fname; void (*handler)(INTERNAL_FUNCTION_PARAMETERS);//函数句柄 const struct _zend_internal_arg_info *arg_info;//函数所需参数 uint32_t num_args;//参数个数 uint32_t flags;&#125; zend_function_entry;声明在Zend/zend_API.h中define ZEND_ME(classname, name, arg_info, flags) ZEND_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)define ZEND_FENTRY(zend_name, name, arg_info, flags) &#123; #zend_name, name, arg_info, (uint32_t) (sizeof(arg_info)/sizeof(struct _zend_internal_arg_info)-1), flags &#125;,define PHP_FE_END ZEND_FE_ENDdefine ZEND_FE_END &#123; NULL, NULL, NULL, 0, 0 &#125;3.zend_module_entry是内核中定义的一个扩展模块的结构体，注册扩展模块到PHP运行过程中，声明在Zend/zend_modules.h中。struct _zend_module_entry &#123; unsigned short size; unsigned int zend_api; unsigned char zend_debug; unsigned char zts; const struct _zend_ini_entry *ini_entry;//指向php.ini的指针 const struct _zend_module_dep *deps; //扩展依赖，deps就是用来注册依赖、冲突模块的 const char *name; //扩展的名称 const struct _zend_function_entry *functions;//指向zend_functions_entry指针 int (*module_startup_func)(INIT_FUNC_ARGS);//模块初始化时被调用的函数指针 int (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS);//模块被关闭时调用的函数指针 int (*request_startup_func)(INIT_FUNC_ARGS);//每处理一次请求前调用此函数 int (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS);//每处理一次请求前后调用此函数 void (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS); //phpinfo时打印出的关于此扩展的信息 const char *version;//扩展的版本号 size_t globals_size;#ifdef ZTS ts_rsrc_id* globals_id_ptr;#else void* globals_ptr;#endif void (*globals_ctor)(void *global); void (*globals_dtor)(void *global); int (*post_deactivate_func)(void); int module_started; unsigned char type; void *handle; int module_number; const char *build_id;&#125;;struct _zend_module_dep &#123; const char *name; /* module name */ const char *rel; /* version relationship: NULL (exists), lt|le|eq|ge|gt (to given version) */ const char *version; /* version */ unsigned char type; /* dependency type */&#125;;如果有依赖，在php扩展中，需要这个写好依赖。或者php.ini中的扩展按从上到下的顺序加载你也可以先写pdo后面追加你的扩展模块名。static const zend_module_dep demo_deps[] = &#123; ZEND_MOD_REQUIRED(\"pdo\") ZEND_MOD_END&#125;; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[9] zend_call_method和zend_call_function","date":"2017-08-09T09:09:59.000Z","path":"2017/08/09/2016-02-09-php-ext-9/","text":"123场景：我们想要在php7扩展中调用用户自定的类中的方法，而且方法有多个参数，找到以下方法，没有看到可以超过两个参数的方法。所以一直向下查找，发现zend_call_method调用的zend_call_function，但是并非只能传两个参数。一直追下去。这样我们用zend_call_function来调用多个参数，实现我们要的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197函数原型：在 Zend/zend_interfaces.下：#define zend_call_method_with_0_params(obj, obj_ce, fn_proxy, function_name, retval) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 0, NULL, NULL)#define zend_call_method_with_1_params(obj, obj_ce, fn_proxy, function_name, retval, arg1) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 1, arg1, NULL)#define zend_call_method_with_2_params(obj, obj_ce, fn_proxy, function_name, retval, arg1, arg2) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 2, arg1, arg2)上面三个调用下面的zend_call_method：ZEND_API zval* zend_call_method(zval *object, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval_ptr, int param_count, zval* arg1, zval* arg2)&#123; int result; zend_fcall_info fci; zval retval; HashTable *function_table; zval params[2]; if (param_count &gt; 0) &#123; ZVAL_COPY_VALUE(&amp;params[0], arg1); &#125; if (param_count &gt; 1) &#123; ZVAL_COPY_VALUE(&amp;params[1], arg2); &#125; //看这里.原来可以传多个参数，只是这里做了限制 //看这里.原来可以传多个参数，只是这里做了限制 //看这里.原来可以传多个参数，只是这里做了限制 fci.size = sizeof(fci); fci.object = (object &amp;&amp; Z_TYPE_P(object) == IS_OBJECT) ? Z_OBJ_P(object) : NULL; ZVAL_STRINGL(&amp;fci.function_name, function_name, function_name_len); fci.retval = retval_ptr ? retval_ptr : &amp;retval; fci.param_count = param_count; fci.params = params; fci.no_separation = 1; fci.symbol_table = NULL; if (!fn_proxy &amp;&amp; !obj_ce) &#123; fci.function_table = !object ? EG(function_table) : NULL; //看这里.原来调用的是zend_call_function //看这里.原来调用的是zend_call_function //看这里.原来调用的是zend_call_function result = zend_call_function(&amp;fci, NULL); zval_ptr_dtor(&amp;fci.function_name); &#125; else &#123; zend_fcall_info_cache fcic; fcic.initialized = 1; if (!obj_ce) &#123; obj_ce = object ? Z_OBJCE_P(object) : NULL; &#125; if (obj_ce) &#123; function_table = &amp;obj_ce-&gt;function_table; &#125; else &#123; function_table = EG(function_table); &#125; if (!fn_proxy || !*fn_proxy) &#123; if ((fcic.function_handler = zend_hash_find_ptr(function_table, Z_STR(fci.function_name))) == NULL) &#123; /* error at c-level */ zend_error_noreturn(E_CORE_ERROR, \"Couldn't find implementation for method %s%s%s\", obj_ce ? ZSTR_VAL(obj_ce-&gt;name) : \"\", obj_ce ? \"::\" : \"\", function_name); &#125; if (fn_proxy) &#123; *fn_proxy = fcic.function_handler; &#125; &#125; else &#123; fcic.function_handler = *fn_proxy; &#125; fcic.calling_scope = obj_ce; if (object) &#123; fcic.called_scope = Z_OBJCE_P(object); &#125; else &#123; zend_class_entry *called_scope = zend_get_called_scope(EG(current_execute_data)); if (obj_ce &amp;&amp; (!called_scope || !instanceof_function(called_scope, obj_ce))) &#123; fcic.called_scope = obj_ce; &#125; else &#123; fcic.called_scope = called_scope; &#125; &#125; fcic.object = object ? Z_OBJ_P(object) : NULL; //看这里.原来调用的是zend_call_function //看这里.原来调用的是zend_call_function //看这里.原来调用的是zend_call_function result = zend_call_function(&amp;fci, &amp;fcic); zval_ptr_dtor(&amp;fci.function_name); &#125; if (result == FAILURE) &#123; /* error at c-level */ if (!obj_ce) &#123; obj_ce = object ? Z_OBJCE_P(object) : NULL; &#125; if (!EG(exception)) &#123; zend_error_noreturn(E_CORE_ERROR, \"Couldn't execute method %s%s%s\", obj_ce ? ZSTR_VAL(obj_ce-&gt;name) : \"\", obj_ce ? \"::\" : \"\", function_name); &#125; &#125; /* copy arguments back, they might be changed by references */ if (param_count &gt; 0 &amp;&amp; Z_ISREF(params[0]) &amp;&amp; !Z_ISREF_P(arg1)) &#123; ZVAL_COPY_VALUE(arg1, &amp;params[0]); &#125; if (param_count &gt; 1 &amp;&amp; Z_ISREF(params[1]) &amp;&amp; !Z_ISREF_P(arg2)) &#123; ZVAL_COPY_VALUE(arg2, &amp;params[1]); &#125; if (!retval_ptr) &#123; zval_ptr_dtor(&amp;retval); return NULL; &#125; return retval_ptr;&#125;我们可以看到zend_call_method调用zend_call_function,函数体定义在Zend/zend_API.h下：ZEND_API int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache);我们可以看到要想使用zend_call_function 必须要了解zend_fcall_info结构体。PHP7 中typedef struct _zend_fcall_info &#123; size_t size; HashTable *function_table; zval function_name; zend_array *symbol_table; zval *retval; zval *params; zend_object *object; zend_bool no_separation; uint32_t param_count;&#125; zend_fcall_info;由于网上流传的代码都是PHP5的代码，我们也就再贴一下PHP5的代码，到改造代码时，可以有个借鉴。PHP5 中typedef struct _zend_fcall_info &#123; size_t size; HashTable *function_table; zval *function_name; HashTable *symbol_table; zval **retval_ptr_ptr; zend_uint param_count; zval ***params; zval *object_ptr; zend_bool no_separation;&#125; zend_fcall_info;其中有变化的参数：zval *function_name; -&gt; zval function_name;zval **retval_ptr_ptr; -&gt; zval *retval;zval *object_ptr; -&gt; zend_object *object;zval ***params; -&gt; zval *params;在PHP7的扩展使用PHP5的代码make时，会出现如下错误：error: incompatible types when assigning to type ‘struct zval *’ from type ‘zval’error: ‘zend_fcall_info’ has no member named ‘object’error: ‘zend_fcall_info’ has no member named ‘retval’我们搜一下php源码中zend_call_function中的使用情况，我们会发现自动加载中的代码如下：static inline void spl_instantiate_arg_n(zend_class_entry *pce, zval *retval, int argc, zval *argv)&#123; zend_function *func = pce-&gt;constructor; zend_fcall_info fci; zend_fcall_info_cache fcc; zval dummy; spl_instantiate(pce, retval); fci.size = sizeof(zend_fcall_info); fci.function_table = &amp;pce-&gt;function_table; ZVAL_STR(&amp;fci.function_name, func-&gt;common.function_name); fci.object = Z_OBJ_P(retval); fci.symbol_table = NULL; fci.retval = &amp;dummy; fci.param_count = argc; fci.params = argv; fci.no_separation = 1; fcc.initialized = 1; fcc.function_handler = func; fcc.calling_scope = EG(scope); fcc.called_scope = pce; fcc.object = Z_OBJ_P(retval); zend_call_function(&amp;fci, &amp;fcc);&#125; OK,我们写一个可以调用用户定义类的方法的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int class_call_user_method(zval *retval, zend_class_entry *obj_ce, zval *obj, zval func, uint32_t params_count, zval params[])&#123; HashTable *function_table; if(obj) &#123; function_table = &amp;Z_OBJCE_P(obj)-&gt;function_table; &#125;else&#123; function_table = (CG(function_table)); &#125; // 对象初始化内容，不能放在这里 // if(!obj_ce)&#123; // object_init(&amp;obj); // &#125; // else&#123; // object_init_ex(&amp;obj, obj_ce); // &#125; zend_fcall_info fci; fci.size = sizeof(fci); fci.function_table = function_table; fci.object = obj ? Z_OBJ_P(obj) : NULL;; fci.function_name = func; fci.retval = retval; fci.param_count = params_count; fci.params = params; fci.no_separation = 1; fci.symbol_table = NULL; /**/ int result; result = zend_call_function(&amp;fci, NULL TSRMLS_CC); //函数调用结束。 if (result == FAILURE) &#123; zend_printf(\"error\"); &#125; /**/ zend_printf(\"Success.\\n\"); &#125; 使用方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ZEND_METHOD(udf,get)&#123; //call __construct zval retval; zval obj; object_init_ex(&amp;obj, adf_ce); zval function_name; ZVAL_STRING(&amp;function_name,\"__construct\"); //int class_call_user_method(zval *retval, zend_class_entry *obj_ce, //zval *obj, zval func, uint32_t params_count, zval params[]) class_call_user_method(&amp;retval, adf_ce, &amp;obj, function_name, 0,NULL); //call set zval retval2; zval obj2; object_init_ex(&amp;obj2, adf_ce); zval function_name2; ZVAL_STRING(&amp;function_name2,\"set\"); zval params[2]; ZVAL_STRING(&amp;params[0],\"root\"); ZVAL_STRING(&amp;params[1],\"tyyy\"); class_call_user_method(&amp;retval2, adf_ce, &amp;obj2, function_name2, 2, params); //call get zval retval3; zval obj3; object_init_ex(&amp;obj3, adf_ce); zval function_name3; ZVAL_STRING(&amp;function_name3,\"get\"); class_call_user_method(&amp;retval3, adf_ce, &amp;obj3, function_name3, 0, NULL); &#125; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[8]类方法之间的调用","date":"2017-08-08T09:09:59.000Z","path":"2017/08/08/2016-02-08-php-ext-8/","text":"123在一个扩展模块里，类之间方法的调用，上面第7个有例子简介，就不多说了首先我们先创建play扩展模块，再创建adf扩展模块，最后创建udf扩展模块，我们要做到的是php -m中显示加载了play,我们可以调用adf类和udf类。 1234567891011121314151617第一步： 在adf和udf类中各实现set get方法，然后初始化minit中的内容 运行成功后，将adf.c php_adf.h和udf.c php_udf.h拷入play文件中 第二步修改play文件夹中的config.m4：if test -z \"$PHP_DEBUG\" ; then PHP_NEW_EXTENSION(play, play.c udf.c adf.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1) 在play.c的MINIT函数中加上 ZEND_MODULE_STARTUP_N(udf) (INIT_FUNC_ARGS_PASSTHRU); ZEND_MODULE_STARTUP_N(adf) (INIT_FUNC_ARGS_PASSTHRU); 第三步执行phpize ./configure --with-php-config=/usr/bin/php-config --enable-debugmake &amp;&amp; make install 123456789101112131415161718在adf.c中加一个静态方法const zend_function_entry adf_functions[] = &#123; PHP_ME(adf, __construct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) PHP_ME(adf,set,global_setkey_arg,ZEND_ACC_PUBLIC) PHP_ME(adf,get,NULL,ZEND_ACC_PUBLIC) PHP_ME(adf,calladf,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC) PHP_FE_END /* Must be the last line in adf_functions[] */&#125;;加上这个一行 PHP_ME(adf,calladf,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC) 再实现一个空方法ZEND_METHOD(adf,calladf)&#123;&#125; 1234567891011121314在udf.c 中定义了一个get方法，它用来调用adf.c中的calladf的静态方法ZEND_METHOD(udf,get)&#123; //创建类实例 zval *object_name; //函数名i zval function_name; ZVAL_STRING(&amp;function_name, \"calladf\"); //zend_call_method_with_0_params(object_name,adf_ce,NULL,\"calladf\",return_value); zend_call_method(object_name,adf_ce,NULL,\"calladf\",sizeof(\"calladf\")-1,return_value,0,NULL,NULL); &#125; 1234567891011121314在 Zend/zend_interfaces 下函数原型：#define zend_call_method_with_0_params(obj, obj_ce, fn_proxy, function_name, retval) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 0, NULL, NULL)#define zend_call_method_with_1_params(obj, obj_ce, fn_proxy, function_name, retval, arg1) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 1, arg1, NULL)#define zend_call_method_with_2_params(obj, obj_ce, fn_proxy, function_name, retval, arg1, arg2) \\ zend_call_method(obj, obj_ce, fn_proxy, function_name, sizeof(function_name)-1, retval, 2, arg1, arg2)上面三个调用下面的：ZEND_API zval* zend_call_method(zval *object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, const char *function_name, size_t function_name_len, zval *retval, int param_count, zval* arg1, zval* arg2); 在Zend/zend_API.h下,上面调用zend_call_function： ZEND_API int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache); typedef struct _zend_fcall_info { size_t size; HashTable *function_table; zval function_name; zend_array *symbol_table; zval *retval; zval *params; zend_object *object; zend_bool no_separation; uint32_t param_count; } zend_fcall_info; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[7]含有两个类的扩展模块","date":"2017-08-07T09:09:59.000Z","path":"2017/08/07/2016-02-07-php-ext-7/","text":"12345在我们写扩展时，就像YAF不会是用一个类文件来完成一个扩展功能，所以我们要在一个扩展模块里调起几个类的实例，同类之间的方法，可以相互调用，不同类之间的实例，应该也可以调用，下面我们就用一个例子来说明。首先我们先创建play扩展模块，再创建adf扩展模块，最后创建udf扩展模块，我们要做到的是php -m中显示加载了play,我们可以调用adf类和udf类。 1234567891011121314151617第一步： 在adf和udf类中各实现set get方法，然后初始化minit中的内容 运行成功后，将adf.c php_adf.h和udf.c php_udf.h拷入play文件中 第二步修改play文件夹中的config.m4：if test -z \"$PHP_DEBUG\" ; then PHP_NEW_EXTENSION(play, play.c udf.c adf.c, $ext_shared,, -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1) 在play.c的MINIT函数中加上 ZEND_MODULE_STARTUP_N(udf) (INIT_FUNC_ARGS_PASSTHRU); ZEND_MODULE_STARTUP_N(adf) (INIT_FUNC_ARGS_PASSTHRU); 第三步执行phpize ./configure --with-php-config=/usr/bin/php-config --enable-debugmake &amp;&amp; make install 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687adf.c zend_class_entry *adf_ce;//新增定义ZEND_BEGIN_ARG_INFO_EX(global_setkey_arg, 0, 0, 2) ZEND_ARG_INFO(0, key1) ZEND_ARG_INFO(0, key2)ZEND_END_ARG_INFO()ZEND_METHOD(adf,__construct)&#123; RETURN_NULL();&#125;ZEND_METHOD(adf,set)&#123; zval *param1; zval *param2; array_init(param2); //int zend_parse_parameters ( int num_args TSRMLS_DC, char* type_spec, ... ) if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|z\",&amp;param1,&amp;param2) == FAILURE) &#123; RETURN_FALSE; &#125; zend_update_property(adf_ce, getThis(), \"param1\", sizeof(\"param1\")-1, param1 TSRMLS_CC); zend_update_property(adf_ce, getThis(), \"param2\", sizeof(\"param2\")-1, param2 TSRMLS_CC); RETURN_NULL();&#125;ZEND_METHOD(adf,get)&#123; array_init(return_value); zval *get1; zval *get2; zval param1; //php &gt;=7.0 zval param2; //php &gt;=7.0 get1 = zend_read_property(adf_ce, getThis(), \"param1\", sizeof(\"param1\")-1, 0, &amp;param1 TSRMLS_DC); get2 = zend_read_property(adf_ce, getThis(), \"param2\", sizeof(\"param2\")-1, 0, &amp;param2 TSRMLS_DC); add_next_index_string(return_value,Z_STRVAL_P(get1)); add_next_index_string(return_value,Z_STRVAL_P(get2)); //add_assoc_string(return_value, \"param1\", ZEND_STRL(\"test1\")); //add_assoc_string(return_value, \"param2\", ZEND_STRL(\"test2\")); RETURN_ZVAL(return_value, 1, 0);&#125;const zend_function_entry adf_functions[] = &#123; PHP_ME(adf, __construct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) PHP_ME(adf,set,global_setkey_arg,ZEND_ACC_PUBLIC) PHP_ME(adf,get,NULL,ZEND_ACC_PUBLIC) PHP_ME(adf,calladf,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_STATIC) PHP_FE_END /* Must be the last line in adf_functions[] */&#125;;PHP_MINIT_FUNCTION(adf)&#123; /* If you have INI entries, uncomment these lines REGISTER_INI_ENTRIES(); */ zend_class_entry ce; INIT_CLASS_ENTRY(ce, \"adf\", adf_functions); adf_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); return SUCCESS;&#125; 123456789101112play.c中代码：PHP_MINIT_FUNCTION(play)&#123; /* If you have INI entries, uncomment these lines REGISTER_INI_ENTRIES(); */ ZEND_MODULE_STARTUP_N(udf) (INIT_FUNC_ARGS_PASSTHRU); ZEND_MODULE_STARTUP_N(adf) (INIT_FUNC_ARGS_PASSTHRU); return SUCCESS;&#125; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[6] 调试Segmentation fault","date":"2017-08-06T09:09:59.000Z","path":"2017/08/06/2016-02-06-php-ext-6/","text":"12345678910111213141516171819202122232425262728293031323334353637383940411.编译安装php-7.0.5，编译时，加上--enable-debug --enable-phpdbgwget http://cn2.php.net/distributions/php-7.0.5.tar.gztar zxvf php-7.0.5.tar.gzcd php-7.0.5./configure --prefix=/usr/local/php7.0.5 --enable-debug --enable-cli --enable-fpm --enable-pcntl --with-openssl --enable-mysqlnd --enable-phpdbg --enable-embedmake &amp;&amp; make install2.php7扩展调用时，出现Segmentation fault2.1ulimit -c unlimited再执行一次php脚本，出现 core.xxxx，OK就先到这里gdb php -c core.xxxx2.2修改扩展模块中的config.m4在其中加入：if test -z \"$PHP_DEBUG\" ; then AC_ARG_ENABLE(debug, [--enable-debug compile with debugging system], [PHP_DEBUG=$enableval],[PHP_DEBUG=no] )fi2.3 重新编译扩展源码phpize./configure --with-php-config=/usr/bin/php-config --enable-debugmake &amp;&amp; make install2.4 确认断点函数nm modules/xxx.so 会列出所有的函数如果自己写的一个Demo类中的get方法出现问题 一般这个函数名为zim_demo_get或者nm modules/xxx.so|grep xxx 找出你自己的写的方法名3.调试xxxx.php文件gdb php 进入gdb界面break zim_demo_get 会问y/n 选ygdb -q xxxx.php -c /etc/php.ini这时会停在zend_method(demo,get)&#123;&#125;方法内，这时只要输入n回车 输入n回车 输入n回车直到出现Segmentation基本上可以定位问题所在。当然你也可以在每一步print 打印你想看的变量内容。 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[5]本类内函数调用","date":"2017-08-05T09:09:59.000Z","path":"2017/08/05/2016-02-05-php-ext-5/","text":"1.需要实现的细节 在第三节，有个调用函数的例子，我们来稍微细说下 然后就是平时大家定义了类里面的方法，有时候有相互调用，我们写一个例子 2.person扩展2.1在php_person.h中增加：PHP_METHOD(person_ce,callback); PHP_METHOD(person_ce,setkey); 2.2 实现代码在php_initest.h中打开全局变量设置块的注释，改成自己相要的变量如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//新增定义ZEND_BEGIN_ARG_INFO_EX(global_setkey_arg, 0, 0, 2) ZEND_ARG_INFO(0, setkey1) ZEND_ARG_INFO(0, setkey2)ZEND_END_ARG_INFO()const zend_function_entry person_functions[] = &#123; ZEND_ME(person, __construct, global_config_arg, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) ZEND_ME(person,doing,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,saying,NULL,ZEND_ACC_PUBLIC) //增加两个类里面的方法 ZEND_ME(person,callback,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,setkey,global_setkey_arg,ZEND_ACC_PUBLIC) ZEND_ME(person,__destruct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_DTOR) PHP_FE_END /* Must be the last line in person_functions[] */&#125;;ZEND_METHOD(person,setkey)&#123; zval *param1; zval *param2; //#include &lt;zend_API.h&gt; //int zend_parse_parameters ( int num_args TSRMLS_DC, char* type_spec, ... ) if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|z\",&amp;param1,&amp;param2) == FAILURE) &#123; RETURN_FALSE; &#125; zend_update_property(person_ce, getThis(), \"param1\", sizeof(\"param1\")-1, param1 TSRMLS_CC); zend_update_property(person_ce, getThis(), \"param2\", sizeof(\"param2\")-1, param2 TSRMLS_CC);&#125;ZEND_METHOD(person,callback)&#123; //#include &lt;zend_interfaces.h&gt; //zval* zend_call_method_with_0_params ( ... obj, zend_class_entry* obj_ce, zend_function** fn_proxy, char* function_name, ... retval ) //zval* zend_call_method_with_1_params ( ... obj, zend_class_entry* obj_ce, zend_function** fn_proxy, char* function_name, ... retval, zval* arg1 ) //zval* zend_call_method_with_2_params ( ... obj, zend_class_entry* obj_ce, zend_function** fn_proxy, char* function_name, ... retval, zval* arg1, zval* arg2 ) //zval* zend_call_method ( zval** object_pp, zend_class_entry* obj_ce, zend_function** fn_proxy, char* function_name, int function_name_len, zval** retval_ptr_ptr, int param_count, zval* arg1, zval* arg2, magic TSRMLS_DC ) zend_call_method_with_0_params(getThis(),person_ce,NULL,\"doing\",return_value);&#125;ZEND_METHOD(person,callback_function)&#123; //声明一个对象变量 zval *object_name; object_init_ex(object_name,person_ce); //声明函数名变量 zval function_name; ZVAL_STRING(&amp;function_name,\"doing\"); //声明承接返回值的变量 zval retval; // 调用类的 doing 方法 if(call_user_function(EG(function_table), object_name, &amp;function_name, &amp;retval, 0, NULL)==FAILURE)&#123; RETURN_NULL(); // zend_error(E_ERROR,\"call person doing error\"); &#125; //释放资源空间 *return_value=*retval; zval_copy_ctor(return_value); zval_ptr_dtor(&amp;retval); &#125; 2.3 相关内容type_spec是格式化字符串，其常见的含义如下： 参数 代表着的类型 b Boolean l Integer 整型 d Floating point 浮点型 s String 字符串 r Resource 资源 a Array 数组 o Object instance 对象 O Object instance of a specified type 特定类型的对象 z Non-specific zval 任意类型～ Z zval**类型 f 表示函数、方法名称 对应的接收变量类型 参数 对应C里的数据类型 b zend_bool l long d double s char*, int 前者接收指针，后者接收长度 r zval* a zval* o zval* O zval*, zend_class_entry* z zval* Z zval** zend_parse_parameters中的 | ，这个表示 在它之前的参数是必须的，之后的是非必须的 2.4 扩展使用1234567891011121314151617[root@bogon tests]# cat test.php&lt;?php$n = new person(array('key'=&gt;'value'));$n-&gt;setkey('testparam1','testparam2');var_dump($n-&gt;param1);var_dump($n-&gt;param2);[root@bogon tests]# php test.phpstring(10) \"testparam1\"string(10) \"testparam2\"array(1) &#123; [\"key\"]=&gt; string(5) \"value\"&#125; 12 仅属个人观点, 可以随意转载但保留以下信息 作者：极品黑公子 邮箱：x0hcker@gmail.com ```","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[4]读取php.ini内容","date":"2017-08-04T09:09:59.000Z","path":"2017/08/04/2016-02-04-php-ext-4/","text":"1.需要实现的细节 在php.ini加上 [initest] initest.username=test nitest.userage=99 实现一个initest类 ，实现一个ini_echo方法，打印相关内容 2.initest扩展2.1创建类的扩展：[root@bogon ext]# cd /usr/local/src/php-7.0.3/ext [root@bogon ext]# ./ext_skel –extname=initest 2.2 修改配置[root@bogon ext]# vim initest/config.m4 dnl PHP_ARG_WITH(initest, for initest support, dnl Make sure that the comment is aligned: dnl [ --with-initest Include initest support]) 更改为： PHP_ARG_WITH(initest, for initest support, dnl Make sure that the comment is aligned: [ --with-initest Include initest support]) 2.3 实现代码在php_initest.h中打开全局变量设置块的注释，改成自己相要的变量如下 12345ZEND_BEGIN_MODULE_GLOBALS(initest) zend_long userage; char *username;ZEND_END_MODULE_GLOBALS(initest) 在initest.c打开相关注释，并添加相关代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546ZEND_DECLARE_MODULE_GLOBALS(initest)PHP_INI_BEGIN() STD_PHP_INI_ENTRY(\"initest.userage\",\"1\", PHP_INI_ALL, OnUpdateLong, userage, zend_initest_globals, initest_globals) STD_PHP_INI_ENTRY(\"initest.username\",\"username\", PHP_INI_ALL, OnUpdateString, username, zend_initest_globals, initest_globals)PHP_INI_END()PHP_MINIT_FUNCTION(initest)&#123; REGISTER_INI_ENTRIES(); return SUCCESS;&#125;PHP_MSHUTDOWN_FUNCTION(initest)&#123; /* uncomment this line if you have INI entries UNREGISTER_INI_ENTRIES(); */ UNREGISTER_INI_ENTRIES(); return SUCCESS;&#125;static void php_initest_init_globals(zend_initest_globals *initest_globals)&#123; //initest_globals-&gt;userage = 1; //initest_globals-&gt;username = \"testusername\";&#125;PHP_FUNCTION(ini_echo)&#123; php_printf(\"username:%s\\n\",INITEST_G(username)); php_printf(\"userage:%d\\n\",INITEST_G(userage));&#125;const zend_function_entry initest_functions[] = &#123; PHP_FE(confirm_initest_compiled, NULL) /* For testing, remove later. */ PHP_FE(ini_echo, NULL) /* For testing, remove later. */ PHP_FE_END /* Must be the last line in initest_functions[] */&#125;; 2.4 编译* [root@bogon hello]# [root@localhost person]# ./configure &amp;&amp; make &amp;&amp; make install 2.5 扩展安装[initest] initest.userage=99 initest.username=test extension=initest.so 2.6 扩展使用12345678[root@bogon tests]# cat test.php&lt;?phpini_echo();[root@bogon tests]# php test.phpusername:testuserage:99 12 仅属个人观点, 可以随意转载但保留以下信息 作者：极品黑公子 邮箱：x0hcker@gmail.com ```","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[3]类构造函数传参","date":"2017-08-03T09:09:59.000Z","path":"2017/08/03/2016-02-03-php-ext-3/","text":"1.需要实现的细节 实现一个person类 ，实现一个doing方法和saying方法 在构造方法中传递一个数组，在doing中打印此数组 saying方法中，构建一个空数组，返回，不需要传参。 2.class扩展2.1创建类的扩展：[root@bogon ext]# cd /usr/local/src/php-7.0.3/ext [root@bogon ext]# ./ext_skel –extname=person 2.2 修改配置[root@bogon ext]# vim person/config.m4 dnl PHP_ARG_WITH(person, for person support, dnl Make sure that the comment is aligned: dnl [ –with-person Include person support]) 更改为： PHP_ARG_WITH(person, for person support, dnl Make sure that the comment is aligned: [ –with-person Include person support]) 2.3 实现代码在php_person.h头中加上 12345extern zend_class_entry *person_ce;PHP_METHOD(person_ce,__construct);PHP_METHOD(person_ce,saying);PHP_METHOD(person_ce,doing); 在person.c头中加上 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798ZEND_BEGIN_ARG_INFO_EX(global_config_arg, 0, 0, 1) ZEND_ARG_INFO(0, global_config)ZEND_END_ARG_INFO()/** * 声明构造函数 * @param * @return */ZEND_METHOD(person,__construct)&#123; zval *array_config; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &amp;array_config) == FAILURE) &#123; RETURN_NULL(); &#125; //php_var_dump( &amp;array_config,1 TSRMLS_CC); zend_update_property(person_ce, getThis(), \"config\", sizeof(\"config\")-1, array_config TSRMLS_CC); &#125;/** * 声明析造函数 * @param * @return */ZEND_METHOD(person,__destruct)&#123; zend_printf(\"destruct\\n\");&#125;ZEND_METHOD(person,doing)&#123; //array_init(return_value); zval *array_config; zval rv; //php &gt;=7.0 array_config = zend_read_property(person_ce, getThis(), \"config\", sizeof(\"config\")-1, 0, &amp;rv TSRMLS_DC); if( Z_TYPE_P(array_config) == IS_NULL || Z_TYPE_P(array_config) != IS_ARRAY )&#123; //zend_error(E_ERROR, \"framework config error!\"); RETURN_FALSE; &#125; //php_var_dump(&amp;array_config, 1 TSRMLS_CC); RETURN_ZVAL(array_config, 1, 0); //zend_printf(\"doing\\n\"); &#125;ZEND_METHOD(person,saying)&#123; if (zend_parse_parameters_none() == FAILURE) &#123; RETURN_FALSE; &#125; array_init(return_value); //zend_printf(\"saying\\n\");&#125;//这个函数需要加上声明，去掉了没用的test函数const zend_function_entry person_functions[] = &#123; ZEND_ME(person, __construct, global_config_arg, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) ZEND_ME(person,doing,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,saying,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,__destruct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_DTOR) PHP_FE_END /* Must be the last line in person_functions[] */&#125;;//将类和方法注册到zendPHP_MINIT_FUNCTION(person)&#123; zend_class_entry ce; INIT_CLASS_ENTRY(ce, \"person\", person_functions); person_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); zend_declare_property_null(person_ce,\"saying\",strlen(\"saying\"),ZEND_ACC_PUBLIC); zend_declare_property_null(person_ce,\"doing\",strlen(\"doing\"),ZEND_ACC_PUBLIC); return SUCCESS;&#125; 2.4 编译* [root@bogon hello]# [root@localhost person]# ./configure &amp;&amp; make &amp;&amp; make install 2.5 扩展安装1. 改更php.ini 加上[person] extenstion=person.so 2.6 扩展使用123456789101112131415161718[root@bogon tests]# cat test.php&lt;?php $n = new person(array('key'=&gt;'value'));var_dump($n-&gt;saying('error'));var_dump($n-&gt;saying());var_dump($n-&gt;doing()); [root@localhost tests]# php test.phpPHP Warning: person::saying() expects exactly 0 parameters, 1 given in /usr/local/src/php-7.0.3/ext/person/tests/test.php on line 5bool(false)array(0) &#123;&#125;array(1) &#123; [\"key\"]=&gt; string(5) \"value\"&#125; 3.引用宏说明3.1 定义参数宏 Zend/zend_API.h[root@bogon php-7.0.3]# grep -A 10 &apos;ZEND_BEGIN_ARG_INFO_EX&apos; ./Zend/*.h #define ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args) \\ static const zend_internal_arg_info name[] = { \\ { (const char*)(zend_uintptr_t)(required_num_args), NULL, 0, return_reference, 0, 0 }, #define ZEND_BEGIN_ARG_INFO(name, _unused)\\ ZEND_BEGIN_ARG_INFO_EX(name, 0, ZEND_RETURN_VALUE, -1) #define ZEND_END_ARG_INFO() }; //宏说明 ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference) //开始参数块定义，pass_rest_by_reference为1时，强制所有参数为引用类型 ZEND_END_ARG_INFO() //结束参数块定义 ZEND_ARG_INFO //声明普通参数，可以用来表示PHP中的int, float, double, string等基本数据类型 ZEND_ARG_OBJ_INFO //声明对象类型的参数 ZEND_ARG_ARRAY_INFO //声明数组类型的参数 ZEND_ARG_PASS_INFO(pass_by_ref) //pass_by_ref为1时，强制设置后续的参数为引用类型 zend_internal_arg_info结构定义在./Zend/zend_compile.h: typedef struct _zend_internal_arg_info { const char *name; //参数的名称 const char *class_name; //当参数类型为类时，指定类的名称 zend_uchar type_hint; zend_uchar pass_by_reference;//是否设置为引用，即使用&amp;操作符 zend_bool allow_null; //是否允许设置为null zend_bool is_variadic; } zend_internal_arg_info; 3.2 定义返回值的宏 Zend/zend_API.h1234567891011121314151617181920212223242526272829303132333435363738394041#define RETVAL_BOOL(b) ZVAL_BOOL(return_value, b)#define RETVAL_NULL() ZVAL_NULL(return_value)#define RETVAL_LONG(l) ZVAL_LONG(return_value, l)#define RETVAL_DOUBLE(d) ZVAL_DOUBLE(return_value, d)#define RETVAL_STR(s) ZVAL_STR(return_value, s)#define RETVAL_INTERNED_STR(s) ZVAL_INTERNED_STR(return_value, s)#define RETVAL_NEW_STR(s) ZVAL_NEW_STR(return_value, s)#define RETVAL_STR_COPY(s) ZVAL_STR_COPY(return_value, s)#define RETVAL_STRING(s) ZVAL_STRING(return_value, s)#define RETVAL_STRINGL(s, l) ZVAL_STRINGL(return_value, s, l)#define RETVAL_EMPTY_STRING() ZVAL_EMPTY_STRING(return_value)#define RETVAL_RES(r) ZVAL_RES(return_value, r)#define RETVAL_ARR(r) ZVAL_ARR(return_value, r)#define RETVAL_OBJ(r) ZVAL_OBJ(return_value, r)#define RETVAL_ZVAL(zv, copy, dtor) ZVAL_ZVAL(return_value, zv, copy, dtor)#define RETVAL_FALSE ZVAL_FALSE(return_value)#define RETVAL_TRUE ZVAL_TRUE(return_value)#define RETURN_BOOL(b) &#123; RETVAL_BOOL(b); return; &#125;#define RETURN_NULL() &#123; RETVAL_NULL(); return;&#125;#define RETURN_LONG(l) &#123; RETVAL_LONG(l); return; &#125;#define RETURN_DOUBLE(d) &#123; RETVAL_DOUBLE(d); return; &#125;#define RETURN_STR(s) &#123; RETVAL_STR(s); return; &#125;#define RETURN_INTERNED_STR(s) &#123; RETVAL_INTERNED_STR(s); return; &#125;#define RETURN_NEW_STR(s) &#123; RETVAL_NEW_STR(s); return; &#125;#define RETURN_STR_COPY(s) &#123; RETVAL_STR_COPY(s); return; &#125;#define RETURN_STRING(s) &#123; RETVAL_STRING(s); return; &#125;#define RETURN_STRINGL(s, l) &#123; RETVAL_STRINGL(s, l); return; &#125;#define RETURN_EMPTY_STRING() &#123; RETVAL_EMPTY_STRING(); return; &#125;#define RETURN_RES(r) &#123; RETVAL_RES(r); return; &#125;#define RETURN_ARR(r) &#123; RETVAL_ARR(r); return; &#125;#define RETURN_OBJ(r) &#123; RETVAL_OBJ(r); return; &#125;#define RETURN_ZVAL(zv, copy, dtor) &#123; RETVAL_ZVAL(zv, copy, dtor); return; &#125;#define RETURN_FALSE &#123; RETVAL_FALSE; return; &#125;#define RETURN_TRUE &#123; RETVAL_TRUE; return; &#125;a)返回数组array_init(return_value);//初始化return_value成数组，此操作完后就可以返回一个空的数组b)返回objectobject_init(return_value);//初始化return_value成Object，此操作完成后返回一个空的对像 3.3 类访问控制掩码 ./Zend/zend_compile.h123456789101112131415161718192021222324252627282930/* method flags (types) */#define ZEND_ACC_STATIC 0x01#define ZEND_ACC_ABSTRACT 0x02#define ZEND_ACC_FINAL 0x04#define ZEND_ACC_IMPLEMENTED_ABSTRACT 0x08/* class flags (types) *//* ZEND_ACC_IMPLICIT_ABSTRACT_CLASS is used for abstract classes (since it is set by any abstract method even interfaces MAY have it s/* ZEND_ACC_EXPLICIT_ABSTRACT_CLASS denotes that a class was explicitly defined as abstract by using the keyword. */#define ZEND_ACC_IMPLICIT_ABSTRACT_CLASS 0x10#define ZEND_ACC_EXPLICIT_ABSTRACT_CLASS 0x20#define ZEND_ACC_INTERFACE 0x40#define ZEND_ACC_TRAIT 0x80#define ZEND_ACC_ANON_CLASS 0x100#define ZEND_ACC_ANON_BOUND 0x200/* method flags (visibility) *//* The order of those must be kept - public &lt; protected &lt; private */#define ZEND_ACC_PUBLIC 0x100#define ZEND_ACC_PROTECTED 0x200#define ZEND_ACC_PRIVATE 0x400#define ZEND_ACC_PPP_MASK (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)#define ZEND_ACC_CHANGED 0x800#define ZEND_ACC_IMPLICIT_PUBLIC 0x1000/* method flags (special method detection) */#define ZEND_ACC_CTOR 0x2000#define ZEND_ACC_DTOR 0x4000#define ZEND_ACC_CLONE 0x8000 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[2]-怎么样定义一个类","date":"2017-08-02T09:09:59.000Z","path":"2017/08/02/2016-02-02-php-ext-2/","text":"1.需要实现的细节 实现一个person类 实现一个doing方法和saying方法 2.第一个扩展2.1创建类的扩展：[root@bogon ext]# cd /usr/local/src/php-7.0.3/ext [root@bogon ext]# ./ext_skel –extname=person 2.2 修改配置[root@bogon ext]# vim person/config.m4 dnl PHP_ARG_WITH(person, for person support, dnl Make sure that the comment is aligned: dnl [ –with-person Include person support]) 更改为： PHP_ARG_WITH(person, for person support, dnl Make sure that the comment is aligned: [ –with-person Include person support]) 2.3 实现代码在php_person.h头中加上 12345extern zend_class_entry *person_ce;PHP_METHOD(person_ce,__construct);PHP_METHOD(person_ce,saying);PHP_METHOD(person_ce,doing); 在person.c头中加上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 声明构造函数 * @param * @return */ZEND_METHOD(person,__construct)&#123; zval *pThis; pThis = getThis(); zend_printf(\"construct\\n\");&#125;/** * 声明析造函数 * @param * @return */ZEND_METHOD(person,__destruct)&#123; zend_printf(\"destruct\\n\");&#125;ZEND_METHOD(person,doing)&#123; zend_printf(\"doing\\n\");&#125;ZEND_METHOD(person,saying)&#123; zend_printf(\"saying\\n\");&#125;//这个函数需要加上声明，去掉了没用的test函数const zend_function_entry person_functions[] = &#123; ZEND_ME(person, __construct, global_config_arg, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR) ZEND_ME(person,doing,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,saying,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,__destruct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_DTOR) PHP_FE_END /* Must be the last line in person_functions[] */&#125;;//将类和方法注册到zendPHP_MINIT_FUNCTION(person)&#123; zend_class_entry ce; INIT_CLASS_ENTRY(ce, \"person\", person_functions); person_ce = zend_register_internal_class(&amp;ce TSRMLS_CC); zend_declare_property_null(person_ce,\"saying\",strlen(\"saying\"),ZEND_ACC_PUBLIC); zend_declare_property_null(person_ce,\"doing\",strlen(\"doing\"),ZEND_ACC_PUBLIC); return SUCCESS;&#125; 2.4 编译* [root@bogon hello]# [root@localhost person]# ./configure &amp;&amp; make &amp;&amp; make install 2.5 扩展安装1. 改更php.ini 加上[person] extenstion=person.so 2.6 扩展使用123456789101112[root@bogon tests]# cat test.php&lt;?php $n = new person();echo $n-&gt;saying();echo $n-&gt;doing(); [root@localhost tests]# php test.phpconstructsayingdoingdestruct 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"php7扩展开发[1]-helloword","date":"2017-08-01T09:09:59.000Z","path":"2017/08/01/2016-02-01-php-ext-1/","text":"1.环境安装 centos 7.1 php 7.0.3 1.1 RPM安装PHP rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm yum install php70w php -v 看一下 7.0.3 php -m 看一下 php70w-devel, php70w-opcache模块安装没有，没有的话安装一下 1.2 下载php的源码包 http://hk1.php.net/distributions/php-7.0.3.tar.gz 把源码放在/usr/local/src/下解压 2.第一个扩展2.1 输入：[root@bogon ext]# cd /usr/local/src/php-7.0.3/ext [root@bogon ext]# ./ext_skel –extname=hello 2.1 输出：Creating directory hello Creating basic files: config.m4 config.w32 .gitignore hello.c php_hello.hCREDITS EXPERIMENTAL tests/001.phpt hello.php [done]. To use your new extension, you will have to execute the following steps: $ cd .. $ vi ext/hello/config.m4 $ ./buildconf $ ./configure –[with|enable]-hello $ make $ ./sapi/cli/php -f ext/hello/hello.php $ vi ext/hello/hello.c $ make Repeat steps 3-6 until you are satisfied with ext/hello/config.m4 andstep 6 confirms that your module is compiled into PHP. Then, start writingcode and repeat the last two steps as often as necessary. 2.2 输入：[root@bogon ext]# tree hello/ 2.2 输出： hello/ ├── config.m4 ├── config.w32 ├── CREDITS ├── EXPERIMENTAL ├── hello.c ├── hello.php ├── php_hello.h └── tests 占个位└── 001.phpt 2.3 修改配置[root@bogon ext]# vim hello/config.m4 dnl PHP_ARG_WITH(hello, for hello support, dnl Make sure that the comment is aligned: dnl [ –with-hello Include hello support]) 更改为： PHP_ARG_WITH(hello, for hello support, dnl Make sure that the comment is aligned: [ –with-hello Include hello support]) 2.4 实现代码* 新增 声明函数 PHP_FE(hello, NULL)； * - const zend_function_entry hello_functions[] = { - PHP_FE(hello, NULL) /* For testing, remove later. */ - PHP_FE(confirm_hello_compiled, NULL) - /* For testing, remove later. */ - PHP_FE_END /* Must be the last line in hello_functions[] */ - }; * 新增 函数实现 PHP_FE(hello, NULL)；放在PHP_FUNCTION(confirm_hello_compiled)上面 * - PHP_FUNCTION(hello) - { - zend_string *strg; - strg = strpprintf(0, &quot;hello word&quot;); - RETURN_STR(strg); - } 2.4 编译* [root@bogon hello]# pwd * /usr/local/src/php-7.0.3/ext/hello * [root@bogon hello]# ./configure * ............. * [root@bogon hello]# make * ............. * [root@bogon hello]# ll modules/ * -rw-r--r--. 1 root root 915 Mar 16 21:58 hello.la * -rwxr-xr-x. 1 root root 31422 Mar 16 21:58 hello.so 2.5 扩展安装1. 改更php.ini 加上[hello] extenstion=hello.so 2. 安放扩展so文件，如果你不知道PHP扩展在哪，可以用如下方法找 3. [root@bogon hello]# find / -name opcache.so 4. cp modules/hello.so /usr/lib64/php/modules 5. php -m|grep hello 会出现hello字样 2.6 扩展使用[root@bogon tests]# cat test.php &lt;?php echo hello(); echo &quot;\\r\\n&quot;; [root@bogon tests]# php test.php hello word &gt; 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"python技术分享[18] tornado之TCPServer","date":"2017-07-29T10:30:00.000Z","path":"2017/07/29/2017-07-29-training-python-17/","text":"C10K问题C10K问题的一个文章：http://www.kegel.com/c10k.html 环境准备： 修改系统打开文件限制 123456limit -n 查看到当前设置 grep 'open files' /proc/$(cat /var/run/xxxx.pid)/limits 打开 /etc/security/limits.conf 并添加（如果已经存在，则修改数值）* soft nofile 1000000* hard nofile 1000000 网络端口限制修改 12345678vi /etc/sysctl.confnet.nf_conntrack_max= 6553500net.ipv4.ip_local_port_range=\"1024 65535\"使之生效sysctl -pvi /proc/sys/net/nf_conntrack_max查看修改是否成功 解决大量TCP的TIME_WAIT问题 123456789101112查看服务器中TCP连接的状态。netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;' 修改系统参数，缓解TIME_WAIT问题vi /etc/sysctl.confnet.ipv4.tcp_tw_reuse=1net.ipv4.tcp_tw_recycle=1net.ipv4.tcp_max_tw_buckets=5000net.ipv4.tcp_syncookies=1使之生效sysctl -p TcpServer代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env python# encoding: utf-8from tornado import processfrom tornado import web, netutilfrom tornado.tcpserver import TCPServerfrom tornado import ioloopimport sys, os ,syslogimport json, base64import multiprocessingdef sub_mod(ip, data): #解密内容 data = json.loads(base64.b64decode(data)) print(data) #db = custom_mongodb(using='logs') #db.insert('test', **data) #db.conn.disconnect()class MtaskConnection(object): stream_set = set([]) def __init__(self, pool, stream, address): self.pool = pool self.stream = stream self.address = address self.stream_set.add(self.stream) self.stream.set_close_callback(self._on_close) self.stream.read_until('\\n', self._on_read_line) def _on_read_line(self, data): self.pool.apply_async(sub_mod, (self.address[0], data)) def _on_close(self): MtaskConnection.stream_set.remove(self.stream)class MonitorTCPServer(TCPServer): def __init__(self): TCPServer.__init__(self) self.pool = multiprocessing.Pool(processes=8) def handle_stream(self, stream, address): MtaskConnection(self.pool, stream, address)def main(): sockets = netutil.bind_sockets(8080) process.fork_processes(0) server = MonitorTCPServer() server.add_sockets(sockets) ioloop.IOLoop.instance().start()if __name__ == '__main__': syslog.openlog(\"monitor_svr\", 0, syslog.LOG_LOCAL6) main() syslog.closelog() TcpClient代码123456789101112131415161718192021import socketimport base64import jsondef clint(): host = '127.0.0.1' port = 8080 bufsize = 1024 addr = (host, port) client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect(addr) data =&#123;\"value\":\"testtestest\"&#125; # json化返回数据 client.send(base64.b64encode(json.dumps(data)) + '\\n') client.close()if __name__ == '__main__': clint() 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"phpmongodb","slug":"phpmongodb","permalink":"//www.zwting.com/tags/phpmongodb/"}]},{"title":"python技术分享[16] python使用ssh隧道连接内网开放的mysql","date":"2017-07-28T10:30:00.000Z","path":"2017/07/28/2017-07-28-training-python-16/","text":"背景介绍 数据库只允许内网访问 服务器公网SSH访问 模块安装 pip install sshtunnel -i https://pypi.doubanio.com/simple/ pip install MySQL-python==1.2.5 -i https://pypi.doubanio.com/simple/ [关键是sshtunnel] 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import MySQLdb from sshtunnel import SSHTunnelForwarder import MySQLdb.cursors def dbconnect_ssh(ssh_host,ssh_port,keyfile,ssh_user,db_host,db_name,sql,db_port,db_user,db_passwd): with SSHTunnelForwarder( (ssh_host, ssh_port), #ssh_password=\"sshpasswd\", ssh_pkey=keyfile, ssh_username=ssh_user, remote_bind_address=(db_host, db_port) ) as server: db = MySQLdb.connect( host='127.0.0.1', port=server.local_bind_port, user=db_user, passwd=db_passwd, db=db_name, charset=\"utf8\", cursorclass=MySQLdb.cursors.DictCursor) cursor = db.cursor() try: cursor.execute(sql) data = cursor.fetchall() db.commit() except: db.rollback() collect = [] for result in data: collect.append(result) db.close() cursor.close() return collectif __name__ == \"__main__\": ssh_host = \"1.1.1.1\" #SSH服务器地址 ssh_port = 22 #SSH端口 keyfile = \"/root/.ssh/id_rsa\" #SSH密钥 ssh_user = \"leoiceo\" #SSH用户名 db_host = \"192.168.1.1\" #数据库地址 db_name = 'mysql' #数据库名 sql = 'show databases;' #SQL db_port = 3306 #数据库端口 db_user = 'root' #数据库用户名 db_passwd = '123456' #数据库密码 result = dbconnect_ssh(ssh_host,ssh_port,keyfile,ssh_user,db_host,db_name,sql,db_port,db_user,db_passwd) print result 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"phpmongodb","slug":"phpmongodb","permalink":"//www.zwting.com/tags/phpmongodb/"}]},{"title":"zookeeper的Cluster集群搭建及管理","date":"2017-07-07T02:30:00.000Z","path":"2017/07/07/2017-07-07-cluster-zookeeper-1/","text":"背景介绍 三台服务器实现zookeeper集群 172.16.61.102 172.16.61.103 172.16.61.104 安装目录 /opt 一切动作默认的目录 安装zookeeper[每台服务器]wget http://mirrors.cnnic.cn/apache/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz tar zxvf zookeeper-3.4.9.tar.gz ln -s zookeeper-3.4.9/ zookeeper 写zookeeper配置cat conf/zoo.cfg tickTime=2000 initLimit=10 syncLimit=5 clientPort=2181 maxClientCnxns=0 dataDir=/opt/zookeeper/data dataLogDir=/opt/zookeeper/logs server.1=172.16.61.102:2888:3888 server.2=172.16.61.103:2888:3888 server.3=172.16.61.104:2888:3888 分发上面安装好的目录scp -r /opt/zookeeper root@172.16.61.103:/opt scp -r /opt/zookeeper root@172.16.61.104:/opt 安装zookeeper[每台服务器]根据上面的配置 server.1=172.16.61.102:2888:3888 server.2=172.16.61.103:2888:3888 server.3=172.16.61.104:2888:3888 如下操作： echo &quot;1&quot; &gt; /opt/zookeeper/data/myid 在172.16.61.102上 echo &quot;2&quot; &gt; /opt/zookeeper/data/myid 在172.16.61.103上 echo &quot;3&quot; &gt; /opt/zookeeper/data/myid 在172.16.61.104上 启动zookeeper[每台服务器]/opt/zookeeper/bin/zkServer.sh start 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"Redis的Cluster集群搭建及管理","date":"2017-07-05T12:30:00.000Z","path":"2017/07/05/2017-07-05-cluster-redis-1/","text":"背景介绍 三台服务器 172.16.61.102 172.16.61.103 172.16.61.104 redis端口占有用情况 172.16.61.102:6000 172.16.61.102:7000 172.16.61.103:6000 172.16.61.103:7000 172.16.61.104:6000 172.16.61.104:7000 安装redis[每台服务器]123456wget http://download.redis.io/releases/redis-3.2.9.tar.gztar zxf redis-3.2.9.tar.gz cd redis-3.2.9make &amp;&amp; make installcp src/redis-trib.rb /usr/bin/cp src/redis-trib.rb /usr/local/bin/ 安装redis cluster [每台服务器]12345678910111213141516171819202122232425mkdir -p /opt/6000/logs mkdir -p /opt/6000/data mkdir -p /opt/6000/conf mkdir -p /opt/7000/logs mkdir -p /opt/7000/data mkdir -p /opt/7000/conf ``` [root@yaliceshi-1-2 opt]# cat /opt/6000/conf/redis_6000.conf``` port 6000 bind 172.16.61.102cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000cluster-slave-validity-factor 10cluster-migration-barrier 1cluster-require-full-coverage yesappendonly yes daemonize yes pidfile /opt/6000/redis.piddir /opt/6000/datalogfile /opt/6000/logs/error.log [root@yaliceshi-1-2 opt]# cat /opt/7000/conf/redis_7000.conf 12345678910111213port 7000 bind 172.16.61.102cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000cluster-slave-validity-factor 10cluster-migration-barrier 1cluster-require-full-coverage yesappendonly yes daemonize yes pidfile /opt/7000/redis.piddir /opt/7000/datalogfile /opt/7000/logs/error.log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263redis-server /opt/6000/conf/redis_6000.conf redis-server /opt/7000/conf/redis_7000.conf ``` * 安装ruby * yum -y install ruby rubygems * wget https://rubygems.org/downloads/redis-3.3.3.gem * gem install -l redis-3.3.3.gem * 创建集群 * redis-trib.rb create --replicas 1 172.16.61.102:6000 172.16.61.102:7000 172.16.61.103:6000 172.16.61.103:7000 172.16.61.104:6000 172.16.61.104:7000``` &gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:172.16.61.104:6000172.16.61.103:6000172.16.61.102:6000Adding replica 172.16.61.103:7000 to 172.16.61.104:6000Adding replica 172.16.61.104:7000 to 172.16.61.103:6000Adding replica 172.16.61.102:7000 to 172.16.61.102:6000M: 0fce21a91ba5be57f75e65953383fb968515c03a 172.16.61.102:6000 slots:10923-16383 (5461 slots) masterS: 57601f37944296b3144261b304f2d18c044e610d 172.16.61.102:7000 replicates 0fce21a91ba5be57f75e65953383fb968515c03aM: f551d92f7504cca5109b2ea9bee1e9a56b711ddc 172.16.61.103:6000 slots:5461-10922 (5462 slots) masterS: b993661e480ff1005117a4b4418818798b0602ee 172.16.61.103:7000 replicates 39eb4b60328941c93569448fd8730dfa36a35515M: 39eb4b60328941c93569448fd8730dfa36a35515 172.16.61.104:6000 slots:0-5460 (5461 slots) masterS: 2a0e2fbcbea48b43f2f953fd84517c5a9cada9ce 172.16.61.104:7000 replicates f551d92f7504cca5109b2ea9bee1e9a56b711ddcCan I set the above configuration? (type 'yes' to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 172.16.61.102:6000)M: 0fce21a91ba5be57f75e65953383fb968515c03a 172.16.61.102:6000 slots:10923-16383 (5461 slots) master 1 additional replica(s)S: 2a0e2fbcbea48b43f2f953fd84517c5a9cada9ce 172.16.61.104:7000 slots: (0 slots) slave replicates f551d92f7504cca5109b2ea9bee1e9a56b711ddcS: 57601f37944296b3144261b304f2d18c044e610d 172.16.61.102:7000 slots: (0 slots) slave replicates 0fce21a91ba5be57f75e65953383fb968515c03aM: 39eb4b60328941c93569448fd8730dfa36a35515 172.16.61.104:6000 slots:0-5460 (5461 slots) master 1 additional replica(s)S: b993661e480ff1005117a4b4418818798b0602ee 172.16.61.103:7000 slots: (0 slots) slave replicates 39eb4b60328941c93569448fd8730dfa36a35515M: f551d92f7504cca5109b2ea9bee1e9a56b711ddc 172.16.61.103:6000 slots:5461-10922 (5462 slots) master 1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered 检查集群 1234567[root@yaliceshi-1-2 7000]# redis-cli -h 172.16.61.102 -p 6000 cluster nodes 0fce21a91ba5be57f75e65953383fb968515c03a 172.16.61.102:6000 myself,master - 0 0 1 connected 10923-16383 2a0e2fbcbea48b43f2f953fd84517c5a9cada9ce 172.16.61.104:7000 slave f551d92f7504cca5109b2ea9bee1e9a56b711ddc 0 1499409685274 6 connected 57601f37944296b3144261b304f2d18c044e610d 172.16.61.102:7000 slave 0fce21a91ba5be57f75e65953383fb968515c03a 0 1499409685274 2 connected 39eb4b60328941c93569448fd8730dfa36a35515 172.16.61.104:6000 master - 0 1499409684775 5 connected 0-5460 b993661e480ff1005117a4b4418818798b0602ee 172.16.61.103:7000 slave 39eb4b60328941c93569448fd8730dfa36a35515 0 1499409683773 5 connected f551d92f7504cca5109b2ea9bee1e9a56b711ddc 172.16.61.103:6000 master - 0 1499409684274 3 connected 5461-10922 参考: http://blog.csdn.net/reyleon/article/details/51454334 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"集群搭建","slug":"集群搭建","permalink":"//www.zwting.com/tags/集群搭建/"}]},{"title":"业务环境概述","date":"2017-06-30T02:30:00.000Z","path":"2017/06/30/team-2/","text":"业务架构思路以公司级通用信息、通用服务、游戏可规范数据为依托，构建企业级运营分析平台。将账号充值支付系统和广告接入系统和游戏数据打通，扩展游戏与用户之间的关系，提高用户行为分析精确度。以为运营平台为入口，管控多个游戏，屏蔽多游戏间的不同点，方便快速接入管理工具，减少游戏后端每个游戏都做一遍管理工具的 。以统一账号支付系统为入口，管控多个游戏，屏蔽多游戏间的不同点，方便快速接入第三渠道，减少游戏后端工作量，保持游戏包的纯净。 管理流程 1、事件管理 2、问题管理 3、配置管理 4、变更管理 5、发布管理 事件管理的目标是在不影响业务的情况下，尽可能快速的恢复服务，从而保证最佳的效率和服务的可持续性。事件管理流程的建立包括事件分类，确定事件的优先级和建立事件的升级机制。 问题管理是调查基础设施和所有可用信息，包括事件数据库，来确定引起事件发生的真正潜在原因，以及提供的服务中可能存在的故障。 配置管理的目标是：定义和控制服务与基础设施的部件，并保持准确的配置信息。变更管理的目标是：以受控的方式，确保所有变更得到评估、批准、实施和评审。发布管理的目标是：在实际运行环境的发布中，交付、分发并跟踪一个或多个变更。 核心模块服务台：服务台是IT部门和IT服务用户之间的单一联系点。它通过提供一个集中和专职的服务联系点促进了组织业务流程与服务管理基础架构集成。服务台的主要目标是协调客户（用户）和IT部门之间的联系，为IT服务运作提供支持，从而提高客户的满意度。 事故管理：事故管理负责记录、归类和安排专家处理事故并监督整个处理过程直至事故得到解决和终止。事故管理的目的是在尽可能最小地影响客户和用户业务的情况下使IT系统恢复到服务级别协议所定义的服务级别。 问题管理：问题管理是指通过调查和分析IT基础架构的薄弱环节、查明事故产生的潜在原因，并制定解决事故的方案和防止事故再次发生的措施，将由于问题和事故对业务产生的负面影响减小到最低的服务管理流程。与事故管理强调事故恢复的速度不同，问题管理强调的是找出事故产生的根源，从而制定恰当的解决方案或防止其再次发生的预防措施。 配置管理：配置管理是识别和确认系统的配置项，记录和报告配置项状态和变更请求，检验配置项的正确性和完整性等活动构成的过程，其目的是提供IT基础架构的逻辑模型，支持其它服务管理流程特别是变更管理和发布管理的运作。 变更管理：变更管理是指为在最短的中断时间内完成基础架构或服务的任一方面的变更而对其进行控制的服务管理流程。变更管理的目标是确保在变更实施过程中使用标准的方法和步骤，尽快地实施变更，以将由变更所导致的业务中断对业务的影响减小到最低。 发布管理：发布管理是指对经过测试后导入实际应用的新增或修改后的配置项进行分发和宣传的管理流程。发布管理以前又称为软件控制与分发，它由变更管理流程控制。 服务级别管理：服务级别管理是为签订服务级别协议（SLAs）而进行的计划、草拟、协商、监控和报告以及签订服务级别协议后对服务绩效的评价等一系列活动所组成的一个服务管理流程。服务级别管理旨在确保组织所需的IT服务质量在成本合理的范围内得以维持并逐渐提高。 IT服务财务管理：IT服务财务管理是负责预算和核算IT服务提供方提供IT服务所需的成本，并向客户收取相应服务费用的管理流程，它包括IT投资预算、IT服务成本核算和服务计费三个子流程，其目标是通过量化服务成本减少成本超支的风险、减少不必要的浪费、合理引导客户的行为，从而最终保证所提供的IT服务符合成本效益的原则。IT服务财务管理流程产生的预算和核算信息可以为服务级别管理、能力管理、IT服务持续性管理和变更管理等管理流程提供决策依据。 IT服务持续性管理：IT服务持续性管理是指确保发生灾难后有足够的技术、财务和管理资源来确保IT服务持续性的管理流程。IT服务持续性管理关注的焦点是在发生服务故障后仍然能够提供预定级别的IT服务，从而支持组织的业务持续运作的能力。 能力管理：能力管理是指在成本和业务需求的双重约束下，通过配置合理的服务能力使组织的IT资源发挥最大效能的服务管理流程。能力管理流程包括业务能力管理、服务能力管理和资源能力管理三个子流程。 可用性管理：可用性管理是通过分析用户和业务方的可用性需求并据以优化和设计IT基础架构的可用性，从而确保以合理的成本满足不断增长的可用性需求的管理流程。可用性管理是一个前瞻性的管理流程，它通过对业务和用户可用性需求的定位，使得IT服务的设计建立在真实需求的基础上，从而避免IT服务运作中采用了过度的可用性级别，节约了IT服务的运作成本。 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"php的mongodb报错socket-timeout-calling-ismaster.md","date":"2017-05-27T10:30:00.000Z","path":"2017/05/27/tech-2/","text":"使用php的mongodb的扩展时报如下错误 No suitable servers found (serverSelectionTryOnce set): [socket timeout calling ismaster on ‘xxx.xxx.xxx.xxx:xx’ 测试场景TEST1[h0cker@iZ232w1qo8eZ ~]$ /X0hcker/h0cker/h0cker/usr/php-7.1.0/bin/php test_wu_1.php 进程ID:18652 进程ID:18652 进程ID:18652 进程ID:18652 进程ID:18652 [h0cker@iZ232w1qo8eZ ~]$ cat test_wu_1.php &lt;?php $options = [ &apos;heartbeatFrequencyMS&apos; =&gt; 1000,h0cker &apos;connectTimeoutMS&apos; =&gt; 600000, &apos;socketTimeoutMSG&apos; =&gt; 600000, &apos;readPreference&apos; =&gt; MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED ]; $uri = &apos;mongodb://username:&apos;.rawurlencode(&apos;xxxxxxxxxxxxxx&apos;).&apos;@xx.xx.xxx.xxx:port&apos;; $manager = new MongoDB\\Driver\\Manager($uri, $options); sleep(400); $where =[]; $options = [&apos;sort&apos;=&gt;[&apos;_id&apos;=&gt;-1]]; try{ for($i=0;$i&lt;5;$i++){ $query = new MongoDB\\Driver\\Query($where, $options); $cursor = $manager-&gt;executeQuery(&quot;project_name_sb1.users&quot;, $query); foreach ($cursor as $document) { echo &quot;进程ID:&quot;,getmypid(),&quot;\\t&quot;,$document-&gt;name,PHP_EOL; break; } } }catch(Exception $e) { var_dump($e); } TEST2[h0cker@iZ232w1qo8eZ ~]$ /X0hcker/h0cker/h0cker/usr/php-7.1.0/bin/php test_wu_1.php 进程ID:21819 object(MongoDB\\Driver\\Exception\\ConnectionTimeoutException)#113 (7) { [&quot;message&quot;:protected]=&gt; string(111) &quot;No suitable servers found (`serverSelectionTryOnce` set): [socket timeout calling ismaster on &apos;xx.xx.xxx.xxx:port&apos;]&quot; [&quot;string&quot;:&quot;Exception&quot;:private]=&gt; string(0) &quot;&quot; [&quot;code&quot;:protected]=&gt; int(13053) [&quot;file&quot;:protected]=&gt; string(31) &quot;/data/X0hcker/88888/test_wu_1.php&quot; [&quot;line&quot;:protected]=&gt; int(23) [&quot;trace&quot;:&quot;Exception&quot;:private]=&gt; array(1) { [0]=&gt; array(6) { [&quot;file&quot;]=&gt; string(31) &quot;/data/X0hcker/X0hcker/test_wu_1.php&quot; [&quot;line&quot;]=&gt; int(23) [&quot;function&quot;]=&gt; string(12) &quot;executeQuery&quot; [&quot;class&quot;]=&gt; string(22) &quot;MongoDB\\Driver\\Manager&quot; [&quot;type&quot;]=&gt; string(2) &quot;-&gt;&quot; [&quot;args&quot;]=&gt; array(2) { [0]=&gt; string(17) &quot;project_name_sb1.users&quot; [1]=&gt; object(MongoDB\\Driver\\Query)#4 (3) { [&quot;filter&quot;]=&gt; object(stdClass)#114 (0) { } [&quot;options&quot;]=&gt; object(stdClass)#116 (1) { [&quot;sort&quot;]=&gt; object(stdClass)#115 (1) { [&quot;_id&quot;]=&gt; int(-1) } } [&quot;readConcern&quot;]=&gt; NULL &lt;?php } &lt;?php } } } [&quot;previous&quot;:&quot;Exception&quot;:private]=&gt; NULL } [h0cker@iZ232w1qo8eZ ~]$ cat test_wu_1.php &lt;?php $options = [ &apos;heartbeatFrequencyMS&apos; =&gt; 1000, &apos;connectTimeoutMS&apos; =&gt; 600000, &apos;socketTimeoutMSG&apos; =&gt; 600000, &apos;readPreference&apos; =&gt; MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED ]; $uri = &apos;mongodb://username:&apos;.rawurlencode(&apos;xxxxxxxxxxxxxx&apos;).&apos;@xx.xx.xxx.xxx:port&apos;; $manager = new MongoDB\\Driver\\Manager($uri, $options); $where =[]; $options = [&apos;sort&apos;=&gt;[&apos;_id&apos;=&gt;-1]]; try{ for($i=0;$i&lt;5;$i++){ $query = new MongoDB\\Driver\\Query($where, $options); sleep(400); $cursor = $manager-&gt;executeQuery(&quot;project_name_sb1.users&quot;, $query); foreach ($cursor as $document) { echo &quot;进程ID:&quot;,getmypid(),&quot;\\t&quot;,$document-&gt;name,PHP_EOL; break; } } }catch(Exception $e) { var_dump($e); } TEST3[h0cker@iZ232w1qo8eZ ~]$ /X0hcker/h0cker/h0cker/usr/php-7.1.0/bin/php test_wu_1.php 进程ID:19525 object(MongoDB\\Driver\\Exception\\ConnectionTimeoutException)#113 (7) { [&quot;message&quot;:protected]=&gt; string(114) &quot;No suitable servers found (`serverSelectionTryOnce` set): [connection closed calling ismaster on &apos;xx.xx.xxx.xxx:port&apos;]&quot; [&quot;string&quot;:&quot;Exception&quot;:private]=&gt; string(0) &quot;&quot; [&quot;code&quot;:protected]=&gt; int(13053) [&quot;file&quot;:protected]=&gt; string(31) &quot;/data/X0hcker/X0hcker/test_wu_1.php&quot; [&quot;line&quot;:protected]=&gt; int(24) [&quot;trace&quot;:&quot;Exception&quot;:private]=&gt; array(1) { [0]=&gt; array(6) { [&quot;file&quot;]=&gt; string(31) &quot;/data/X0hcker/X0hcker/test_wu_1.php&quot; [&quot;line&quot;]=&gt; int(24) [&quot;function&quot;]=&gt; string(12) &quot;executeQuery&quot; [&quot;class&quot;]=&gt; string(22) &quot;MongoDB\\Driver\\Manager&quot; [&quot;type&quot;]=&gt; string(2) &quot;-&gt;&quot; [&quot;args&quot;]=&gt; array(2) { [0]=&gt; string(17) &quot;project_name_sb1.users&quot; [1]=&gt; object(MongoDB\\Driver\\Query)#4 (3) { [&quot;filter&quot;]=&gt; object(stdClass)#114 (0) { } [&quot;options&quot;]=&gt; object(stdClass)#116 (1) { [&quot;sort&quot;]=&gt; object(stdClass)#115 (1) { [&quot;_id&quot;]=&gt; int(-1) } } [&quot;readConcern&quot;]=&gt; NULL } } } } [&quot;previous&quot;:&quot;Exception&quot;:private]=&gt; NULL } [h0cker@iZ232w1qo8eZ ~]$ cat test_wu_1.php &lt;?php $options = [ &apos;heartbeatFrequencyMS&apos; =&gt; 1000, &apos;connectTimeoutMS&apos; =&gt; 600000, &apos;socketCheckIntervalMS&apos; =&gt; 1000, &apos;socketTimeoutMSG&apos; =&gt; 600000, //&apos;readPreference&apos; =&gt; MongoDB\\Driver\\ReadPreference::RP_SECONDARY_PREFERRED ]; $uri = &apos;mongodb://username:&apos;.rawurlencode(&apos;xxxxxxxxxxxxxx&apos;).&apos;@xx.xx.xxx.xxx:port&apos;; $manager = new MongoDB\\Driver\\Manager($uri, $options); $where =[]; $options = [&apos;sort&apos;=&gt;[&apos;_id&apos;=&gt;-1]]; try{ for($i=0;$i&lt;5;$i++){ $query = new MongoDB\\Driver\\Query($where, $options); sleep(400); $cursor = $manager-&gt;executeQuery(&quot;project_name_sb1.users&quot;, $query); foreach ($cursor as $document) { echo &quot;进程ID:&quot;,getmypid(),&quot;\\t&quot;,$document-&gt;name,PHP_EOL; break; } } }catch(Exception $e) { var_dump($e); } TCPDUMP 抓包php7 mongodb1.2.9 副本集 同网段[root@iZ232w1qo8eZ ~]# tcpdump -i eth0 &quot;host 10.5.0.8 and port 99999&quot; -t -n tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [S], seq 818492780, win 14600, options [mss 1460,nop,nop,sackOK,nop,wscale 9], length 0 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [S.], seq 3246913933, ack 818492781, win 14600, options [mss 1460,nop,nop,sackOK,nop,wscale 9], length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 1, win 29, length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 1:357, ack 1, win 29, length 356 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [.], ack 357, win 31, length 0 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 1:429, ack 357, win 31, length 428 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 429, win 31, length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 357:529, ack 429, win 31, length 172 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 429:624, ack 529, win 33, length 195 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 529:729, ack 624, win 33, length 200 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 624:748, ack 729, win 35, length 124 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 729:825, ack 748, win 33, length 96 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 748:842, ack 825, win 35, length 94 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 825:879, ack 842, win 33, length 54 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 842:895, ack 879, win 35, length 53 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 895, win 33, length 0 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [.], ack 879, win 35, length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 895, win 33, length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 879:937, ack 895, win 33, length 58 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 895:1323, ack 937, win 35, length 428 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 1323, win 35, length 0 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [P.], seq 937:991, ack 1323, win 35, length 54 IP 10.5.0.8.99999 &gt; 10.5.0.14.23507: Flags [P.], seq 1323:1376, ack 991, win 35, length 53 IP 10.5.0.14.23507 &gt; 10.5.0.8.99999: Flags [.], ack 1376, win 35, length 0 php7 mongodb1.2.9 sharding+repset 跨网段 [root@iZ232w1qo8eZ ~]# tcpdump -i eth0 &quot;host xx.xx.xxx.xxx and port 88888&quot; -t -n tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [S], seq 3082498855, win 14600, options [mss 1460,sackOK,TS val 1239088868 ecr 0,nop,wscale 9], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [S.], seq 3290624131, ack 3082498856, win 14480, options [mss 1460,sackOK,TS val 1826673145 ecr 1239088868,nop,wscale 9], length 0 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 1, win 29, options [nop,nop,TS val 1239088869 ecr 1826673145], length 0 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 1:345, ack 1, win 29, options [nop,nop,TS val 1239088869 ecr 1826673145], length 344 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [.], ack 345, win 31, options [nop,nop,TS val 1826673145 ecr 1239088869], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [P.], seq 1:213, ack 345, win 31, options [nop,nop,TS val 1826673145 ecr 1239088869], length 212 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 213, win 31, options [nop,nop,TS val 1239088869 ecr 1826673145], length 0 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 345:517, ack 213, win 31, options [nop,nop,TS val 1239088869 ecr 1826673145], length 172 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [P.], seq 213:408, ack 517, win 33, options [nop,nop,TS val 1826673148 ecr 1239088869], length 195 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 517:717, ack 408, win 33, options [nop,nop,TS val 1239088890 ecr 1826673148], length 200 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [P.], seq 408:532, ack 717, win 35, options [nop,nop,TS val 1826673167 ecr 1239088890], length 124 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 717:813, ack 532, win 33, options [nop,nop,TS val 1239088890 ecr 1826673167], length 96 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [P.], seq 532:626, ack 813, win 35, options [nop,nop,TS val 1826673168 ecr 1239088890], length 94 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 813:867, ack 626, win 33, options [nop,nop,TS val 1239088891 ecr 1826673168], length 54 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [P.], seq 626:679, ack 867, win 35, options [nop,nop,TS val 1826673168 ecr 1239088891], length 53 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 679, win 33, options [nop,nop,TS val 1239088933 ecr 1826673168], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [.], ack 867, win 35, options [nop,nop,TS val 1826973209 ecr 1239088933], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [.], ack 867, win 35, options [nop,nop,TS val 1827003209 ecr 1239088933], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [.], ack 867, win 35, options [nop,nop,TS val 1827033209 ecr 1239088933], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [R.], seq 679, ack 867, win 35, options [nop,nop,TS val 1827063209 ecr 1239088933], length 0 IP 10.5.0.14.58073 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 867:925, ack 679, win 33, options [nop,nop,TS val 1239488892 ecr 1826673168], length 58 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.58073: Flags [R], seq 3290624810, win 0, length 0 python2.7 pymongo sharding+repset 跨网段[root@iZ232w1qo8eZ ~]# [root@iZ232w1qo8eZ ~]# tcpdump -i eth0 &quot;host xx.xx.xxx.xxx and port 88888&quot; -t -n tcpdump: verbose output suppressed, use -v or -vv for full protocol decode listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [S], seq 3421149159, win 14600, options [mss 1460,nop,nop,sackOK,nop,wscale 9], length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.42496: Flags [S.], seq 186285320, ack 3421149160, win 14600, options [mss 1460,nop,nop,sackOK,nop,wscale 9], length 0 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 1, win 29, length 0 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 1:59, ack 1, win 29, length 58 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.42496: Flags [.], ack 59, win 29, length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.42496: Flags [P.], seq 1:213, ack 59, win 29, length 212 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 213, win 31, length 0 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [P.], seq 59:117, ack 213, win 31, length 58 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.42496: Flags [P.], seq 213:425, ack 117, win 29, length 212 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 425, win 33, length 0 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [F.], seq 117, ack 425, win 33, length 0 IP xx.xx.xxx.xxx.88888 &gt; 10.5.0.14.42496: Flags [F.], seq 425, ack 118, win 29, length 0 IP 10.5.0.14.42496 &gt; xx.xx.xxx.xxx.88888: Flags [.], ack 426, win 33, length 0 ConnectionTimeOut和SocketTimeOut的区别：一次完整的请求包括三个阶段： 建立连接 数据传输 断开连接 如果与服务器(这里指数据库)请求建立连接的时间超过ConnectionTimeOut，就会抛 ConnectionTimeOutException，即服务器连接超时，没有在规定的时间内建立连接。 如果与服务器连接成功，就开始数据传输了。 如果服务器处理数据用时过长，超过了SocketTimeOut，就会抛出SocketTimeOutExceptin，即服务器响应超时，服务器没有在规定的时间内返回给客户端数据。 PHP的MONGODB 扩展分析PHP_MINIT_FUNCTION 初始化module时运行 PHP_MSHUTDOWN_FUNCTION 当module被卸载时运行 PHP_RINIT_FUNCTION 当一个REQUEST请求初始化时运行 PHP_RSHUTDOWN_FUNCTION 当一个REQUEST请求结束时运行 PHP_GINIT_FUNCTION 初始化全局变量时 PHP_GSHUTDOWN_FUNCTION 释放全局变量时 在MongoDB文件夹中的php_phongo.c 中/* {{{ PHP_GINIT_FUNCTION */ PHP_GINIT_FUNCTION(mongodb) { bson_mem_vtable_t bsonMemVTable = { php_phongo_malloc, php_phongo_calloc, php_phongo_realloc, php_phongo_free, }; #if PHP_VERSION_ID >= 70000 #if defined(COMPILE_DL_MONGODB) && defined(ZTS) ZEND_TSRMLS_CACHE_UPDATE(); #endif #endif memset(mongodb_globals, 0, sizeof(zend_mongodb_globals)); mongodb_globals->bsonMemVTable = bsonMemVTable; /* Initialize HashTable for persistent clients */ zend_hash_init_ex(&mongodb_globals->clients, 0, NULL, php_phongo_client_dtor, 1, 0); } /* }}} */ 声明一个全局变量mongodb_globals保存clients 在MongoDB文件夹中的php_phongo.c 中PHP_MSHUTDOWN_FUNCTION(mongodb) { (void)type; /* We don&apos;t care if we are loaded via dl() or extension= */ /* Destroy HashTable for persistent clients. The HashTable destructor will * destroy any mongoc_client_t objects contained within. */ zend_hash_destroy(&amp;MONGODB_G(clients)); bson_mem_restore_vtable(); /* Cleanup after libmongoc */ mongoc_cleanup(); UNREGISTER_INI_ENTRIES(); return SUCCESS; } 在模块卸载时会销毁mongodb的MONGODB_G(clients)客户端 理论上mongodb模块在php-fpm中是长连接 在MongoDB文件夹中的Manger.c 中PHP_METHOD(Manager, __construct) { php_phongo_manager_t *intern; zend_error_handling error_handling; char *uri_string = NULL; phongo_zpp_char_len uri_string_len = 0; zval *options = NULL; zval *driverOptions = NULL; SUPPRESS_UNUSED_WARNING(return_value) SUPPRESS_UNUSED_WARNING(return_value_ptr) SUPPRESS_UNUSED_WARNING(return_value_used) zend_replace_error_handling(EH_THROW, phongo_exception_from_phongo_domain(PHONGO_ERROR_INVALID_ARGUMENT), &amp;error_handling TSRMLS_CC); intern = Z_MANAGER_OBJ_P(getThis()); /* Separate the options and driverOptions zvals, since we may end up * modifying them in php_phongo_manager_prep_tagsets() and * php_phongo_manager_merge_context_options() below, respectively. */ if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;|s!a/!a/!&quot;, &amp;uri_string, &amp;uri_string_len, &amp;options, &amp;driverOptions) == FAILURE) { zend_restore_error_handling(&amp;error_handling TSRMLS_CC); return; } zend_restore_error_handling(&amp;error_handling TSRMLS_CC); if (options) { php_phongo_manager_prep_tagsets(options TSRMLS_CC); } if (driverOptions &amp;&amp; !php_phongo_manager_merge_context_options(driverOptions TSRMLS_CC)) { /* Exception should already have been thrown */ return; } phongo_manager_init(intern, uri_string ? uri_string : PHONGO_MANAGER_URI_DEFAULT, options, driverOptions TSRMLS_CC); } 查看 phongo_manager_init 在MongoDB文件夹中的php_phongo.c 中void phongo_manager_init(php_phongo_manager_t *manager, const char *uri_string, zval *options, zval *driverOptions TSRMLS_DC) /* {{{ */ { char *hash = NULL; size_t hash_len = 0; bson_t bson_options = BSON_INITIALIZER; mongoc_uri_t *uri = NULL; mongoc_ssl_opt_t *ssl_opt = NULL; bson_iter_t iter; #if PHP_VERSION_ID >= 70000 mongoc_client_t *client_ptr; #else mongoc_client_t **client_ptr; #endif if (!(hash = php_phongo_manager_make_client_hash(uri_string, options, driverOptions, &hash_len TSRMLS_CC))) { /* Exception should already have been thrown and there is nothing to free */ return; } #if PHP_VERSION_ID >= 70000 if((client_ptr = zend_hash_str_find_ptr(&MONGODB_G(clients), hash, hash_len)) != NULL){ MONGOC_DEBUG(\"Found client for hash: %s\\n\", hash); manager->client = client_ptr; goto cleanup; } #else if (zend_hash_find(&MONGODB_G(clients), hash, hash_len + 1, (void**) &client_ptr) == SUCCESS) { MONGOC_DEBUG(\"Found client for hash: %s\\n\", hash); manager->client = *client_ptr; goto cleanup; } #endif if (options) { phongo_zval_to_bson(options, PHONGO_BSON_NONE, &bson_options, NULL TSRMLS_CC); } /* An exception may be thrown during BSON conversion */ if (EG(exception)) { goto cleanup; } if (!(uri = php_phongo_make_uri(uri_string, &bson_options))) { phongo_throw_exception(PHONGO_ERROR_INVALID_ARGUMENT TSRMLS_CC, \"Failed to parse MongoDB URI: '%s'\", uri_string); goto cleanup; } if (!php_phongo_apply_rc_options_to_uri(uri, &bson_options TSRMLS_CC) || !php_phongo_apply_rp_options_to_uri(uri, &bson_options TSRMLS_CC) || !php_phongo_apply_wc_options_to_uri(uri, &bson_options TSRMLS_CC)) { /* Exception should already have been thrown */ goto cleanup; } if (bson_iter_init_find_case(&iter, &bson_options, \"appname\") && BSON_ITER_HOLDS_UTF8(&iter)) { const char *str = bson_iter_utf8(&iter, NULL); if (!mongoc_uri_set_appname(uri, str)) { phongo_throw_exception(PHONGO_ERROR_INVALID_ARGUMENT TSRMLS_CC, \"Invalid appname value: '%s'\", str); goto cleanup; } } ssl_opt = php_phongo_make_ssl_opt(driverOptions TSRMLS_CC); /* An exception may be thrown during SSL option creation */ if (EG(exception)) { goto cleanup; } manager->client = php_phongo_make_mongo_client(uri, ssl_opt TSRMLS_CC); if (!manager->client) { phongo_throw_exception(PHONGO_ERROR_RUNTIME TSRMLS_CC, \"Failed to create Manager from URI: '%s'\", uri_string); goto cleanup; } MONGOC_DEBUG(\"Created client hash: %s\\n\", hash); #if PHP_VERSION_ID >= 70000 zend_hash_str_update_ptr(&MONGODB_G(clients), hash, hash_len, manager->client); #else zend_hash_update(&MONGODB_G(clients), hash, hash_len + 1, &manager->client, sizeof(mongoc_client_t *), NULL); #endif cleanup: if (hash) { pefree(hash, 1); } bson_destroy(&bson_options); if (uri) { mongoc_uri_destroy(uri); } if (ssl_opt) { php_phongo_free_ssl_opt(ssl_opt); } } /* }}} */ client_ptr = zend_hash_str_find_ptr(&amp;MONGODB_G(clients), hash, hash_len) manager-&gt;client = php_phongo_make_mongo_client(uri, ssl_opt TSRMLS_CC);zend_hash_str_update_ptr(&amp;MONGODB_G(clients), hash, hash_len, manager-&gt;client); 这里会在全局变量MONGODB_G(clients)中先查找客户端连接句柄，如果找不到就会新建一个连接并保存到全局变量中，也就是实现了一个单例模式的程式 查看新连接是怎么样建立的，需要跟踪php_phongo_make_mongo_client 在php_phongo.c文件中定义static mongoc_client_t *php_phongo_make_mongo_client(const mongoc_uri_t *uri, mongoc_ssl_opt_t *ssl_opt TSRMLS_DC) /* {{{ */ { const char *mongoc_version, *bson_version; mongoc_client_t *client; #ifdef HAVE_SYSTEM_LIBMONGOC mongoc_version = mongoc_get_version(); #else mongoc_version = \"bundled\"; #endif #ifdef HAVE_SYSTEM_LIBBSON bson_version = bson_get_version(); #else bson_version = \"bundled\"; #endif MONGOC_DEBUG(\"Creating Manager, phongo-%s[%s] - mongoc-%s(%s), libbson-%s(%s), php-%s\", MONGODB_VERSION_S, MONGODB_STABILITY_S, MONGOC_VERSION_S, mongoc_version, BSON_VERSION_S, bson_version, PHP_VERSION ); client = mongoc_client_new_from_uri(uri); if (!client) { return NULL; } if (mongoc_uri_get_ssl(uri) && ssl_opt) { mongoc_client_set_ssl_opts(client, ssl_opt); } return client; } /* }}} */ 查看 client = mongoc_client_new_from_uri(uri); 在mongoc-client.c文件中定义mongoc_client_t * mongoc_client_new_from_uri (const mongoc_uri_t *uri) { mongoc_topology_t *topology; topology = mongoc_topology_new (uri, true); return _mongoc_client_new_from_uri (uri, topology); } 我们先看_mongoc_client_new_from_uri查看_mongoc_client_new_from_uri mongoc_client_t * _mongoc_client_new_from_uri (const mongoc_uri_t *uri, mongoc_topology_t *topology) { mongoc_client_t *client; const mongoc_read_prefs_t *read_prefs; const mongoc_read_concern_t *read_concern; const mongoc_write_concern_t *write_concern; const char *appname; BSON_ASSERT (uri); #ifndef MONGOC_ENABLE_SSL if (mongoc_uri_get_ssl (uri)) { MONGOC_ERROR (&quot;Can&apos;t create SSL client, SSL not enabled in this build.&quot;); return NULL; } #endif client = (mongoc_client_t *)bson_malloc0(sizeof *client); client-&gt;uri = mongoc_uri_copy (uri); client-&gt;initiator = mongoc_client_default_stream_initiator; client-&gt;initiator_data = client; client-&gt;topology = topology; client-&gt;error_api_version = MONGOC_ERROR_API_VERSION_LEGACY; client-&gt;error_api_set = false; write_concern = mongoc_uri_get_write_concern (client-&gt;uri); client-&gt;write_concern = mongoc_write_concern_copy (write_concern); read_concern = mongoc_uri_get_read_concern (client-&gt;uri); client-&gt;read_concern = mongoc_read_concern_copy (read_concern); read_prefs = mongoc_uri_get_read_prefs_t (client-&gt;uri); client-&gt;read_prefs = mongoc_read_prefs_copy (read_prefs); appname = mongoc_uri_get_option_as_utf8 (client-&gt;uri, &quot;appname&quot;, NULL); if (appname &amp;&amp; client-&gt;topology-&gt;single_threaded) { /* the appname should have already been validated */ BSON_ASSERT (mongoc_client_set_appname (client, appname)); } mongoc_cluster_init (&amp;client-&gt;cluster, client-&gt;uri, client); #ifdef MONGOC_ENABLE_SSL client-&gt;use_ssl = false; if (mongoc_uri_get_ssl (client-&gt;uri)) { /* sets use_ssl = true */ mongoc_client_set_ssl_opts (client, mongoc_ssl_opt_get_default ()); } #endif mongoc_counter_clients_active_inc (); return client; } 查看mongoc_client_default_stream_initiator mongoc_stream_t * mongoc_client_default_stream_initiator (const mongoc_uri_t *uri, const mongoc_host_list_t *host, void *user_data, bson_error_t *error) { mongoc_stream_t *base_stream = NULL; #ifdef MONGOC_ENABLE_SSL mongoc_client_t *client = (mongoc_client_t *)user_data; const char *mechanism; int32_t connecttimeoutms; #endif BSON_ASSERT (uri); BSON_ASSERT (host); #ifndef MONGOC_ENABLE_SSL if (mongoc_uri_get_ssl (uri)) { bson_set_error (error, MONGOC_ERROR_CLIENT, MONGOC_ERROR_CLIENT_NO_ACCEPTABLE_PEER, &quot;SSL is not enabled in this build of mongo-c-driver.&quot;); return NULL; } #endif switch (host-&gt;family) { #if defined(AF_INET6) case AF_INET6: #endif case AF_INET: base_stream = mongoc_client_connect_tcp (uri, host, error); break; case AF_UNIX: base_stream = mongoc_client_connect_unix (uri, host, error); break; default: bson_set_error (error, MONGOC_ERROR_STREAM, MONGOC_ERROR_STREAM_INVALID_TYPE, &quot;Invalid address family: 0x%02x&quot;, host-&gt;family); break; } #ifdef MONGOC_ENABLE_SSL if (base_stream) { mechanism = mongoc_uri_get_auth_mechanism (uri); if (client-&gt;use_ssl || (mechanism &amp;&amp; (0 == strcmp (mechanism, &quot;MONGODB-X509&quot;)))) { mongoc_stream_t *original = base_stream; base_stream = mongoc_stream_tls_new_with_hostname (base_stream, host-&gt;host, &amp;client-&gt;ssl_opts, true); if (!base_stream) { mongoc_stream_destroy (original); bson_set_error (error, MONGOC_ERROR_STREAM, MONGOC_ERROR_STREAM_SOCKET, &quot;Failed initialize TLS state.&quot;); return NULL; } connecttimeoutms = mongoc_uri_get_option_as_int32 ( uri, &quot;connecttimeoutms&quot;, MONGOC_DEFAULT_CONNECTTIMEOUTMS); if (!mongoc_stream_tls_handshake_block (base_stream, host-&gt;host, connecttimeoutms, error)) { mongoc_stream_destroy (base_stream); return NULL; } } } #endif return base_stream ? mongoc_stream_buffered_new (base_stream, 1024) : NULL; } 查看mongoc_client_connect_tcp static mongoc_stream_t * mongoc_client_connect_tcp (const mongoc_uri_t *uri, const mongoc_host_list_t *host, bson_error_t *error) { mongoc_socket_t *sock = NULL; struct addrinfo hints; struct addrinfo *result, *rp; int32_t connecttimeoutms; int64_t expire_at; char portstr [8]; int s; ENTRY; BSON_ASSERT (uri); BSON_ASSERT (host); connecttimeoutms = mongoc_uri_get_option_as_int32 ( uri, &quot;connecttimeoutms&quot;, MONGOC_DEFAULT_CONNECTTIMEOUTMS); BSON_ASSERT (connecttimeoutms); bson_snprintf (portstr, sizeof portstr, &quot;%hu&quot;, host-&gt;port); memset (&amp;hints, 0, sizeof hints); hints.ai_family = host-&gt;family; hints.ai_socktype = SOCK_STREAM; hints.ai_flags = 0; hints.ai_protocol = 0; s = getaddrinfo (host-&gt;host, portstr, &amp;hints, &amp;result); if (s != 0) { mongoc_counter_dns_failure_inc (); bson_set_error(error, MONGOC_ERROR_STREAM, MONGOC_ERROR_STREAM_NAME_RESOLUTION, &quot;Failed to resolve %s&quot;, host-&gt;host); RETURN (NULL); } mongoc_counter_dns_success_inc (); for (rp = result; rp; rp = rp-&gt;ai_next) { /* * Create a new non-blocking socket. */ if (!(sock = mongoc_socket_new (rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol))) { continue; } /* * Try to connect to the peer. */ expire_at = bson_get_monotonic_time () + (connecttimeoutms * 1000L); if (0 != mongoc_socket_connect (sock, rp-&gt;ai_addr, (socklen_t)rp-&gt;ai_addrlen, expire_at)) { char *errmsg; char errmsg_buf[BSON_ERROR_BUFFER_SIZE]; char ip[255]; mongoc_socket_inet_ntop (rp, ip, sizeof ip); errmsg = bson_strerror_r ( mongoc_socket_errno (sock), errmsg_buf, sizeof errmsg_buf); MONGOC_WARNING (&quot;Failed to connect to: %s:%d, error: %d, %s\\n&quot;, ip, host-&gt;port, mongoc_socket_errno(sock), errmsg); mongoc_socket_destroy (sock); sock = NULL; continue; } break; } if (!sock) { bson_set_error (error, MONGOC_ERROR_STREAM, MONGOC_ERROR_STREAM_CONNECT, &quot;Failed to connect to target host: %s&quot;, host-&gt;host_and_port); freeaddrinfo (result); RETURN (NULL); } freeaddrinfo (result); return mongoc_stream_socket_new (sock); } 在上面的函数中会发现connecttimeoutms参数 我们再看mongoc_topology_new mongoc_client_t * mongoc_client_new_from_uri (const mongoc_uri_t *uri) { mongoc_topology_t *topology; topology = mongoc_topology_new (uri, true); return _mongoc_client_new_from_uri (uri, topology); } 在libmongoc文件夹中的mongoc-toplogy.c 中mongoc_topology_t * mongoc_topology_new (const mongoc_uri_t *uri, bool single_threaded) { int64_t heartbeat_default; int64_t heartbeat; mongoc_topology_t *topology; mongoc_topology_description_type_t init_type; uint32_t id; const mongoc_host_list_t *hl; BSON_ASSERT (uri); topology = (mongoc_topology_t *)bson_malloc0(sizeof *topology); /* * Not ideal, but there&apos;s no great way to do this. * Base on the URI, we assume: * - if we&apos;ve got a replicaSet name, initialize to RS_NO_PRIMARY * - otherwise, if the seed list has a single host, initialize to SINGLE * - everything else gets initialized to UNKNOWN */ if (mongoc_uri_get_replica_set(uri)) { init_type = MONGOC_TOPOLOGY_RS_NO_PRIMARY; } else { hl = mongoc_uri_get_hosts(uri); if (hl-&gt;next) { init_type = MONGOC_TOPOLOGY_UNKNOWN; } else { init_type = MONGOC_TOPOLOGY_SINGLE; } } heartbeat_default = single_threaded ? MONGOC_TOPOLOGY_HEARTBEAT_FREQUENCY_MS_SINGLE_THREADED : MONGOC_TOPOLOGY_HEARTBEAT_FREQUENCY_MS_MULTI_THREADED; heartbeat = mongoc_uri_get_option_as_int32 (uri, &quot;heartbeatfrequencyms&quot;, heartbeat_default); mongoc_topology_description_init (&amp;topology-&gt;description, init_type, heartbeat); topology-&gt;description.set_name = bson_strdup(mongoc_uri_get_replica_set(uri)); topology-&gt;uri = mongoc_uri_copy (uri); topology-&gt;scanner_state = MONGOC_TOPOLOGY_SCANNER_OFF; topology-&gt;scanner = mongoc_topology_scanner_new (topology-&gt;uri, _mongoc_topology_scanner_setup_err_cb, _mongoc_topology_scanner_cb, topology); topology-&gt;single_threaded = single_threaded; if (single_threaded) { /* Server Selection Spec: * * &quot;Single-threaded drivers MUST provide a &quot;serverSelectionTryOnce&quot; * mode, in which the driver scans the topology exactly once after * server selection fails, then either selects a server or raises an * error. * * &quot;The serverSelectionTryOnce option MUST be true by default.&quot; */ topology-&gt;server_selection_try_once = mongoc_uri_get_option_as_bool ( uri, &quot;serverselectiontryonce&quot;, true); } else { topology-&gt;server_selection_try_once = false; } topology-&gt;server_selection_timeout_msec = mongoc_uri_get_option_as_int32( topology-&gt;uri, &quot;serverselectiontimeoutms&quot;, MONGOC_TOPOLOGY_SERVER_SELECTION_TIMEOUT_MS); topology-&gt;local_threshold_msec = mongoc_uri_get_option_as_int32 ( topology-&gt;uri, &quot;localthresholdms&quot;, MONGOC_TOPOLOGY_LOCAL_THRESHOLD_MS); /* Total time allowed to check a server is connectTimeoutMS. * Server Discovery And Monitoring Spec: * * &quot;The socket used to check a server MUST use the same connectTimeoutMS as * regular sockets. Multi-threaded clients SHOULD set monitoring sockets&apos; * socketTimeoutMS to the connectTimeoutMS.&quot; */ topology-&gt;connect_timeout_msec = mongoc_uri_get_option_as_int32( topology-&gt;uri, &quot;connecttimeoutms&quot;, MONGOC_DEFAULT_CONNECTTIMEOUTMS); mongoc_mutex_init (&amp;topology-&gt;mutex); mongoc_cond_init (&amp;topology-&gt;cond_client); mongoc_cond_init (&amp;topology-&gt;cond_server); for ( hl = mongoc_uri_get_hosts (uri); hl; hl = hl-&gt;next) { mongoc_topology_description_add_server (&amp;topology-&gt;description, hl-&gt;host_and_port, &amp;id); mongoc_topology_scanner_add (topology-&gt;scanner, hl, id); } return topology; } 会发现在uri里面有这几个参数，所以在uri里设置吧serverselectiontryonceserverselectiontimeoutmslocalthresholdmsconnecttimeoutms 设置了以后就不报错了，但是我们还得接着看完执行函数 在获取句柄后，执行executeQuery函数，所以现在我们来看executeQuery 在MongoDB文件夹中的Manger.c 中PHP_METHOD(Manager, executeQuery) { char *namespace; phongo_zpp_char_len namespace_len; zval *query; zval *readPreference = NULL; DECLARE_RETURN_VALUE_USED SUPPRESS_UNUSED_WARNING(return_value_ptr) if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;sO|O!&quot;, &amp;namespace, &amp;namespace_len, &amp;query, php_phongo_query_ce, &amp;readPreference, php_phongo_readpreference_ce) == FAILURE) { return; } phongo_execute_query(getThis(), namespace, query, readPreference, -1, return_value, return_value_used TSRMLS_CC); } 查看 phongo_execute_query ，注意这里的getThis()其实就是Manger的实例 在MongoDB文件夹中的php_phongo.c 中int phongo_execute_query(zval *manager, const char *namespace, zval *zquery, zval *zreadPreference, int server_id, zval *return_value, int return_value_used TSRMLS_DC) /* {{{ */ { mongoc_client_t *client; const php_phongo_query_t *query; mongoc_cursor_t *cursor; char *dbname; char *collname; mongoc_collection_t *collection; client = Z_MANAGER_OBJ_P(manager)->client; if (!phongo_split_namespace(namespace, &dbname, &collname)) { phongo_throw_exception(PHONGO_ERROR_INVALID_ARGUMENT TSRMLS_CC, \"%s: %s\", \"Invalid namespace provided\", namespace); return false; } collection = mongoc_client_get_collection(client, dbname, collname); efree(dbname); efree(collname); query = Z_QUERY_OBJ_P(zquery); if (query->read_concern) { mongoc_collection_set_read_concern(collection, query->read_concern); } cursor = mongoc_collection_find_with_opts(collection, query->filter, query->opts, phongo_read_preference_from_zval(zreadPreference TSRMLS_CC)); mongoc_collection_destroy(collection); /* mongoc issues a warning we need to catch somehow */ if (!cursor) { phongo_throw_exception(PHONGO_ERROR_MONGOC_FAILED TSRMLS_CC, \"%s\", \"FIXME: Couldn't create cursor...\"); return false; } if (server_id > 0 && !mongoc_cursor_set_hint(cursor, server_id)) { phongo_throw_exception(PHONGO_ERROR_MONGOC_FAILED TSRMLS_CC, \"%s\", \"Could not set cursor server_id\"); return false; } if (!phongo_advance_cursor_and_check_for_error(cursor TSRMLS_CC)) { return false; } if (!return_value_used) { mongoc_cursor_destroy(cursor); return true; } phongo_cursor_init_for_query(return_value, manager, cursor, namespace, zquery, zreadPreference TSRMLS_CC); return true; } /* }}} */ client = Z_MANAGER_OBJ_P(manager)-&gt;client; 获取manger中的客户端连接 collection = mongoc_client_get_collection(client, dbname, collname); 获取客户端连接中的collection句柄 query = Z_QUERY_OBJ_P(zquery); cursor = mongoc_collection_find_with_opts(collection, query-&gt;filter, query-&gt;opts, phongo_read_preference_from_zval(zreadPreference TSRMLS_CC)); 执行query的内容 mongoc_collection_destroy(collection); 销毁collection phongo_cursor_init_for_query(return_value, manager, cursor, namespace, zquery, zreadPreference TSRMLS_CC); 将结果集放在return_value 以上过程出现的函数需要细节的查看1.查看 mongoc_client_get_collection 查看 mongoc_client_get_collection在libmongoc文件夹中的mongoc-client.c/* *-------------------------------------------------------------------------- * * mongoc_client_get_collection -- * * This function returns a newly allocated collection structure. * * @db should be the name of the database, such as &quot;test&quot;. * @collection should be the name of the collection such as &quot;test&quot;. * * The above would result in the namespace &quot;test.test&quot;. * * You should free this structure when you are done with it using * mongoc_collection_destroy(). * * Returns: * A newly allocated mongoc_collection_t that should be freed with * mongoc_collection_destroy(). * * Side effects: * None. * *-------------------------------------------------------------------------- */ mongoc_collection_t * mongoc_client_get_collection (mongoc_client_t *client, const char *db, const char *collection) { BSON_ASSERT (client); BSON_ASSERT (db); BSON_ASSERT (collection); return _mongoc_collection_new(client, db, collection, client-&gt;read_prefs, client-&gt;read_concern, client-&gt;write_concern); } 查看 _mongoc_collection_new 在libmongoc文件夹中的mongoc-collection.cmongoc_collection_t * _mongoc_collection_new (mongoc_client_t *client, const char *db, const char *collection, const mongoc_read_prefs_t *read_prefs, const mongoc_read_concern_t *read_concern, const mongoc_write_concern_t *write_concern) { mongoc_collection_t *col; ENTRY; BSON_ASSERT (client); BSON_ASSERT (db); BSON_ASSERT (collection); col = (mongoc_collection_t *)bson_malloc0(sizeof *col); col-&gt;client = client; col-&gt;write_concern = write_concern ? mongoc_write_concern_copy(write_concern) : mongoc_write_concern_new(); col-&gt;read_concern = read_concern ? mongoc_read_concern_copy(read_concern) : mongoc_read_concern_new(); col-&gt;read_prefs = read_prefs ? mongoc_read_prefs_copy(read_prefs) : mongoc_read_prefs_new(MONGOC_READ_PRIMARY); bson_snprintf (col-&gt;ns, sizeof col-&gt;ns, &quot;%s.%s&quot;, db, collection); bson_snprintf (col-&gt;db, sizeof col-&gt;db, &quot;%s&quot;, db); bson_snprintf (col-&gt;collection, sizeof col-&gt;collection, &quot;%s&quot;, collection); col-&gt;collectionlen = (uint32_t)strlen(col-&gt;collection); col-&gt;nslen = (uint32_t)strlen(col-&gt;ns); _mongoc_buffer_init(&amp;col-&gt;buffer, NULL, 0, NULL, NULL); col-&gt;gle = NULL; RETURN(col); } 2.查看 phongo_cursor_init_for_query 在php_phongo.c文件中static void phongo_cursor_init_for_query(zval *return_value, zval *manager, mongoc_cursor_t *cursor, const char *namespace, zval *query, zval *readPreference TSRMLS_DC) /* {{{ */ { php_phongo_cursor_t *intern; phongo_cursor_init(return_value, manager, cursor, readPreference TSRMLS_CC); intern = Z_CURSOR_OBJ_P(return_value); /* namespace has already been validated by phongo_execute_query() */ phongo_split_namespace(namespace, &intern->database, &intern->collection); #if PHP_VERSION_ID >= 70000 ZVAL_ZVAL(&intern->query, query, 1, 0); #else Z_ADDREF_P(query); intern->query = query; #endif } /* }}} */ 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"PHP7扩展开发","slug":"PHP7扩展开发","permalink":"//www.zwting.com/tags/PHP7扩展开发/"}]},{"title":"一个创业管理者的内心读白","date":"2017-05-24T00:30:00.000Z","path":"2017/05/24/manage-1/","text":"别太拿自己当回事儿创业，如果放不下架子，放不下面子，你没有机会享受高风险的回报，即使有，你也不配常常是自己的所谓“为了项目好”，最后一意孤行，闹得所有人都开心，已有的计划无法继续，所有人都失去信心，如果项目黄了，你要承担多少责任？ 最怕的是“一条鱼腥了一锅汤”举个例子，处理jshint配置能用多久呢？如果半天都搞不定，我真心不认为这样的人需要去口口声声的讲，“代码要规范”，连基本功都不过关，谈规范，只是让别人坑而已大师们尚且虚怀若谷，又何况我们呢？水瓶要么空要么满才不会逛荡，以一个空杯的心态面对世界，才能更好的适应社会。如果心智成熟，和你的老大好好沟通，降低开发风险，又能对项目有利，你的领导会高看你眼，放心把更重要的工作交给你。 知道什么该学？大晚上12点，马上要切换测试环境了，我说“在群里说一声，没睡的大伙测一下”那货说：“大家都睡了，群里沟通成本太高”。。。可你知道，这背后的真正用意是什么？你只要发了这个信息，老大们都会看到，都会记着你在辛苦的工作，至于结果，有人起来帮忙测试最好，如果没有，至少对自己也是好事儿有的时候我特别想笑，你以为学东西就是学技术么？ 我们再举个例子，别人教你东西，你愿意学或者不愿意学都要听，为啥？如果你觉得他得东西有价值你可以多听点，以后他还会给你分享如果你直接拒绝，他以后也不会给你分享了。即使你特别不想听，找个借口委婉点也好有的时候我可以给你讲12分，可你不愿意听，对不起，我讲6分就好了，为啥让自己那么累呢？关键你他妈还不给我钱。。。 学东西不要太表面，技巧性的东西在这个时代已经没有难度了，反正有各种办法查到，只是积累多少的问题的，最难的是他们背后的思考，那是实践后总结出来的真知 我折腾过很多东西，很累，但我习惯了如何快速了解新东西，并能用正确的方式使用他们，这是我的本事，那你呢？即使不会，我可以放下姿态跟人学，那你呢？ 你当我是谁？有的时候我也在想，你当我是谁？领导？还是大哥？无论哪种都好，至少有那么一些尊重我并不想美化这个词，但我得承认，尊重是人和人友好的基础.你尊重我，我教你，带你，给你做各种好的打算，我心甘情愿。如果你因为情绪不好，找我聊，或者大骂我一顿，我都可以接受，如果我做的不好，你也可以找我聊，或者大骂我一顿。即使我做的再不好，你身为我的小弟，是否要给我留够面子呢？当着那么多人，与我争执，你是我小弟么？你当我是谁？ 你知道谁是真的对你好么？天天对你笑，恭维你的人，给你涨工资，夸你的人？还是用心品吧，这世界没有免费的午餐，不会有无端的馅饼落我头上，唯一能表明也是“我还算一个有用的人”而已。 内裤穿反了，只有自己知道有很多时候，人生很无奈，比如有一个月，你的产品没有任何大的进展，对于一个创业公司是很严重的事儿，而你作为一个负责人，你会有意无意的注意到你的小伙伴的懈怠或者不尽力、不给力，我想大部分人都会很郁闷的，想不小心眼都很难。 第一，我不能去责怪他们，创业公司团队稳定是第一要务 第二，我要反思，为啥会这样呢？是因为产品计划按部就班，安排的计划让他们闭门造车么？ 我心里也没有答案的，而我能做的就是先走下去，在变革求利好。团队里首先会有人沉不住气，各种消极悲观，在创业公司是一旦不成功就会失败，损失很大。而在大公司，大不了从头再来。大公司承担这点损失，和创业公司承担这些损失的差别真是天上地下。 而我能做的只有乐观的陪着大家走下去。 某天我观察到我们的用户不爱用我们的一个功能，他们宁可微信发给我，也不愿意用，这是一个很严重的问题，于是我们所有人开会 ，讨论这个问题，团队像炸了窝一样，各抒己见，异常活跃，最总给出了一个很好的解决方案，并且把0.8之后的发展思路也捋顺了。所有人都很激动，士气里面都上来了。 人生真是很奇妙，创业对我做的改造最多的是心态，承受着巨大的压力，就好比“内裤穿反了，只有自己知道”一样，剩下的事儿就是遇到什么问题解决什么问题，只要尽力不后悔就可以了。 作为一个技术负责人，一往无前的冲，把事情做好就可以给团队很大的勇气和动力，另外要做的就是和小伙伴们一起肩并肩互相扶持，创业不一定成功，坚持不下去是一定不会成功的。 关于推卸责任我不喜欢这个人代码，我也不喜欢那个人代码，那么你有想过为什么嘛？我再退一步讲，你觉得别人会喜欢你的代码么？如果你真的牛逼，你有代码洁癖，把所有的代码都整理的井井有条，制定规范，所有人都觉得好（不一定全用），那么你真的很牛逼，必须提职加薪，想做管理做管理，想当专家当专家，因为这种人是真的人才当松散2周，一个sprint没有完成，开发要求2天修补bug，我其实想问，你真的好意思要么？这2天修补bug的时间，会导致整个开发计划延后2天，下一个冲刺无法正常完成。。。形成惯性，以后的计划都无法正常完成。。。。。我郁闷的不是这2天，而是羞耻心和责任心的缺失。 羞耻心和责任心才是进步的动力如果你真的在这2周很努力的去做了，我觉得这个延期可以理解，但是后面要想办法补上。因为你觉得自己没做好，才会努力去学习，改进，这才是成长的动力。另外你真的补上了，会让别人对你很信任。人和人相处到最后实际上就是尊重和信任，无它。人有脸，树有皮啊，谁能想到我写这段文字的时候，内心是多么的凄凉，可事实真的是真的，有人的人是真的真的没有 别逼着我做决定我很想：“把工资一结，然后告诉那人，你不配拿我这份尊重！”忍忍吧，至少现在我还不能这样做，但是早晚有一天，出来混是要还的。 抱怨这世界上最蠢的事儿就是抱怨，不解决任何事情，又让自己很郁闷，我先反省一下自己的蠢 tomorrow is another day","tags":[{"name":"新人入职","slug":"新人入职","permalink":"//www.zwting.com/tags/新人入职/"},{"name":"培训管理","slug":"培训管理","permalink":"//www.zwting.com/tags/培训管理/"}]},{"title":"如何有效地帮助新人融入项目中","date":"2017-05-17T03:13:00.000Z","path":"2017/05/17/manage-2/","text":"新同事的学习和领悟能力自然是非常重要，然而一个好的“师傅”能够带他进门，也会极大降低学习的门槛。在这里，分享一点自己的心得，我一般按照下面几步进行介绍，而我自己在进入到一个新项目中一般也是按照这几步进行学习的。 一、项目背景 在这个环节，我会介绍为什么会有这个项目，项目的目标是什么，当前的状态以及项目组的组织结构等。这里，一定不要忘记把当前的产品展示新同事，使其有一个直观的印象。 虽然我们都是搞技术的，但是对于一个新同事，一上来就直接深入细节而抛开项目背景，显然是不合适的。因为，一个人是否可以把事情做好，除了取决于他的技术能力；还和他是否对项目或者业务方向有认可度，是否愿意投入精力去用心让项目成果。如果一个人对项目本身的目标都不认可，怎么可能会做好呢。 二、技术介绍 介绍了项目的相关情况以后，对于有经验的开发者来讲，一般都会在脑海基于原来的经验有一个大致的实现思路。那么这个时候，就可以介绍项目开发用到的技术有哪些，这些技术大概都用在什么地方。 三、工程目录结构 在这里，我可能会打开工程目录，介绍工程的组织结构，每个文件夹以及某些重要文件的作用。对于有过类似项目经验的同事来说，相对比较容易理解，而对于经验相对缺乏的同事来讲，可能只是有一个简单的印象，还需要在以后的工作中不断的加强印象。 四、功能分解 虽然很多项目大致相同，但是还是有很多细微差别之处。这个时候，我就会拿一个具体的功能，从页面到控制层，再到服务层，在到数据层，最后到数据库，完完整整地讲解一遍，把相关的代码文件都串起来。在这里，尤其要告诉新同事，如果添加一个新功能时应该添加、修改哪些文件，这些文件之间的对应以及调用关系是什么样的。经过这一步，即使经验不是很丰富的新同事，也可以照猫画虎，做出一个简单的功能。 五、发布测试 功能完成以后，自然是要上线测试的。一般情况下，在项目中都会生产、演练和测试等几套环境同时运行，本地编写和测试完成的代码，还需要发布到测试和演练环境中进行测试，确保更改有效。于是就需要，告诉他打包、发布和测试的步骤。 六、问答 在上面的五步中，肯定会有一些问题积累下来，这个时候就可以对这些问题进行深入讨论，加深对某些部分的深入理解。如果有些问题，我无法解答，就会带他找到这个方面比较有经验的同事，进行请教。 作为当代的程序员，我们不但要会写代码，更要能够把我们的经验传播出去，那么沟通能力的提高就是很紧迫的了。 一个项目的完整流程，基本上包括需求、设计（包括视觉和功能）、编码、测试、验收、上线等六个环节，当然这六个环节对整个项目不一定是串行的，但是对于一个具体的功能点来讲肯定是串行的。项目的整体进度肯定是要从达到上线标准的功能来衡量。如果功能无法正常运行，对于用户来讲，就等于零。在用户眼里只有1和0的区别，没有用户会接受完成度是80%的说法。作为开发人员，我们更希望从代码的角度去考虑这个事情：主流程实现完了，那就是80%，再加上异常的处理流程，Okay，那就是100%了。其实这个100%对于整体的功能来讲，最多只能算是30%，过了验收测试应该可以算上90%，上线稳定运行才是1。在会议上，开发人员估计的进度，换个角度应该可以理解为，这个功能编码工作量的完成度。","tags":[{"name":"新人入职","slug":"新人入职","permalink":"//www.zwting.com/tags/新人入职/"},{"name":"培训管理","slug":"培训管理","permalink":"//www.zwting.com/tags/培训管理/"}]},{"title":"怎样搭建自动式发包平台","date":"2017-05-16T07:51:47.000Z","path":"2017/05/16/team-6/","text":"业务背景在客户端和服务端都准备完备的前提下，需要实现游戏自助切换版本上线，以往都是运维手工切版本上线，且流程冗长，内容繁多，一不小心就会出问题，而且具体发版的内容需要和后端研发和运营反复核对，所以做此系统用来解决在运营期间每次发版本的问题。 业务架构 建立工作流，每个工作流由多个任务构成，任务由多个任务节点构点，任务节点和运维脚本一一对应 多个工作流中的任务标有执行次序，在执行失败时可重试 多个任务节点的执行标有执行次序 工作流依托于服务器，工作流的执行时指定所需依赖的服务器集群 运维配置工作流与操作人执行的工作流是分开使用的，配置工作流配置完毕，由执行人反复使用 有益的思考+坚持做事情，这才是真正有意思上的勤奋。勤奋不是为了努力，是为了偷懒。怎么的偷懒？就是更快地把事情做完，做好，是让自己能做以前做不到的事情！ 仅属个人观点, 可以随意转载但保留以下信息 作者：极品黑公子 邮箱：x0hcker@gmail.com 日期：2017-05-16","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"怎样搭建自动式出包平台","date":"2017-05-13T07:51:47.000Z","path":"2017/05/13/team-5/","text":"有益的思考+坚持做事情，这才是真正有意思上的勤奋。勤奋不是为了努力，是为了偷懒。怎么的偷懒？就是更快地把事情做完，做好，是让自己能做以前做不到的事情！ 游戏业务自助系统搭建游戏研发人员，在研发过程中涉及到客户端、服务端的更新，游戏客户端和游戏服务端的搭建，需要系统化编排工作流，减少手工的错误，加快搭建速度，尽量做到多人多游戏搭建，统一化工作流。首先是游戏自助发包系统，我们且不讨论前端怎么样操作，只讨论流程。我们想要实现测试或者运营自助出包，需要系统实现如下功能点：1.客户端美术资源编排客户端脚本编排游戏配置数据编排游戏数据加密码游戏数据存贮游戏服务端脚本编排 工作流程串连所需的工作流引擎 游戏全量包打包流程 游戏增量包打包流程3.服务端上传服务器流程客户端上传CDN流程 仅属个人观点, 可以随意转载但保留以下信息 作者：极品黑公子 邮箱：x0hcker@gmail.com 日期：2017-05-16","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"怎样搭建自助式GM管理平台","date":"2017-04-27T07:52:05.000Z","path":"2017/04/27/team-8/","text":"123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"怎样搭建自助式WEB业务系统","date":"2017-04-27T07:51:59.000Z","path":"2017/04/27/team-7/","text":"123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"怎样搭建自助式运维平台","date":"2017-04-27T07:51:43.000Z","path":"2017/04/27/team-4/","text":"由于运维的琐碎、故障出现的不确定性以及解决问题的不可控性的存在，所以让运维人痛并快乐着。好的架构不是设计出来的，而是一步步的演进出来的。命运就是这么难以捉摸,当你拼尽一切前进时才发现前无大道,想放弃一切后退之时却后路尽绝,最后生无可恋的纵身一跃时,希望却不知何时悄然而至。 业务背景第一阶段：标准化 OS级别基础环境一致，配置文件统一管理，软件安装目录一致，操控方式一致，监控方式一致，日志格式一致，标准化基础建设以便将来使用起来方便。 第二阶段：自动化 减少响应时间，减少人为因素的故障，对业务流程进行固化，将手工脚本化为界面可操作系统，权限管理聚合在一起，统一管控服务器等。 第三阶段：平台化 相对于自动化来讲平台化，讲究的更为人性化，屏蔽硬代码，使各方人员的操作习惯形成工作流，然后给大家更大的自主权。比如可自主的申请权限操作、可自主的发布游戏版本、可自主的查看各集群报错等。 业务架构运维工具的核心点在于任务调度平台构建的搭建。游戏运维日常内容种类繁多、零散、多变，当以定制化系统来应对时，会经常需要麻烦开发人员改动代码来适应运维场景，所以借鉴OA、CMS系统定制化工作流以此来应对，这样减少开发人员相应的工作量，也可以使运维利用自己最熟悉的 shell、python在不改动页面的前提下，尽快完成功能的开发，加快项目的落地。 第一：定制工作流基于运维人员对各个工作流统一命名、统一部署、统一使用，使得基础环境一致性得以落地使用，并将日常工作内容固化。工作流元素：工作流(多个)任务节点(具有优先级)(多个)进程节点(具有优先级)工作流参数：在执行过程中可替换在定制过程中尽量保证工作流的原子性，一个工作流只做一件事。不要出现歧义 第二：执行工作流定制的工作流可在任意集群上执行，执行工作流，工作流上可填写所需变量内容。每个任务节点单独展示，使运维方便定位问题，方便定位发生在哪个服务器。 第三：工作流程执行引擎工作流之间没有优先级、任务节点之间有优先级、进程节点之间有优先级，所以 工作流之间是并行关系，任务节点之间是串行关系，进程节点之间是串行关系。在描述这一切时忽略了服务器之间并行的关系，而所有的任务节点其实是作用到服务器上，同一个任务节点的不同进程节点是在同一台服务器上执行的。在工作流数增大或者单个工作流延时比较长的情况下，需要考虑分布执行的情况，用生产者和消费者加锁的方案解决。 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"怎样搭建CMDB管理平台","date":"2017-04-27T07:51:40.000Z","path":"2017/04/27/team-3/","text":"公司级业务支撑平台工程环境搭建需要依赖的最基本因素就是信息。信息间的层次感直接会导致业务级平台的层次构成。数据+API 是信息化工程的基本要素，我们在支撑业务搭建过程中要做到数据的集中化管理，数据在集中化过程中不断的分享数据，使数据流通起来，这样使得数据间形成一个闭环，相互促进、相互监督，在分享中提高质量，在提高过程中不断的分享。数据库的设计并非越复杂越好，简单明了，在遵守第一范式和第二范式的同时，要适当的冗余数据，业务流程复杂程序会承几何式下降。在做数据设计时尽量做到适度适时适合！ 业务背景CMDB业务视角，决定了数据的构成，请参考以下视角因素。 运维视角： 处理故障时需要了解游戏跑在IDC的集群上，所在集群的服务器IP列表，每个服务器上启动着哪些应用服务。 运营视角： 游戏上跑着逻辑平台，逻辑平台跑着区服。 商务渠道视角： 游戏上跑着SDK渠道，每个渠道的收入及留存。 广告渠道视角： 游戏上跑着广告渠道。广告为游戏引入的流量的转化率。 财务视角： 游戏跑在哪家的IDC上，各个家IDC的成本，各个游戏的成本。 平台流程视角： 统一接口输入 统一接口输出 统一游戏、集群、平台等代号 统一账号、权限 游戏研发视角： 全区全服游戏 单区单服游戏 业务架构• CMDB的数据的（全区全服）业务关系图参考 如图所示：在全区全服的游戏中，多个服务器组成一个物理集群，一个物理集群上可以跑多个逻辑集群环境用于业务环境。每个物理集群上可以跑多个区服，由业务运营决定区服是否属于同一业务逻辑集群。 如图所示：在全区全服的游戏中，一个业务模块往往由一个小规模的集群构成，解决业务模块的单点问题。在一台服务器上执行多个应用进程，提高服务器利用率，尽量使磁盘IO的业务放在RRD的服务器上，CPUIO高的业务放到内核优化的服务器上。最后由多个业务模块组成一个游戏平台，这样既可保持高可用又可提高运行效率，达到最优化的配置。 业务如此也就要求在CMDB中记录各级依赖关系。由不同服务器的进程组成不同的服务集群，各个服务器的相同业务进程挂载到负载均衡上提供服务。此间所涉及到所有元素都要在CMDB有所记录。 如图所示：以MongoDB为例，以一主一从一促裁的副本集方式向外提供服务。在搭建环境过程中，需要确认每个服务器的角色以及使用端口，数据存贮位置以及副本集名称，而且也必须要考虑多台服务器的情况。 如图所示：游戏服务模块都是由不同的程序进程组成的，比如KAKURA，它负责长连接、玩家数据的路由、玩家的聊天、消息的推送等等，由于功能的多样性会涉及到数据库，缓存、NGINX、PHP、NODEJS以及Python脚本，不同的进程放在不同的负载之后提供服务，既对内通信又对外通信。业务模块组成元素、各进程的信息、不同的负载的挂载方式都需要在CMDB中做记录. 仅属个人观点, 可以随意转载但保留以下信息 作者：极品黑公子 邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"支撑部门介绍","date":"2017-04-27T07:51:27.000Z","path":"2017/04/27/team-1/","text":"一个部门的成立，总是要有理由的；一个项目的建立，总是要有目的的。游戏支撑团队的为什么存在？简单的概括一下： 1.研发手里面开发的工作忙不过来 2.周边系统的业务偏离研发主体业务 3.自己做不专业达不到要求团队诉求 4.有些领域研发真的搞不定，需要专业的人 于是，研发体系中打杂部分分离开来，首先出现的是运维和业务支撑系统的开发人员，其他人员会随着业务的分离和专业性要求不断的出现在部门体系中。个人建议在部门最初建时最好有QA部门，因为只有生产部门没有质检部门，会出现质量下降，做而无果的现象出现，对于整个组织发展来讲，会是一个很大的损失，所以一开始就在尽量避免此类事情的发生。好下面我们来定义部门的组织加构和支撑部门到底是怎样的一个部门。 部门定义及定位 负责公司游戏项目在研发、内测、删档测试、公测、正式上线过程中基础服务搭建的部门； 研发（除游戏专项研发之外）周边辅助系统的部门； 研发企业级应用（OA类似）系统的部门； 对公司管理范围内的项目，运行运维、维护、改进、改造、监控的部门； 满足运营要求，保证游戏运营稳定工作，提高用户（包括客户，管理员）满意度的部门。 对于游戏服务架构深入发解，发现问题，并对问题进行抽象解决，消化和理解项目组需求，转换为可行的解决方案，并推而广之。 人员业务组织结构 运维：运维负责人、网络运维、系统运维、业务运维 数据：数据负责人、hadoop数据开发、hadoop脚本开发 开发：开发负责人、WEB开发、脚本开发 前端：前端负责人、前端开发人员 移动： 移动负责人、IOS开发、Android开发 测试：测试负责人、测试人员 业务内容解释 运维：负责机房服务器上下架、网络安全和通畅、服务器管理、基础环境搭建、游戏平台环境搭建。 数据：负责数据仓库、数据集市、维度数据的统筹工作以及ETL内容，为玩家消费趋势分析、游戏关卡分析、玩家行为日志分析提供数据支持， 为开发人员、运营、商务、财务、高管等人员提供数据类的API。 开发：负责社区官网、游戏平台登录支付，游戏活动、GM工具、数据报告分析、运维管理工具、OA企业应用、UCENTER用户统一入口平台、基础信息管理系统等以及基础信息化的API开放平台工作等开发工作，负责平台流程布道任务。 前端：为开发提供前端界面，保证各个浏览器的监容性，保证手机端和PC端的适用性。 移动：负责在游戏平台登录支付手机端的开发工作，屏蔽各家渠道的区别，统一化接口，实现一平台接入，各平台适用的原则，保证游戏端统一使用，减少游戏研发的工作量和接入难度。 测试：负责开发人员交付产品的验收工作。需要根据规格说明书做相关测试用例以及安排压力测试等工作。为产品质量保驾护航。 部门理念 项目立项通过做立项报告会、需求规格说明书、迭代计划任务列表保证项目的可控范围。 迭代计划执行过程中通过每天的例会、迭代计划会、迭代总结会、迭代交付形成项目开发过程中的时间燃尽图和项目的甘特图，多个时间点保证目标的正确性和及时准确性保证项目进度的正常进行。 项目完毕后，通过项目总结会向需求方做最后项目的交付，开发、测试、运维和用户明确各环节负责人，保证线上环境的持续性可用。 项目落地后需为用户提供及时准确的问题回馈手段，保证线上的可用和下次迭代功能的收集工作。 技术人员方向：技术架构师+业务架构师。技术服务于业务的成长，业务带来技术的提高 管理人员方向：利用敏捷管理的理念，对于团队依照业务层动态来组建团队，通过几个项目的磨合达到团队规模可控，工作流程可复制、技术和管理理念可进化的团队。 对新事务的态度：采用稳定通用性技术方案，保证项目的完成度。对新技术的态度，提倡自我调研分享，部门负责人同意之后，在新项目中小范围实施测试，各方同意后大面积布道使用。 123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]},{"title":"目录索引","date":"2017-04-04T09:09:59.000Z","path":"2017/04/04/team-0/","text":"目录引言1. 支撑部门介绍1.１ 部门定义及组织架构1.2 部门业务定位1.３ 部门管理理念2.业务环境概述2.1 游戏服务器架构2.1 支撑体系架构3.怎样搭建CMDB管理平台3.1 业务背景3.2 业务架构3.3 数据组织结构４.怎样搭建自助式运维平台4.1 业务背景4.2 业务架构4.3 服务器结构5.怎样搭建手游自助式出包平台6.怎样搭建自助式游戏业务系统7.怎样搭建自助式WEB业务系统8.怎样搭建自助式GM管理平台9.怎样搭建登录充账平台10.怎样搭建广告平台11.怎样搭建数据管理平台123仅属个人观点, 可以随意转载但保留以下信息作者：极品黑公子邮箱：x0hcker@gmail.com","tags":[{"name":"运维","slug":"运维","permalink":"//www.zwting.com/tags/运维/"},{"name":"开发","slug":"开发","permalink":"//www.zwting.com/tags/开发/"},{"name":"大数据","slug":"大数据","permalink":"//www.zwting.com/tags/大数据/"},{"name":"QA","slug":"QA","permalink":"//www.zwting.com/tags/QA/"},{"name":"SDK开发","slug":"SDK开发","permalink":"//www.zwting.com/tags/SDK开发/"},{"name":"技术管理","slug":"技术管理","permalink":"//www.zwting.com/tags/技术管理/"}]}]